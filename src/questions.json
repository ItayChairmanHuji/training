[
  {
    "id": "PRB-1",
    "chapter": "",
    "question": "Problems outlined in grey make up the representative question set. This set of prob-\nlems is intended to cover the most essential ideas in each section. These problems are usually\nhighly typical of what you\u2019d see on an interview, although some of them are atypical but\ncarry an important moral. If you \ufb01nd yourself uncon\ufb01dent with the idea behind one of these,\nit\u2019s probably a good idea to practice similar problems. This representative question set is our\nsuggestion for a minimal selection of problems to work on. You are highly encouraged to\nwork on more.",
    "solution": "\u25a0\nIf you \ufb01nd yourself at a real stand-off, go ahead and look for a clue in one of the\nrecommended theory books. Think about it for a while, and don\u2019t be afraid to read\nback in the notes to look for a key idea that will help you proceed. If you still can\u2019t\nsolve the problem, well, we included the Solutions section for a reason! As you\u2019re\nreading the solutions, try hard to understand why we took the steps we did, instead\nof memorizing step-by-step how to solve that one particular problem.\nIf you struggled with a question quite a lot, it\u2019s probably a good idea to return to it\nin a few days. That might have been enough time for you to internalize the necessary\nideas, and you might \ufb01nd it easily conquerable. If you\u2019re still having troubles, read\nover the solution again, with an emphasis on understanding why each step makes\nsense. One of the reasons so many job candidates are required to demonstrate their\nability to resolves data science problems on the board, is that it hiring managers as-\nsume it re\ufb02ects their true problem-solving skills.\n6\nChapter 1\nHOW-TO USE THIS BOOK\nIn this volume, you will learn lots of concepts, and be asked to apply them in\na variety of situations. Often, this will involve answering one really big problem by\nbreaking it up into manageable chunks, solving those chunks, then putting the pieces\nback together. When you see a particularly long question, remain calm and look for a\nway to break it into pieces you can handle.\n1.1.4\nTypes of Problems\nTwo main types of problems are presented in this book.\nCONCEPTUAL: The \ufb01rst category is meant to test and improve your understanding\nof basic underlying concepts. These often involve many mathematical calculations.\nThey range in dif\ufb01culty from very basic reviews of de\ufb01nitions to problems that require\nyou to be thoughtful about the concepts covered in the section.\nAn example in Information Theory follows."
  },
  {
    "id": "PRB-2",
    "chapter": "",
    "question": "What is the distribution of maximum entropy, that is, the distribution which has the\nmaximum entropy among all distributions on the bounded interval [a, b],(\u2212\u221e, +\u221e)",
    "solution": "The uniform distribution has the maximum entropy among all distributions on the\nbounded interval: [a, b],(\u2212\u221e, +\u221e).\nThe variance of U(a, b) is \u03c32 = 1/12(b \u2212 a)2.\nTherefore the entropy is:\n1/2 log 12 + log \u03c3.\n(1.1)\n\u25a0\nAPPLICATION: Problems in this category are for practicing skills. It\u2019s not enough to\nunderstand the philosophical grounding of an idea: you have to be able to apply it in\nappropriate situations. This takes practice! mostly in Python or in one of the available\nDeep Learning Libraries such as PyTorch.\nAn example in PyTorch follows.\n7\n1.1. INTRODUCTION"
  },
  {
    "id": "PRB-3",
    "chapter": "",
    "question": "Describe in your own words, what is the purpose of the following code in the context of\ntraining a Convolutional Neural Network.\n1\nself.transforms = []\n2\nif rotate:\n3\nself.transforms.append(RandomRotate())\n4\nif flip:\n5\nself.transforms.append(RandomFlip())",
    "solution": "During the training of a Convolutional Neural Network, data augmentation, and to some\nextent dropout are used as core methods to decrease over\ufb01tting. Data augmentation is a regu-\nlarization scheme that synthetically expands the data-set by utilizing label-preserving trans-\nformations to add more invariant examples of the same data samples. It is most commonly\nperformed in real time on the CPU during the training phase whilst the actual training mode\ntakes place on the GPU. This may consist for instance, random rotations, random \ufb02ips, zoom-\ning, spatial translations etc.\n\u25a0\n8\nKINDERGARTEN\nPART II\nCHAPTER\n2\nLOGISTIC REGRESSION\nYou should call it entropy for two reasons. In the \ufb01rst place, your uncertainty\nfunction has been used in statistical mechanics under that name. In the second\nplace, and more importantly, no one knows what entropy really is, so in a debate\nyou will always have the advantage.\n\u2014 John von Neumann to Claude Shannon\nContents\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\nProblems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\nGeneral Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\nOdds, Log-odds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\nThe Sigmoid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15\nTruly Understanding Logistic Regression\n. . . . . . . . . . . . . . . . .\n16\nThe Logit Function and Entropy\n. . . . . . . . . . . . . . . . . . . . . .\n22\nPython/PyTorch/CPP . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n23\nSolutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n27\nGeneral Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n27\nOdds, Log-odds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n29\nThe Sigmoid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n32\nTruly Understanding Logistic Regression\n. . . . . . . . . . . . . . . . .\n33\nThe Logit Function and Entropy\n. . . . . . . . . . . . . . . . . . . . . .\n38\nPython, PyTorch, CPP\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n38\n2.1. INTRODUCTION\n2.1\nIntroduction\nM\nUltivariable methods are routinely utilized in statistical analyses across a\nwide range of domains. Logistic regression is the most frequently used\nmethod for modelling binary response data and binary classi\ufb01cation.\nWhen the response variable is binary, it characteristically takes the form of 1/0,\nwith 1 normally indicating a success and 0 a failure. Multivariable methods usually\nassume a relationship between two or more independent, predictor variables, and\none dependent, response variable. The predicted value of a response variable may be\nexpressed as a sum of products, wherein each product is formed by multiplying the\nvalue of the variable and its coef\ufb01cient. How the coef\ufb01cients are computed? from a\nrespective data set. Logistic regression is heavily used in supervised machine learning\nand has become the workhorse for both binary and multiclass classi\ufb01cation problems.\nMany of the questions introduced in this chapter are crucial for truly understanding\nthe inner-workings of arti\ufb01cial neural networks.\n2.2\nProblems\n2.2.1\nGeneral Concepts"
  },
  {
    "id": "PRB-4",
    "chapter": "",
    "question": "True or False: For a \ufb01xed number of observations in a data set, introducing more vari-\nables normally generates a model that has a better \ufb01t to the data. What may be the drawback\nof such a model \ufb01tting strategy?",
    "solution": "True. However, when an excessive and unnecessary number of variables is used in a lo-\ngistic regression model, peculiarities (e.g., speci\ufb01c attributes) of the underlying data set dis-\nproportionately affect the coef\ufb01cients in the model, a phenomena commonly referred to as\n\u201cover\ufb01tting\u201d. Therefore, it is important that a logistic regression model does not start training\nwith more variables than is justi\ufb01ed for the given number of observations.\n\u25a0\n27\n2.3. SOLUTIONS"
  },
  {
    "id": "PRB-5",
    "chapter": "",
    "question": "De\ufb01ne the term \u201codds of success\u201d both qualitatively and formally. Give a numerical\nexample that stresses the relation between probability and odds of an event occurring.",
    "solution": "The odds of success are de\ufb01ned as the ratio between the probability of success p \u2208 [0, 1]\nand the probability of failure 1 \u2212 p. Formally:\nOdds(p) \u2261\n\ufffd\np\n1 \u2212 p\n\ufffd\n.\n(2.8)\nFor instance, assuming the probability of success of an event is p = 0.7. Then, in our\nexample, the odds of success are 7/3, or 2.333 to 1. Naturally, in the case of equal probabilities\nwhere p = 0.5, the odds of success is 1 to 1.\n\u25a0"
  },
  {
    "id": "PRB-6",
    "chapter": "",
    "question": "1. De\ufb01ne what is meant by the term \"interaction\", in the context of a logistic regression\npredictor variable.\n12\nChapter 2\nLOGISTIC REGRESSION\n2. What is the simplest form of an interaction? Write its formulae.\n3. What statistical tests can be used to attest the signi\ufb01cance of an interaction term?",
    "solution": "1. An interaction is the product of two single predictor variables implying a non-additive\neffect.\n2. The simplest interaction model includes a predictor variable formed by multiplying two\nordinary predictors. Let us assume two variables X and Z. Then, the logistic regression\nmodel that employs the simplest form of interaction follows:\n\u03b20 + \u03b21X + \u03b22Z + \u03b23XZ,\n(2.9)\nwhere the coef\ufb01cient for the interaction term XZ is represented by predictor \u03b23.\n3. For testing the contribution of an interaction, two principal methods are commonly\nemployed; the Wald chi-squared test or a likelihood ratio test between the model with\nand without the interaction term. Note: How does interaction relates to information\ntheory? What added value does it employ to enhance model performance?\n\u25a0"
  },
  {
    "id": "PRB-7",
    "chapter": "",
    "question": "True or False: In machine learning terminology, unsupervised learning refers to the\nmapping of input covariates to a target response variable that is attempted at being predicted\nwhen the labels are known.",
    "solution": "False. This is exactly the de\ufb01nition of supervised learning; when labels are known then\nsupervision guides the learning process.\n\u25a0\n28\nChapter 2\nLOGISTIC REGRESSION"
  },
  {
    "id": "PRB-8",
    "chapter": "",
    "question": "Complete the following sentence: In the case of logistic regression, the response vari-\nable is the log of the odds of being classi\ufb01ed in [...].",
    "solution": "In the case of logistic regression, the response variable is the log of the odds of being clas-\nsi\ufb01ed in a group of binary or multi-class responses. This de\ufb01nition essentially demonstrates\nthat odds can take the form of a vector.\n\u25a0"
  },
  {
    "id": "PRB-9",
    "chapter": "",
    "question": "Describe how in a logistic regression model, a transformation to the response variable is\napplied to yield a probability distribution. Why is it considered a more informative repres-\nentation of the response?",
    "solution": "When a transformation to the response variable is applied, it yields a probability distribu-\ntion over the output classes, which is bounded between 0 and 1; this transformation can be\nemployed in several ways, e.g., a softmax layer, the sigmoid function or classic normalization.\nThis representation facilitates a soft-decision by the logistic regression model, which permits\nconstruction of probability-based processes over the predictions of the model. Note: What are\nthe pros and cons of each of the three aforementioned transformations?\n\u25a0"
  },
  {
    "id": "PRB-10",
    "chapter": "",
    "question": "Complete the following sentence: Minimizing the negative log likelihood also means\nmaximizing the [...] of selecting the [...] class.\n2.2.2\nOdds, Log-odds",
    "solution": "Minimizing the negative log likelihood also means maximizing the likelihood of selecting\nthe correct class.\n\u25a0\n2.3.2\nOdds, Log-odds"
  },
  {
    "id": "PRB-11",
    "chapter": "",
    "question": "Assume the probability of an event occurring is p = 0.1.\n1. What are the odds of the event occurring?.\n2. What are the log-odds of the event occurring?.\n13\n2.2. PROBLEMS\n3. Construct the probability of the event as a ratio that equals 0.1.",
    "solution": "1. The odds of the event occurring are, by de\ufb01nition:\nodds = (0.1\n0.9) = 0.11.\n(2.10)\n2. The log-odds of the event occurring are simply taken as the log of the odds:\nlog-odds = ln(0.1/0.9) = \u22122.19685.\n(2.11)\n3. The probability may be constructed by the following representation:\nprobability =\nodds\nodds + 1 = 0.11\n1.11 = 0.1,\n(2.12)\n29\n2.3. SOLUTIONS\nor, alternatively:\np =\nexp (ln odds)\nexp (ln odds) + 1 = 0.11\n1.11 = 0.1.\n(2.13)\nNote: What is the intuition behind this representation?\n\u25a0"
  },
  {
    "id": "PRB-12",
    "chapter": "",
    "question": "True or False: If the odds of success in a binary response is 4, the corresponding probab-\nility of success is 0.8.",
    "solution": "True. By de\ufb01nition of odds, it is easy to notice that p = 0.8 satis\ufb01es the following relation:\nodds = (0.8\n0.2) = 4\n(2.14)\n\u25a0"
  },
  {
    "id": "PRB-13",
    "chapter": "",
    "question": "Draw a graph of odds to probabilities, mapping the entire range of probabilities to\ntheir respective odds.",
    "solution": "The graph of odds to probabilities is depicted in Figure 2.12.\n0,1\n0,2\n0,3\n0,4\n0,5\n0,6\n0,7\n0,8\n0,9\n2,0\n4,0\n6,0\n8,0\n10,0\nProbability\nOdds\nodds(p) =\np\n1\u2212p\nFIGURE 2.12: Odds vs. probability values.\n\u25a0\n30\nChapter 2\nLOGISTIC REGRESSION"
  },
  {
    "id": "PRB-14",
    "chapter": "",
    "question": "The logistic regression model is a subset of a broader range of machine learning models\nknown as generalized linear models (GLMs), which also include analysis of variance (AN-\nOVA), vanilla linear regression, etc. There are three components to a GLM; identify these\nthree components for binary logistic regression.",
    "solution": "A binary logistic regression GLM consists of there components:\n1. Random component: refers to the probability distribution of the response variable (Y ),\ne.g., binomial distribution for Y in the binary logistic regression, which takes on the\nvalues Y = 0 or Y = 1.\n2. Systematic component: describes the explanatory variables:\n(X1, X2, ...) as a combination of linear predictors. The binary case does not constrain\nthese variables to any degree.\n3. Link function: speci\ufb01es the link between random and systematic components. It says\nhow the expected value of the response relates to the linear predictor of explanatory\nvariables.\nNote: Assume that Y denotes whether a human voice activity was detected (Y = 1)\nor not (Y = 0) in a give time frame. Propose two systematic components and a link\nfunction adjusted for this task.\n\u25a0"
  },
  {
    "id": "PRB-15",
    "chapter": "",
    "question": "Let us consider the logit transformation, i.e., log-odds. Assume a scenario in which the\nlogit forms the linear decision boundary:\nlog\n\ufffdPr(Y = 1|X)\nPr(Y = 0|X)\n\ufffd\n= \u03b80 + \u03b8TX,\n(2.1)\nfor a given vector of systematic components X and predictor variables \u03b8. Write the mathem-\natical expression for the hyperplane that describes the decision boundary.",
    "solution": "The hyperplane is simply de\ufb01ned by:\n\u03b80 + \u03b8TX = 0.\n(2.15)\nNote: Recall the use of the logit function and derive this decision boundary rigorously.\n\u25a0"
  },
  {
    "id": "PRB-16",
    "chapter": "",
    "question": "True or False: The logit function and the natural logistic (sigmoid) function are inverses\nof each other.\n14\nChapter 2\nLOGISTIC REGRESSION\n2.2.3\nThe Sigmoid\nThe sigmoid (Fig. 2.1) also known as the logistic function, is widely used in binary\nclassi\ufb01cation and as a neuron activation function in arti\ufb01cial neural networks.\n\u22121,0 \u22120,8 \u22120,6 \u22120,4 \u22120,2\n0,2\n0,4\n0,6\n0,8\n1,0\n0,2\n0,4\n0,6\n0,8\n1,0\nx\ny\n\u03c3(x) =\n1\n1+e\u22124x\n\u03c3(x) =\n1\n1+e\u221215x\nFIGURE 2.1: Examples of two sigmoid functions.",
    "solution": "True. The logit function is de\ufb01ned as:\nz(p) = logit(p) = log\n\ufffd\np\n1 \u2212 p\n\ufffd\n,\n(2.16)\n31\n2.3. SOLUTIONS\nfor any p \u2208 [0, 1]. A simple set of algebraic equations yields the inverse relation:\np(z) =\nexp z\n1 + exp z,\n(2.17)\nwhich exactly describes the relation between the output and input of the logistic function, also\nknown as the sigmoid.\n\u25a0\n2.3.3\nThe Sigmoid"
  },
  {
    "id": "PRB-17",
    "chapter": "",
    "question": "Compute the derivative of the natural sigmoid function:\n\u03c3(x) =\n1\n1 + e\u2212x \u2208 (0, 1).\n(2.2)",
    "solution": "There are various approaches to solve this problem, here we provide two; direct derivation\nor derivation via the softmax function.\n1. Direct derivation:\nd\ndx\u03c3(x) =\nd\ndx((1 + e\u2212x)\u22121) = \u2212((1 + e\u2212x)(\u22122)) d\ndx(1 + e\u2212x) =\ne\u2212x\n(1+e\u2212x)2.\n2. Softmax derivation:\nIn a classi\ufb01cation problem with mutually exclusive classes, where all of the values are\npositive and sum to one, a softmax activation function may be used. By de\ufb01nition, the\nsoftmax activation function consists of n terms, such that \u2200i \u2208 [1, n]:\nf(\u03b8i) =\ne\u03b8i\n\ufffd\nk evk =\n1\n1 + e\u2212\u03b8i \ufffd\nk\u0338=i e\u03b8k .\n(2.18)\nTo compute the partial derivative of 2.18, we treat all \u03b8k where k \u0338= i as constants and\nthen differentiate \u03b8i using regular differentiation rules. For a given \u03b8i, let us de\ufb01ne:\n\u03b2 =\n\ufffd\nk\u0338=i\ne\u03b8k,\n(2.19)\nand\nf(\u03b8i) =\n1\n1 + \u03b2e\u2212\u03b8i = (1 + \u03b2e\u2212\u03b8i)\u22121.\n(2.20)\nIt can now be shown that the derivative with respect to \u03b8i holds:\nf \u2032(\u03b8i) =\n\ufffd\n1 + \u03b2e\u2212\u03b8i\ufffd\u22122 \u03b2e\u2212\u03b8i,\n(2.21)\n32\nChapter 2\nLOGISTIC REGRESSION\nwhich can take on the informative form of:\nf \u2032(\u03b8i) = f(\u03b8i)(1 \u2212 f(\u03b8i)).\n(2.22)\nIt should be noted that 2.21 holds for any constant \u03b2, and for \u03b2 = 1 it clearly reduces\nto the sigmoid activation function.\nNote: Characterize the sigmoid function when its argument approaches 0, \u221e and \u2212\u221e.\nWhat undesired properties of the sigmoid function do this values entail when considered as an\nactivation function?\n\u25a0"
  },
  {
    "id": "PRB-18",
    "chapter": "",
    "question": "Remember that in logistic regression, the hypothesis function for some parameter vector\n\u03b2 and measurement vector x is de\ufb01ned as:\nh\u03b2(x)\n=\ng(\u03b2Tx) =\n1\n1 + e\u2212\u03b2T x\n=\nP(y = 1|x; \u03b2),\n(2.3)\n15\n2.2. PROBLEMS\nwhere y holds the hypothesis value.\nSuppose the coef\ufb01cients of a logistic regression model with independent variables are as\nfollows: \u03b20 = \u22121.5, \u03b21 = 3, \u03b22 = \u22120.5.\nAssume additionally, that we have an observation with the following values for the dependent\nvariables: x1 = 1, x2 = 5. As a result, the logit equation becomes:\nlogit = \u03b20 + \u03b21x1 + \u03b22x2.\n(2.4)\n1. What is the value of the logit for this observation?\n2. What is the value of the odds for this observation?\n3. What is the value of P(y = 1) for this observation?\n2.2.4\nTruly Understanding Logistic Regression",
    "solution": "1. The logit value is simply obtained by substituting the values of the dependent variables\nand model coef\ufb01cients into the linear logistic regression model, as follows:\nlogit = \u03b20 + \u03b21x1 + \u03b22x2 = \u22121.5 + 3 \u00b7 1 + \u22120.5 \u00b7 5 = \u22121.\n(2.23)\n2. According to the natural relation between the logit and the odds, the following holds:\nodds = elogit = e\u03b20+\u03b21x1+\u03b22x2 = e\u22121 = 0.3678794.\n(2.24)\n3. The odds ratio is, by de\ufb01nition:\nodds = P(y = 1)\nP(y = 0),\n(2.25)\nso the logistic response function is:\nP(y = 1) =\n1\n1 + e\u2212logit =\n1\n1 + e1 = 0.2689414.\n(2.26)\n\u25a0\n2.3.4\nTruly Understanding Logistic Regression\n33\n2.3. SOLUTIONS"
  },
  {
    "id": "PRB-19",
    "chapter": "",
    "question": "Proton therapy (PT) [2] is a widely adopted form of treatment for many types of cancer\nincluding breast and lung cancer (Fig. 2.2).\nFIGURE 2.2: Pulmonary nodules (left) and breast cancer (right).\nA PT device which was not properly calibrated is used to simulate the treatment of\ncancer. As a result, the PT beam does not behave normally. A data scientist collects inform-\nation relating to this simulation. The covariates presented in Table 2.1 are collected during\n16\nChapter 2\nLOGISTIC REGRESSION\nthe experiment. The columns Yes and No indicate if the tumour was eradicated or not, re-\nspectively.\nTumour eradication\nCancer Type\nYes\nNo\nBreast\n560\n260\nLung\n69\n36\nTABLE 2.1: Tumour eradication statistics.\nReferring to Table 2.1:\n1. What is the explanatory variable and what is the response variable?\n2. Explain the use of relative risk and odds ratio for measuring association.\n3. Are the two variables positively or negatively associated?\nFind the direction and strength of the association using both relative risk and odds\nratio.\n4. Compute a 95% con\ufb01dence interval (CI) for the measure of association.\n5. Interpret the results and explain their signi\ufb01cance.",
    "solution": "1. Tumour eradication (Y ) is the response variable and cancer type (X) is the explanatory\nvariable.\n2. Relative risk (RR) is the ratio of risk of an event in one group (e.g., exposed group)\nversus the risk of the event in the other group (e.g., non-exposed group). The odds ratio\n(OR) is the ratio of odds of an event in one group versus the odds of the event in the\nother group.\n3. If we calculate odds ratio as a measure of association:\n\u02c6\u03b8 = 560 \u00d7 36\n69 \u00d7 260 = 1.23745.\n(2.27)\nAnd the log-odds ratio is (log(1.23745)) = 0.213052:\nThe odds ratio is larger than one, indicating that the odds for a breast cancer is more\nthan the odds for a lung cancer to be eradicated. Notice however, that this result is too\nclose to one, which prevents conclusive decision regarding the odds relation.\nAdditionally, if we calculate relative risk as a measure of association:\nRR =\n560\n560+260\n69\n69+36\n= 1.0392.\n(2.28)\n4. The 95% con\ufb01dence interval for the odds-ratio, \u03b8 is computed from the sample con\ufb01d-\nence interval for log odds ratio:\n\u02c6\u03c3\n\ufffd\nlog(\u02c6\u03b8)\n\ufffd\n=\n\ufffd\n1\n560 +\n1\n260 + 1\n69 + 1\n36 = 0.21886.\n(2.29)\nTherefore, the 95% CI for log (\u03b8) is:\n0.213052 \u00b1 1.95 \u00d7 0.21886 = (0.6398298, \u22120.2137241).\n(2.30)\n34\nChapter 2\nLOGISTIC REGRESSION\nTherefore, the 95% CI for \u03b8 is:\n(e\u22120.210, e0.647) = (0.810, 1.909).\n(2.31)\n5. The CI (0.810, 1.909) contains 1, which indicates that the true odds ratio is not signi-\n\ufb01cantly different from 1 and there is not enough evidence that tumour eradication is\ndependent on cancer type.\n\u25a0"
  },
  {
    "id": "PRB-20",
    "chapter": "",
    "question": "Consider a system for radiation therapy planning (Fig. 2.3). Given a patient with a ma-\nlignant tumour, the problem is to select the optimal radiation exposure time for that patient.\nA key element in this problem is estimating the probability that a given tumour will be erad-\nicated given certain covariates. A data scientist collects information relating to this radiation\ntherapy system.\n17\n2.2. PROBLEMS\nFIGURE 2.3: A multi-detector positron scanner used to locate tumours.\nThe following covariates are collected; X1 denotes time in milliseconds that a patient is\nirradiated with, X2 = holds the size of the tumour in centimeters, and Y notates a binary re-\nsponse variable indicating if the tumour was eradicated. Assume that each response\u2019 variable\nYi is a Bernoulli random variable with success parameter pi, which holds:\npi =\ne\u03b20+\u03b21x1+\u03b22x2\n1 + e\u03b20+\u03b21x1+\u03b22x2 .\n(2.5)\nThe data scientist \ufb01ts a logistic regression model to the dependent measurements and pro-\nduces these estimated coef\ufb01cients:\n\u02c6\u03b20 = \u22126,\n\u02c6\u03b21 = 0.05,\n\u02c6\u03b22 = 1.\n(2.6)\n1. Estimate the probability that, given a patient who undergoes the treatment for 40\nmilliseconds and who is presented with a tumour sized 3.5 centimetres, the system\neradicates the tumour.\n2. How many milliseconds the patient in part (a) would need to be radiated with to have\nexactly a 50% chance of eradicating the tumour?\n18\nChapter 2\nLOGISTIC REGRESSION",
    "solution": "1. By using the de\ufb01ned values for X1 and X2, and the known logistic regression model,\nsubstitution yields:\n\u02c6p(X) =\ne\u22126+0.05X1+X2\n(1 + e\u22126+0.05X1+X2) = 0.3775.\n(2.32)\n2. The equation for the predicted probability tells us that:\ne\u22126+0.05X1+3.5\n(1 + e\u22126+0.05X1+3.5) = 0.5,\n(2.33)\nwhich is equivalent to constraining:\ne\u22126+0.05X1+3.5 = 1.\n(2.34)\nBy taking the logarithm of both sides, we get that the number of milliseconds needed is:\nX1 = 2.5\n0.05 = 50.\n(2.35)\n\u25a0"
  },
  {
    "id": "PRB-21",
    "chapter": "",
    "question": "Recent research [3] suggests that heating mercury containing dental amalgams may\ncause the release of toxic mercury fumes into the human airways. It is also presumed that\ndrinking hot coffee, stimulates the release of mercury vapour from amalgam \ufb01llings (Fig.\n2.4).\nFIGURE 2.4: A dental amalgam.\nTo study factors that affect migraines, and in particular, patients who have at least four\ndental amalgams in their mouth, a data scientist collects data from 200K users with and\nwithout dental amalgams. The data scientist then \ufb01ts a logistic regression model with an\nindicator of a second migraine within a time frame of one hour after the onset of the \ufb01rst mi-\ngraine, as the binary response variable (e.g., migraine=1, no migraine=0). The data scientist\nbelieves that the frequency of migraines may be related to the release of toxic mercury fumes.\nThere are two independent variables:\n1. X1 = 1 if the patient has at least four amalgams; 0 otherwise.\n2. X2 = coffee consumption (0 to 100 hot cups per month).\nThe output from training a logistic regression classi\ufb01er is as follows:\nAnalysis of LR Parameter Estimates\nParameter\nEstimate\nStd.Err\nZ-val\nPr>|Z|\nIntercept\n-6.36347\n3.21362\n-1.980\n0.0477\n$X_1$\n-1.02411\n1.17101\n-0.875\n0.3818\n$X_2$\n0.11904\n0.05497\n2.165\n0.0304\n19\n2.2. PROBLEMS\n1. Using X1 and X2, express the odds of a patient having a migraine for a second time.\n2. Calculate the probability of a second migraine for a patient that has at least four\namalgams and drank 100 cups per month?\n3. For users that have at least four amalgams, is high coffee intake associated with an\nincreased probability of a second migraine?\n4. Is there statistical evidence that having more than four amalgams is directly associ-\nated with a reduction in the probability of a second migraine?",
    "solution": "35\n2.3. SOLUTIONS\nFor the purpose of this exercise, it is instructive to pre-de\ufb01ne z as:\nz (X1, X2) = \u22126.36 \u2212 1.02 \u00d7 X1 + 0.12 \u00d7 X2.\n(2.36)\n1. By employing the classic logistic regression model:\nodds = exp(z (X1, X2)).\n(2.37)\n2. By substituting the given values of X1, X2 into z (X1, X2), the probability holds:\np = exp(z (1, 100))/(1 + exp(z (1, 100))) = 0.99.\n(2.38)\n3. Yes. The coef\ufb01cient for coffee consumption is positive (0.119) and the p-value is less\nthan 0.05 (0.0304).\nNote: Can you describe the relation between these numerical relations and the positive\nconclusion?\n4. No. The p-value for this predictor is 0.3818 > 0.05.\nNote: Can you explain why this inequality implicates a lack of statistical evidence?\n\u25a0"
  },
  {
    "id": "PRB-22",
    "chapter": "",
    "question": "To study factors that affect Alzheimer\u2019s disease using logistic regression, a researcher\nconsiders the link between gum (periodontal) disease and Alzheimer as a plausible risk factor\n[1]. The predictor variable is a count of gum bacteria (Fig. 2.5) in the mouth.\nFIGURE 2.5: A chain of spherical bacteria.\nThe response variable, Y , measures whether the patient shows any remission (e.g. yes=1).\nThe output from training a logistic regression classi\ufb01er is as follows:\nParameter\nDF\nEstimate\nStd\nIntercept\n1\n-4.8792\n1.2197\ngum bacteria\n1\n0.0258\n0.0194\n1. Estimate the probability of improvement when the count of gum bacteria of a patient\nis 33.\n20\nChapter 2\nLOGISTIC REGRESSION\n2. Find out the gum bacteria count at which the estimated probability of improvement is\n0.5.\n3. Find out the estimated odds ratio of improvement for an increase of 1 in the total gum\nbacteria count.\n4. Obtain a 99% con\ufb01dence interval for the true odds ratio of improvement increase of\n1 in the total gum bacteria count. Remember that the most common con\ufb01dence levels\nare 90%, 95%, 99%, and 99.9%. Table 9.1 lists the z values for these levels.\nCon\ufb01dence Level\nz\n90%\n1.645\n95%\n1.960\n99%\n2.576\n99.9%\n3.291\nTABLE 2.2: Common con\ufb01dence levels.",
    "solution": "1. The estimated probability of improvement is:\n\u02c6\u03c0(gum bacteria) =\nexp(\u22124.8792 + 0.0258 \u00d7 gum bacteria)\n1 + exp(\u22124.8792 + 0.0258 \u00d7 gum bacteria).\nHence, \u02c6\u03c0(33) = 0.01748.\n36\nChapter 2\nLOGISTIC REGRESSION\n2. For \u02c6\u03c0(gum bacteria) = 0.5 we know that:\n\u02c6\u03c0(gum) =\nexp(\u02c6\u03b1 + \u02c6\u03b2x)\n1 + exp(\u02c6\u03b1 + \u02c6\u03b2x)\n= 0.5\n(2.39)\ngum bacteria = \u2212\u02c6\u03b1/\u02c6\u03b2 = 4.8792/0.0258 = 189.116.\n(2.40)\n3. The estimated odds ratio are given by:\nexp(\u02c6\u03b2) = exp(0.0258) = 1.0504.\n(2.41)\n4. A 99% con\ufb01dence interval for \u03b2 is calculated as follows:\n\u02c6\u03b2 \u00b1 z0.005 \u00d7 ASE(\u02c6\u03b2) =\n(2.42)\n0.0258 \u00b1 2.576 \u00d7 0.0194\n(2.43)\n= (\u22120.00077, 0.9917).\n(2.44)\nTherefore, a 99% con\ufb01dence interval for the true odds ratio exp(\u03b2) is given by:\n(exp(\u22120.00077), exp(0.9917)) = (0.99923, 2.6958).\n(2.45)\n\u25a0"
  },
  {
    "id": "PRB-23",
    "chapter": "",
    "question": "Recent research [4] suggests that cannabis (Fig. 2.6) and cannabinoids administration\nin particular, may reduce the size of malignant tumours in rats.\nFIGURE 2.6: Cannabis.\n21\n2.2. PROBLEMS\nTo study factors affecting tumour shrinkage, a deep learning researcher collects data from\ntwo groups; one group is administered with placebo (a substance that is not medicine) and\nthe other with cannabinoids. His main research revolves around studying the relationship\n(Table 2.3) between the anticancer properties of cannabinoids and tumour shrinkage:\nTumour Shrinkage In Rats\nGroup\nYes\nNo\nSum\nCannabinoids\n60\n6833\n6893\nPlacebo\n130\n6778\n6909\nSum\n190\n13611\n13801\nTABLE 2.3: Tumour shrinkage in rats.\nFor the true odds ratio:\n1. Find the sample odds ratio.\n2. Find the sample log-odds ratio.\n3. Compute a 95% con\ufb01dence interval (z0.95 = 1.645; z0.975 = 1.96) for the true log odds\nratio and true odds ratio.\n2.2.5\nThe Logit Function and Entropy",
    "solution": "1. The sample odds ratio is:\n\u02c6\u03b8 = 130 \u00d7 6833\n60 \u00d7 6778 = 2.1842.\n(2.46)\n37\n2.3. SOLUTIONS\n2. The estimated standard error for log\n\ufffd\u02c6\u03b8\n\ufffd\nis:\n\u02c6\u03c3\n\ufffd\nlog \u02c6\u03b8\n\ufffd\n=\n\ufffd\n1\n60 +\n1\n6833 +\n1\n130 +\n1\n6778 = 0.1570.\n(2.47)\n3. According to previous sections, the 95% CI for the true log odds ratio is:\n0.7812 \u00b1 1.96 \u00d7 0.1570 = (0.4734, 1.0889).\n(2.48)\nCorrespondingly, the 95% CI for the true odds ratio is:\n(e0.4734, e1.0889) = (1.6060, 2.9710).\n(2.49)\n\u25a0\n2.3.5\nThe Logit Function and Entropy"
  },
  {
    "id": "PRB-24",
    "chapter": "",
    "question": "The entropy (see Chapter 4) of a single binary outcome with probability p to receive 1 is\nde\ufb01ned as:\nH(p) \u2261 \u2212p log p \u2212 (1 \u2212 p) log(1 \u2212 p).\n(2.7)\n1. At what p does H(p) attain its maximum value?\n2. What is the relationship between the entropy H(p) and the logit function, given p?\n22\nChapter 2\nLOGISTIC REGRESSION\n2.2.6\nPython/PyTorch/CPP",
    "solution": "1. The entropy (Fig. 2.13) has a maximum value of log2(2) for probability p = 1/2, which\nis the most chaotic distribution. A lower entropy is a more predictable outcome, with\nzero providing full certainty.\n2. The derivative of the entropy with respect to p yields the negative of the logit func-\ntion:\ndH(p)\ndp\n= \u2212logit(p).\n(2.50)\nNote: The curious reader is encouraged to rigorously prove this claim.\n\u25a0\n2.3.6\nPython, PyTorch, CPP"
  },
  {
    "id": "PRB-25",
    "chapter": "",
    "question": "The following C++ code (Fig. 2.7) is part of a (very basic) logistic regression implement-\nation module. For a theoretical discussion underlying this question, refer to problem 2.17.\n1 #include ...\n2 std::vector<double> theta {-6,0.05,1.0};\n3 double sigmoid(double x) {\n4\ndouble tmp =1.0 / (1.0 + exp(-x));\n5\nstd::cout << \"prob=\" << tmp<<std::endl;\n6\nreturn tmp;\n7 }\n8 double hypothesis(std::vector<double> x){\n9\ndouble z;\n10\nz=std::inner_product(std::begin(x), std::end(x),\nstd::begin(theta), 0.0);\n\ufffd\u2192\n11\nstd::cout << \"inner_product=\" << z<<std::endl;\n12\nreturn sigmoid(z);\n13 }\n14 int classify(std::vector<double> x){\n15\nint hypo=hypothesis(x) > 0.5f;\n16\nstd::cout << \"hypo=\" << hypo<<std::endl;\n17\nreturn hypo;\n18 }\n19 int main() {\n20\nstd::vector<double> x1 {1,40,3.5};\n21\nclassify(x1);\n22 }\nFIGURE 2.7: Logistic regression in CPP\n1. Explain the purpose of line 10, i.e., inner_product.\n2. Explain the purpose of line 15, i.e., hypo(x) > 0.5f.\n23\n2.2. PROBLEMS\n3. What does \u03b8 (theta) stand for in line 2?\n4. Compile and run the code, you can use:\nhttps://repl.it/languages/cpp11 to evaluate the code.\nWhat is the output?",
    "solution": "38\nChapter 2\nLOGISTIC REGRESSION\nFIGURE 2.13: Binary entropy.\n1. During inference, the purpose of inner_product is to multiply the vector of logistic re-\ngression coef\ufb01cients with the vector of the input which we like to evaluate, e.g., calculate\nthe probability and binary class.\n2. The line hypo(x) > 0.5f is commonly used for the evaluation of binary classi\ufb01cation\nwherein probability values above 0.5 (i.e., a threshold) are regarded as TRUE whereas\nvalues below 0.5 are regarded as FALSE.\n3. The term \u03b8 (theta) stands for the logistic regression coef\ufb01cients which were evaluated\nduring training.\n4. The output is as follows:\n1 > inner_product=-0.5\n2 > prob=0.377541\n3 > hypo=0\nFIGURE 2.14: Logistic regression in C++\n\u25a0"
  },
  {
    "id": "PRB-26",
    "chapter": "",
    "question": "The following Python code (Fig. 2.8) runs a very simple linear model on a two-dimensional\nmatrix.\n1 import torch\n2 import torch.nn as nn\n3\n4 lin = nn.Linear(5, 7)\n5 data = (torch.randn(3, 5))\n6\n7 print(lin(data).shape)\n8 >?\nFIGURE 2.8: A linear model in PyTorch\nWithout actually running the code, determine what is the size of the matrix printed as a\nresult of applying the linear model on the matrix.",
    "solution": "39\n2.3. SOLUTIONS\nBecause the second dimension of lin is 7, and the \ufb01rst dimension of data is 3, the result-\ning matrix has a shape of torch.Size([3, 7]) .\n\u25a0"
  },
  {
    "id": "PRB-27",
    "chapter": "",
    "question": "The following Python code snippet (Fig. 2.9) is part of a logistic regression implementa-\ntion module in Python.\n24\nChapter 2\nLOGISTIC REGRESSION\n1 from scipy.special import expit\n2 import numpy as np\n3 import math\n4\n5 def Func001(x):\n6\ne_x = np.exp(x - np.max(x))\n7\nreturn e_x / e_x.sum()\n8\n9 def Func002(x):\n10\nreturn 1 / (1 + math.exp(-x))\n11\n12 def Func003(x):\n13\nreturn x * (1-x)\nFIGURE 2.9: Logistic regression methods in Python.\nAnalyse the methods Func001 , Func002 and Func003 presented in Fig. 2.9, \ufb01nd their\npurposes and name them.",
    "solution": "Ideally, you should be able to recognize these functions immediately upon a request from\nthe interviewer.\n1. A softmax function.\n2. A sigmoid function.\n3. A derivative of a sigmoid function.\n\u25a0"
  },
  {
    "id": "PRB-28",
    "chapter": "",
    "question": "The following Python code snippet (Fig. 2.10) is part of a machine learning module in\nPython.\n25\n2.2. PROBLEMS\n1 ^^I^^I\n2 from scipy.special import expit\n3 import numpy as np\n4 import math\n5 ^^I^^I\n6 def Func006(y_hat, y):\n7\nif y == 1:\n8\nreturn -np.log(y_hat)\n9\nelse:\n10\nreturn -np.log(1 - y_hat)^^I\nFIGURE 2.10: Logistic regression methods in Python.\nAnalyse the method Func006 presented in Fig. 2.10. What important concept in machine-\nlearning does it implement?",
    "solution": "The function implemented in Fig. 2.10 is the binary cross-entropy function.\n\u25a0"
  },
  {
    "id": "PRB-29",
    "chapter": "",
    "question": "The following Python code snippet (Fig. 2.11) presents several different variations of the\nsame function.\n26\nChapter 2\nLOGISTIC REGRESSION\n1 ^^I^^I\n2 from scipy.special import expit\n3 import numpy as np\n4 import math\n5\n6 def Ver001(x):\n7\nreturn 1 / (1 + math.exp(-x))\n8\n9 def Ver002(x):\n10\nreturn 1 / (1 + (np.exp(-x)))\n11\n12 WHO_AM_I = 709\n13\n14 def Ver003(x):\n15\nreturn 1 / (1 + np.exp(-(np.clip(x, -WHO_AM_I, None))))\nFIGURE 2.11: Logistic regression methods in Python.\n1. Which mathematical function do these methods implement?\n2. What is signi\ufb01cant about the number 709 in line 11?\n3. Given a choice, which method would you use?\n2.3\nSolutions\n2.3.1\nGeneral Concepts",
    "solution": "1. All the methods are variations of the sigmoid function.\n2. In Python, approximately 1.797e + 308 holds the largest possible valve for a \ufb02oating\npoint variable. The logarithm of which is evaluated at 709.78. If you try to execute the\nfollowing expression in Python, it will result in inf : np.log(1.8e + 308).\n3. I would use Ver003 because of its stability. Note: Can you entail why is this method\nmore stable than the others?\n\u25a0\n40\nCHAPTER\n3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nAnyone who considers arithmetical methods of producing random digits is, of\ncourse, in a state of sin.\n\u2014 John von Neumann (1903-1957)\nContents\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n42\nProblems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n42\nExpectation and Variance\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n42\nConditional Probability . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n44\nBayes Rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n45\nMaximum Likelihood Estimation . . . . . . . . . . . . . . . . . . . . . .\n51\nFisher Information\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n51\nPosterior & prior predictive distributions\n. . . . . . . . . . . . . . . . .\n54\nConjugate priors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n54\nThe Beta-Binomial distribution . . . . . . . . . . . . . . . . . . .\n54\nBayesian Deep Learning . . . . . . . . . . . . . . . . . . . . . . . . . . .\n55\nSolutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n59\nExpectation and Variance\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n59\nConditional Probability . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n62\nBayes Rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n66\nMaximum Likelihood Estimation . . . . . . . . . . . . . . . . . . . . . .\n71\nFisher Information\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n73\nPosterior & prior predictive distributions\n. . . . . . . . . . . . . . . . .\n76\nConjugate priors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n77\nBayesian Deep Learning . . . . . . . . . . . . . . . . . . . . . . . . . . .\n77\n3.1. INTRODUCTION\n3.1\nIntroduction\nT\nHE Bayesian school of thought has permeated \ufb01elds such as mechanical\nstatistics, classical probability, and \ufb01nancial mathematics [13]. In tandem,\nthe subject matter itself has gained attraction, particularly in the \ufb01eld of\nBML. It is not surprising then, that several new Python based probabilistic\nprogramming libraries such as PyMc3 and Stan [11] have emerged and have become\nwidely adopted by the machine learning community.\nThis chapter aims to introduce the Bayesian paradigm and apply Bayesian infer-\nences in a variety of problems. In particular, the reader will be introduced with real-\nlife examples of conditional probability and also discover one of the most important\nresults in Bayesian statistics: that the family of beta distributions is conjugate to a bi-\nnomial likelihood. It should be stressed that Bayesian inference is a subject matter\nthat students evidently \ufb01nd hard to grasp, since it heavily relies on rigorous probab-\nilistic interpretations of data. Speci\ufb01cally, several obstacles hamper with the prospect\nof learning Bayesian statistics:\n1. Students typically undergo merely basic introduction to classical probability and\nstatistics. Nonetheless, what follows requires a very solid grounding in these\n\ufb01elds.\n2. Many courses and resources that address Bayesian learning do not cover essen-\ntial concepts.\n3. A strong comprehension of Bayesian methods involves numerical training and\nsophistication levels that go beyond \ufb01rst year calculus.\nConclusively, this chapter may be much harder to understand than other chapters.\nThus, we strongly urge the readers to thoroughly solve the following questions and\nverify their grasp of the mathematical concepts in the basis of the solutions [8].\n3.2\nProblems\n3.2.1\nExpectation and Variance"
  },
  {
    "id": "PRB-30",
    "chapter": "",
    "question": "De\ufb01ne what is meant by a Bernoulli trial.\n42\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL",
    "solution": "The notion of a Bernoulli trial refers to an experiment with two dichotomous binary out-\ncomes; success (x = 1), and failure (x = 0).\n\u25a0"
  },
  {
    "id": "PRB-31",
    "chapter": "",
    "question": "The binomial distribution is often used to model the probability that k out of a group of n\nobjects bare a speci\ufb01c characteristic. De\ufb01ne what is meant by a binomial random variable\nX.",
    "solution": "A binomial random variable X = k represents k successes in n mutually independent\nBernoulli trials.\n\u25a0"
  },
  {
    "id": "PRB-32",
    "chapter": "",
    "question": "What does the following shorthand stand for?\nX \u223c Binomial(n, p)\n(3.1)",
    "solution": "The shorthand X \u223c Binomial(n, p) indicates that the random variable X has the bi-\nnomial distribution (Fig. 3.16). The positive integer parameter n indicates the number of\nBernoulli trials and the real parameter p, 0 < p < 1 holds the probability of success in each of\nthese trials.\n0\n10\n20\n30\n40\n50\n0,0\n0,2\n0,4\np(x = k) =\n\ufffdn\nk\n\ufffd\n\u00b7 pk \u00b7 (1 \u2212 p)n\u2212k\nx\np(x)\nn = 50, p = 0.3\nn = 50, p = 0.7\nn = 50, p = 0.9\nFIGURE 3.16: The binomial distribution.\n\u25a0"
  },
  {
    "id": "PRB-33",
    "chapter": "",
    "question": "Find the probability mass function (PMF) of the following random variable:\nX \u223c Binomial(n, p)\n(3.2)",
    "solution": "59\n3.3. SOLUTIONS\nThe random variable X \u223c Binomial(n, p) has the following PMF:\nP(X = k) =\n\ufffdn\nk\n\ufffd\npk (1 \u2212 p)n\u2212k ; k = 0, 1, 2, . . . , n.\n(3.11)\n\u25a0"
  },
  {
    "id": "PRB-34",
    "chapter": "",
    "question": "Answer the following questions:\n1. De\ufb01ne what is meant by (mathematical) expectation.\n2. De\ufb01ne what is meant by variance.\n3. Derive the expectation and variance of a the binomial random variable X \u223c Binomial(n, p)\nin terms of p and n.",
    "solution": "The answers below regard a discrete random variable. The curious reader is encouraged to\nexpend them to the continuous case.\n1. For a random variable X with probability mass function P(X = k) and a set of out-\ncomes K, the expected value of X is de\ufb01ned as:\nE[X] :=\n\ufffd\nk\u2208K\nkP(X = k).\n(3.12)\nNote: The expectation of X may also be denoted by \u00b5X.\n2. The variance of X is de\ufb01ned as:\nVar[X] := E\n\ufffd\n(X \u2212 E[X])2\ufffd\n.\n(3.13)\nNote: The variance of X may also be denoted by \u03c32\nX, while \u03c3X itself denotes the stand-\nard deviation of X.\n3. The population mean and variance of a binomial random variable with parameters n\nand p are:\nE[X] = np\nV [X] = np(1 \u2212 p)\n(3.14)\nNote: Why is this solution intuitive? What information theory-related phenomenon\noccurs when p = 1/2?\n\u25a0"
  },
  {
    "id": "PRB-35",
    "chapter": "",
    "question": "Proton therapy (PT) is a widely adopted form of treatment for many types of cancer [6].\nA PT device which was not properly calibrated is used to treat a patient with pancreatic\ncancer (Fig. 3.1). As a result, a PT beam randomly shoots 200 particles independently and\ncorrectly hits cancerous cells with a probability of 0.1.\n43\n3.2. PROBLEMS\nFIGURE 3.1: Histopathology for pancreatic cancer cells.\n1. Find the statistical distribution of the number of correct hits on cancerous cells in\nthe described experiment. What are the expectation and variance of the corresponding\nrandom variable?\n2. A radiologist using the device claims he was able to hit exactly 60 cancerous cells.\nHow likely is it that he is wrong?\n3.2.2\nConditional Probability",
    "solution": "60\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\n1. This scenario describes an experiment that is repeated 200 times independently with a\nsuccess probability of 0.1. Thus, if the random variable X denotes the number of times\nsuccess was obtained, then it is best characterized by the binomial distribution with\nparameters n = 200 and p = 0.1. Formally:\nX \u223c Binomial(200, 0.1).\n(3.15)\nThe expectation of X is given by:\nx = E(x) = 200 \u00d7 0.1 = 20,\n(3.16)\nand its respective variance is:\nV ar = 200 \u00d7 0.10(1 \u2212 0.10) = 18.0.\n(3.17)\n2. Here we propose two distinguished methods to answer the question.\nPrimarily, the straightforward solution is to employ the de\ufb01nition of the binomial dis-\ntribution and substitute the value of X in it. Namely:\nP(X = 60; n = 200, p = 0.1)\n=\n\ufffd200\n60\n\ufffd\n0.160 (1 \u2212 0.1)200\u221260\n=\u2248 2.7 \u00d7 e\u221215.\n(3.18)\nThis leads to an extremely high probability that the radiologist is mistaken.\nThe following approach is longer and more advanced, but grants the reader with insights\nand intuition regarding the results. To derive how wrong the radiologist is, we can\nemploy an approximation by considering the standard normal distribution. In statistics,\nthe Z-score allows us to understand how far from the mean is a data point in units of\nstandard deviation, thus revealing how likely it is to occur (Fig. 3.17).\n61\n3.3. SOLUTIONS\nZ-score\nz =\nData point\nx \u2212 \u00b5\nExpectation\n\u03c3\nStandard dev.\n.\n(3.19)\nFIGURE 3.17: Z-score\nTherefore, the probability of correctly hitting 60 cells is:\nP(X \u2265 60) = P(Z \u2265 60 \u2212 20\n\u221a\n18.0 ) = P(Z \u2265 9.428) \u2248 0.\n(3.20)\nAgain, the outcome shows the likelihood that the radiologist was wrong approaches 1.\nNote: Why is the relation depicted in Fig. 3.17 deduces that Z is a standard Gaussian?\nUnder what terms is this conclusion valid? Why does eq. (3.20) employs the cumulative\ndistribution function and not the probability mass function?\n\u25a0\n3.3.2\nConditional Probability"
  },
  {
    "id": "PRB-36",
    "chapter": "",
    "question": "Given two events A and B in probability space H, which occur with probabilities P(A)\nand P(B), respectively:\n1. De\ufb01ne the conditional probability of A given B. Mind singular cases.\n2. Annotate each part of the conditional probability formulae.\n3. Draw an instance of Venn diagram, depicting the intersection of the events A and B.\nAssume that A \ufffd B = H.",
    "solution": "1. For two events A and B with P(B) > 0, the conditional probability of A given that\nB has occurred is de\ufb01ned as:\nP(A|B) = P(A \u2229 B)\nP(B)\n.\n(3.21)\nIt is easy to note that if P(B) = 0, this relation is not de\ufb01ned mathematically. In this\ncase, P(A|B) = P(A \u2229 B) = P(A).\n2. The annotated probabilities are displayed in Fig. 3.18:\n62\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nA given B\nP(A|B) =\nA and B\nP(A \u2229 B)\nP(B)\nB only\n.\n(3.22)\nFIGURE 3.18: Conditional probability\n3. An example of a diagram depicting the intersected events A and B is displayed in Fig.\n3.19:\nA\nB\nH\nFIGURE 3.19: Venn diagram of the intersected events A and B in probability space H\n\u25a0"
  },
  {
    "id": "PRB-37",
    "chapter": "",
    "question": "Bayesian inference amalgamates data information in the likelihood function with known\nprior information. This is done by conditioning the prior on the likelihood using the Bayes\nformulae. Assume two events A and B in probability space H, which occur with probabilities\n44\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nP(A) and P(B), respectively. Given that A \ufffd B = H, state the Bayes formulae for this case,\ninterpret its components and annotate them.",
    "solution": "The Bayes formulae reads:\nP(A|B) =\nP(B|A)P(A)\nP(B|A)P(A) + P(B|Ac)P(Ac),\n(3.23)\nwhere P(Ac) is the complementary probability of P(A). The interpretation of the elements in\n63\n3.3. SOLUTIONS\nBayes formulae is as follows:\nposterior probability = likelihood of the data \u00d7 prior probability\nnormalization constant\n.\n(3.24)\nNote: What is the important role of the normalization constant? Analyze the cases where\nP(B) \u2192 0 and P(B) \u2192 1. The annotated probabilities are displayed in (Fig. 3.20):\nPosterior\nP(A|B) =\nLikelihood\nP(B|A)\nPrior\nP(A)\nP(B|A)P(A) + P(B|Ac)P(Ac)\nB only\n.\n(3.25)\nFIGURE 3.20: Annotated components of the Bayes formula (eq. 3.23)\n\u25a0"
  },
  {
    "id": "PRB-38",
    "chapter": "",
    "question": "De\ufb01ne the terms likelihood and log-likelihood of a discrete random variable X given\na \ufb01xed parameter of interest \u03b3. Give a practical example of such scenario and derive its\nlikelihood and log-likelihood.",
    "solution": "Given X as a discrete randomly distributed variable and given \u03b3 as the parameter of\ninterest, the likelihood and the log-likelihood of X given \u03b3 follows respectively:\nL\u03b3(X = x) = p(X = x|\u03b3)\n(3.26)\n\u2113\u03b3(X = x) = ln (p(X = x|\u03b3))\n(3.27)\nThe term likelihood can be intuitively understood from this de\ufb01nition; it deduces how likely is\nto obtain a value x when a prior information is given regarding its distribution, namely the\nparameter \u03b3. For example, let us consider a biased coin toss with ph = \u03b3. Then:\nL\u03b3(X = \u201ch\u2032\u2032) = p(X = \u201ch\u2032\u2032|\u03b3) = \u03b3.\n(3.28)\n\u2113\u03b3(X = \u201ch\u2032\u2032) = ln (p(X = \u201ch\u2032\u2032|\u03b3)) = ln (\u03b3) .\n(3.29)\n64\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nNote: The likelihood function may also follow continuous distributions such as the normal\ndistribution. In the latter, it is recommended and often obligatory to employ the log-likelihood.\nWhy? We encourage the reader to modify the above to the continuous case of normal distribu-\ntion and derive the answer.\n\u25a0"
  },
  {
    "id": "PRB-39",
    "chapter": "",
    "question": "De\ufb01ne the term prior distribution of a likelihood parameter \u03b3 in the continuous case.",
    "solution": "The continuous prior distribution, f(\u0393 = \u03b3) represents what is known about the probab-\nility of the value \u03b3 before the experiment has commenced. It is termed as being subjective,\nand therefore may vary considerably between researchers. By proceeding the previous example,\nf(\u0393 = 0.8) holds the probability of randomly \ufb02ipping a coin that yields \u201cheads\u201d with chance\nof 80% of times.\n\u25a0"
  },
  {
    "id": "PRB-40",
    "chapter": "",
    "question": "Show the relationship between the prior, posterior and likelihood probabilities.",
    "solution": "The essence of Bayesian analysis is to draw inference of unknown quantities or quantiles\nfrom the posterior distribution p(\u0393 = \u03b3|X = x), which is traditionally derived from prior\nbeliefs and data information. Bayesian statistical conclusions about chances to obtain the para-\nmeter \u0393 = \u03b3 or unobserved values of random variable X = x, are made in terms of prob-\nability statements. These probability statements are conditional on the observed values of X,\nwhich is denoted as p(\u0393 = \u03b3|X = x), called posterior distributions of parameter \u03b3. Bayesian\nanalysis is a practical method for making inferences from data and prior beliefs using probab-\nility models for quantities we observe and for quantities which we wish to learn. Bayes rule\nprovides a relationship of this form:\nposterior \u221d p(x|\u03b3)p(\u03b3) \u221d data given prior \u00d7 chance of prior .\n(3.30)\n\u25a0"
  },
  {
    "id": "PRB-41",
    "chapter": "",
    "question": "In a Bayesian context, if a \ufb01rst experiment is conducted, and then another experiment is\nfollowed, what does the posterior become for the next experiment?",
    "solution": "The posterior density summarizes what is known about the parameter of interest \u03b3 after\nthe data is observed. In Bayesian statistics, the posterior density p(\u0393 = \u03b3|X = x) becomes\nthe prior for this next experiment. This is part of the well-known Bayesian updating mech-\nanism wherein we update our knowledge to re\ufb02ect the actual distribution of data that we\nobserved. To summarize, from the perspective of Bayes Theorem, we update the prior distri-\nbution to a posterior distribution after seeing the data.\n\u25a0\n65\n3.3. SOLUTIONS"
  },
  {
    "id": "PRB-42",
    "chapter": "",
    "question": "What is the condition under which two events A and B are said to be statistically\nindependent?\n3.2.3\nBayes Rule",
    "solution": "Two events A and B are statistically independent if (and only if):\nP(A \u2229 B) = P(A)P(B).\n(3.31)\nNote: Use conditional probability and rationalize this outcome. How does this property be-\ncome extremely useful in practical researches that consider likelihood of normally distributed\nfeatures?\n\u25a0\n3.3.3\nBayes Rule"
  },
  {
    "id": "PRB-43",
    "chapter": "",
    "question": "In an experiment conducted in the \ufb01eld of particle physics (Fig. 3.2), a certain particle\nmay be in two distinct equally probable quantum states: integer spin or half-integer spin.\nIt is well-known that particles with integer spin are bosons, while particles with half-integer\nspin are fermions [4].\n45\n3.2. PROBLEMS\nFIGURE 3.2: Bosons and fermions: particles with half-integer spin are fermions.\nA physicist is observing two such particles, while at least one of which is in a half-integer\nstate. What is the probability that both particles are fermions?",
    "solution": "Let \u03b3 stand for the number of half-integer spin states, and given the prior knowledge that\nboth states are equally probable:\nP(\u03b3 = 2|\u03b3 \u2265 1)\n(3.32)\n= P(\u03b3 = 2, \u03b3 \u2265 1)\nP(\u03b3 \u2265 1)\n(3.33)\n=\nP(\u03b3 = 2)\n1 \u2212 P(\u03b3 = 0) =\n1/4\n1 \u2212 1/4 = 1\n3\n(3.34)\nNote: Under what statistical property do the above relations hold?\n\u25a0"
  },
  {
    "id": "PRB-44",
    "chapter": "",
    "question": "During pregnancy, the Placenta Chorion Test [1] is commonly used for the diagnosis of\nhereditary diseases (Fig. 3.3). The test has a probability of 0.95 of being correct whether or\nnot a hereditary disease is present.\n46\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nFIGURE 3.3: Foetal surface of the placenta\nIt is known that 1% of pregnancies result in hereditary diseases. Calculate the probability\nof a test indicating that a hereditary disease is present.",
    "solution": "Let event A indicate present hereditary-disease and let event B to hold a positive test result.\nThe calculated probabilities are presented in Table 3.1. We were asked to \ufb01nd the probability\nof a test indicating that hereditary-disease is present, namely P(B). According to the law of\ntotal probability:\nP(B) = P(B|A) \u2217 P(A) + P(B|A) \u2217 P(A)\n= [0.95 \u2217 0.01] + [0.05 \u2217 0.99] = 0.059\n(3.35)\nNote: In terms of performance evaluation, P(B|A) is often referred to as the probability of\n66\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nPROBABILITY\nEXPLANATION\nP(A)= 0.01\nThe probability of hereditary-disease.\nP(A)=1-0.01=.99\nThe probability of no hereditary-disease.\nP(B|A)=0.95\nThe probability that the test will yield a negative result [\u02dcB] if\nhereditary-disease is NOT present [\u00c3].\nP(B|B)=1-0.95=.05\nThe probability that the test will yield a positive result [B]\nif hereditary-disease is NOT present [\u00c3] (probability of false\nalarm).\nP(B|A)=0.95\nThe probability that the test will yield a positive result [B] if\nhereditary-disease is present [A] (probability of detection).\nP(B|A)=1-0.95=.05\nThe probability that the test will yield a negative result [\u02dcB] if\nhereditary-disease is present [A].\nTABLE 3.1: Probability values of hereditary-disease detection.\ndetection and P(B|A) is considered the probability of false alarm. Notice that these measures\ndo not, neither logically nor mathematically, combine to probability of 1.\n\u25a0"
  },
  {
    "id": "PRB-45",
    "chapter": "",
    "question": "The Dercum disease [3] is an extremely rare disorder of multiple painful tissue growths.\nIn a population in which the ratio of females to males is equal, 5% of females and 0.25% of\nmales have the Dercum disease (Fig. 3.4).\nFIGURE 3.4: The Dercum disease\nA person is chosen at random and that person has the Dercum disease. Calculate the\nprobability that the person is female.",
    "solution": "We \ufb01rst enumerate the probabilities one by one:\nP(Dercum|female) = 0.05,\n(3.36)\nP(Dercum|male) = 0.0025,\n(3.37)\nP(male) = P(female) = 0.5.\n(3.38)\nWe are asked to \ufb01nd P(female|Dercum). Using Bayes Rule:\nP(female|Dercum) = P(Dercum|female)P(female)\nP(Dercum)\n.\n(3.39)\n67\n3.3. SOLUTIONS\nHowever we are missing the term P(Dercum). To \ufb01nd it, we apply the Law of Total Probab-\nility:\nP(Dercum) = P(Dercum|female)P(female)\n+P(Dercum|male)P(male)\n=\n0.05 \u00b7 0.5 + 0.0025 \u00b7 0.5 = 0.02625.\nAnd \ufb01nally, returning to eq. (3.39):\nP(female|Dercum) = 0.05 \u00b7 0.5\n0.02625 \u2248 0.9524\n(3.40)\nNote: How could this result be reached with one mathematical equation?\n\u25a0"
  },
  {
    "id": "PRB-46",
    "chapter": "",
    "question": "There are numerous fraudulent binary options websites scattered around the Internet,\nand for every site that shuts down, new ones are sprouted like mushrooms. A fraudulent AI\n47\n3.2. PROBLEMS\nbased stock-market prediction algorithm utilized at the New York Stock Exchange, (Fig. 3.6)\ncan correctly predict if a certain binary option [7] shifts states from 0 to 1 or the other way\naround, with 85% certainty.\nFIGURE 3.5: The New York Stock Exchange.\nA \ufb01nancial engineer has created a portfolio consisting twice as many state-1 options then\nstate-0 options. A stock option is selected at random and is determined by said algorithm to\nbe in the state of 1. What is the probability that the prediction made by the AI is correct?",
    "solution": "In order to solve this problem, we introduce the following events:\n1. AI: the AI predicts that the state of the stock option is 1.\n2. State1: the state of the stock option is 1.\n3. State0: the state of the stock option is 0.\nA direct application of Bayes formulae yields:\nP(State1|AI) =\n(3.41)\nP(AI|State1)P(State1)\nP(AI|State1)P(State1)+P(AI|State0)P(State0)\n(3.42)\n=\n0.85\u00b72/3\n0.85\u00b72/3+0.15\u00b71/3 \u2248 0.9189.\n\u25a0"
  },
  {
    "id": "PRB-47",
    "chapter": "",
    "question": "In an experiment conducted by a hedge fund to determine if monkeys (Fig. 3.6) can\noutperform humans in selecting better stock market portfolios, 0.05 of humans and 1 out of\n15 monkeys could correctly predict stock market trends correctly.\n48\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nFIGURE 3.6: Hedge funds and monkeys.\nFrom an equally probable pool of humans and monkeys an \u201cexpert\u201d is chosen at ran-\ndom. When tested, that expert was correct in predicting the stock market shift. What is the\nprobability that the expert is a human?",
    "solution": "1. H: a human.\n68\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\n2. M: a monkey.\n3. C: a correct prediction.\nBy employing Bayes theorem and the Law of Total probability:\nP(H|C) = P(H \u2229 C)\nP(C)\n=\nP(C|H)P(H)\nP(C|H)P(H) + P(C|M)P(M)\n=\n1\n20 \u00b7 1\n2\n1\n20 \u00b7 1\n2 + 1\n15 \u00b7 1\n2\n\u2248 0.42.\n(3.43)\nNote: If something seems off in this outcome, do not worry - it is a positive sign for\nunderstanding of conditional probability.\n\u25a0"
  },
  {
    "id": "PRB-48",
    "chapter": "",
    "question": "During the cold war, the U.S.A developed a speech to text (STT) algorithm that could\ntheoretically detect the hidden dialects of Russian sleeper agents. These agents (Fig. 3.7),\nwere trained to speak English in Russia and subsequently sent to the US to gather intelli-\ngence. The FBI was able to apprehend ten such hidden Russian spies [9] and accused them\nof being \"sleeper\" agents.\nFIGURE 3.7: Dialect detection.\n49\n3.2. PROBLEMS\nThe Algorithm relied on the acoustic properties of Russian pronunciation of the word\n(v-o-k-s-a-l) which was borrowed from English V-a-u-x-h-a-l-l. It was alleged that it is im-\npossible for Russians to completely hide their accent and hence when a Russian would\nsay V-a-u-x-h-a-l-l, the algorithm would yield the text \"v-o-k-s-a-l\". To test the algorithm\nat a diplomatic gathering where 20% of participants are Sleeper agents and the rest Americ-\nans, a data scientist randomly chooses a person and asks him to say V-a-u-x-h-a-l-l. A single\nletter is then chosen randomly from the word that was generated by the algorithm, which\nis observed to be an \"l\". What is the probability that the person is indeed a Russian sleeper\nagent?",
    "solution": "In order to solve this problem, we introduce the following events:\n1. RUS: a Russian sleeper agent is speaking.\n2. AM: an American is speaking.\n3. L: the TTS system generates an \u201cl\u201d.\nWe are asked to \ufb01nd the value of P(RUS|L). Using Bayes Theorem we can write:\nP(RUS|L) = P(L|RUS)P(RUS)\nP(L)\n.\n(3.44)\nWe were told that the Russians consist 1/5 of the attendees at the gathering, therefore:\nP(RUS) = 1\n5.\n(3.45)\n69\n3.3. SOLUTIONS\nAdditionally, because \"v-o-k-s-a-l\" has a single l out of a total of six letters:\nP(L|RUS) = 1\n6.\n(3.46)\nAdditionally, because \"V-a-u-x-h-a-l-l\" has two l\u2019s out of a total of eight letters:\nP(L|AM) = 2\n8.\n(3.47)\nAn application of the Law of Total Probability yields:\nP(L) = P(AM)P(L|AM) + P(RUS)P(L|RUS)\n(3.48)\n=\n\ufffd4\n5\n\ufffd \ufffd2\n8\n\ufffd\n+\n\ufffd1\n5\n\ufffd \ufffd1\n6\n\ufffd\n= 7\n30.\nUsing Bayes Theorem we can write:\nP(RUS|L) =\n1\n5\n\ufffd\n1\n6\n\ufffd\n7\n30\n= 1\n7.\n(3.49)\nNote: What is the letter by which the algorithm is most likely to discover a Russian sleeper\nagent?\n\u25a0"
  },
  {
    "id": "PRB-49",
    "chapter": "",
    "question": "During World War II, forces on both sides of the war relied on encrypted communica-\ntions. The main encryption scheme used by the German military was an Enigma machine\n[5], which was employed extensively by Nazi Germany. Statistically, the Enigma machine\nsent the symbols X and Z Fig. (3.8) according to the following probabilities:\nP(X) = 2\n9\n(3.3)\nP(Z) = 7\n9\n(3.4)\nFIGURE 3.8: The Morse telegraph code.\nIn one incident, the German military sent encoded messages while the British army used\ncountermeasures to deliberately tamper with the transmission. Assume that as a result of the\nBritish countermeasures, an X is erroneously received as a Z (and mutatis mutandis) with a\n50\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nprobability 1\n7. If a recipient in the German military received a Z, what is the probability that\na Z was actually transmitted by the sender?\n3.2.4\nMaximum Likelihood Estimation",
    "solution": "We are given that:\nP(X is erroneously received as a Z) = 1/7. Using Bayes Theorem we can write:\nP(Z trans|Z received) =\n= P(Z received|Z trans)P(Z trans)\nP(Z received)\n.\n(3.50)\n70\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nAn application of the Law of Total Probability yields:\nP(Z received) =\nP(Z received|Z trans)P(Z trans)\n+P(Z received|X trans)P(X trans)\n= 6\n7 \u00b7 7\n9 + 1\n7 \u00b7 2\n9\n= 44\n63.\nSo, using Bayes Rule, we have that\nP(Z trans|Z received)\n= P(Z received|Z trans)P(Z trans)\nP(Z received)\n=\n6\n7\n7\n9\n44\n63\n= 44\n63 = 0.95.\n(3.51)\n\u25a0\n3.3.4\nMaximum Likelihood Estimation"
  },
  {
    "id": "PRB-50",
    "chapter": "",
    "question": "What is likelihood function of the independent identically distributed (i.i.d) random\nvariables:\nX1, \u00b7 \u00b7 \u00b7 , Xn where Xi \u223c binomial(n, p), \u2200i \u2208 [1, n],\nand where p is the parameter of interest?",
    "solution": "For the set of i.i.d samples X1, \u00b7 \u00b7 \u00b7 , Xn, the likelihood function is the product of the\nprobability functions:\nL(p) = p(X1 = x1; p)p(X2 = x2; p) \u00b7 \u00b7 \u00b7 p(Xn = xn; p)\n=\nn\n\ufffd\ni=1\n\ufffdn\nxi\n\ufffd\npxi(1 \u2212 p)n\u2212xi.\n(3.52)\nNote: What is the distribution of Xn when X is a Bernoulli distributed random variable?\n\u25a0\n71\n3.3. SOLUTIONS"
  },
  {
    "id": "PRB-51",
    "chapter": "",
    "question": "How can we derive the maximum likelihood estimator (MLE) of the i.i.d samples\nX1, \u00b7 \u00b7 \u00b7 , Xn introduced in Q. 3.21?",
    "solution": "The maximum likelihood estimator (MLE) of p is the value of all possible p values that\nmaximizes L(p). Namely, the p value that renders the set of measurements X1, \u00b7 \u00b7 \u00b7 , Xn as the\nmost likely. Formally:\n\u02c6p = arg max0\u2264p\u22641L(p)\n(3.53)\nNote: The curious student is highly encouraged to derive \u02c6p from L(p). Notice that L(p) can\nbe extremely simpli\ufb01ed.\n\u25a0"
  },
  {
    "id": "PRB-52",
    "chapter": "",
    "question": "What is the relationship between the likelihood function and the log-likelihood function?",
    "solution": "The log-likelihood is the logarithm of the likelihood function. Intuitively, maximizing\nthe likelihood function L(\u03b3) is equivalent to maximizing ln L(\u03b3) in terms of \ufb01nding the MLE\n\u02c6\u03b3, since ln is a monotonically increasing function. Often, we maximize ln(f(\u03b3)) instead of\nthe f(\u03b3). A common example is when L(\u03b3) is comprised of normally distribution random\nvariables.\nFormally, if X1, \u00b7 \u00b7 \u00b7 , Xn are i.i.d, each with probability mass function (PMF) of fXi(xi | \u03b3),\nthen\nf(\u03b3) =\nn\n\ufffd\ni=1\nfXi(xi | \u03b3),\n(3.54)\nln(f(\u03b3)) =\nn\n\ufffd\ni=1\nln fXi(xi | \u03b3).\n(3.55)\n\u25a0"
  },
  {
    "id": "PRB-53",
    "chapter": "",
    "question": "Describe how to analytically \ufb01nd the MLE of a likelihood function?",
    "solution": "The general procedure for \ufb01nding the MLE, given that the likelihood function is differen-\ntiable, is as follows:\n1. Start by differentiating the log-likelihood function ln (L(\u03b3)) with respect to a parameter\nof interest \u03b3.\n2. Equate the result to zero.\n72\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\n3. Solve the equation to \ufb01nd \u02c6\u03b3 that holds:\n\u2202 ln L(\u02c6\u03b3 | x1, \u00b7 \u00b7 \u00b7 xn)\n\u2202\u03b3\n= 0\n(3.56)\n4. Compute the second derivative to verify that you indeed have a maximum rather than\na minimum.\n\u25a0"
  },
  {
    "id": "PRB-54",
    "chapter": "",
    "question": "What is the term used to describe the \ufb01rst derivative of the log-likelihood function?",
    "solution": "The \ufb01rst derivative of the log-likelihood function is commonly known as the Fisher score\nfunction, and is de\ufb01ned as:\nu(\u03b3) = \u2202 ln L(\u03b3 | x1, \u00b7 \u00b7 \u00b7 xn)\n\u2202\u03b3\n(3.57)\n\u25a0"
  },
  {
    "id": "PRB-55",
    "chapter": "",
    "question": "De\ufb01ne the term Fisher information.\n3.2.5\nFisher Information\n51\n3.2. PROBLEMS",
    "solution": "Fisher information, is the term used to describe the expected value of the second derivat-\nives (the curvature) of the log-likelihood function, and is de\ufb01ned by:\nI(\u03b3) = \u2212E\n\ufffd\u22022 ln L(\u03b3 | x1, \u00b7 \u00b7 \u00b7 xn)\n\u2202\u03b32\n\ufffd\n(3.58)\n\u25a0\n3.3.5\nFisher Information"
  },
  {
    "id": "PRB-56",
    "chapter": "",
    "question": "The 2014 west African Ebola (Fig. 9.10) epidemic has become the largest and fastest-\nspreading outbreak of the disease in modern history [2] with a death tool far exceeding all\npast outbreaks combined. Ebola (named after the Ebola River in Zaire) \ufb01rst emerged in 1976\nin Sudan and Zaire and infected over 284 people with a mortality rate of 53%.\nFIGURE 3.9: The Ebola virus.\nThis rare outbreak, underlined the challenge medical teams are facing in containing epi-\ndemics. A junior data scientist at the center for disease control (CDC) models the possible\nspread and containment of the Ebola virus using a numerical simulation. He knows that out\nof a population of k humans (the number of trials), x are carriers of the virus (success in\nstatistical jargon). He believes the sample likelihood of the virus in the population, follows a\nBinomial distribution:\nL(\u03b3 | y) =\n\uf8eb\n\uf8ed n\ny\n\uf8f6\n\uf8f8 \u03b3y(1 \u2212 \u03b3)n\u2212y,\n\u03b3 \u2208 [0, 1],\ny = 1, 2, . . . , n\n(3.5)\nAs the senior researcher in the team, you guide him that his parameter of interest is \u03b3,\nthe proportion of infected humans in the entire population. The expectation and variance of\nthe binomial distribution are:\nE(y|\u03b3, n) = n\u03b3,\nV (y|\u03b3, n) = n\u03b3(1 \u2212 \u03b3)\n(3.6)\nAnswer the following; for the likelihood function of the form Lx(\u03b3):\n1. Find the log-likelihood function lx(\u03b3) = ln Lx(\u03b3).\n52\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\n2. Find the gradient of lx(\u03b3).\n3. Find the Hessian matrix H(\u03b3).\n4. Find the Fisher information I(\u03b3).\n5. In a population spanning 10,000 individuals, 300 were infected by Ebola. Find the\nMLE for \u03b3 and the standard error associated with it.",
    "solution": "1. Given L(\u03b3):\nln L(\u03b3) = ln\n\ufffd\nny\n\ufffd\n+ y \u2217 ln(\u03b3) + (n \u2212 y) ln(1 \u2212 \u03b3).\n(3.59)\n73\n3.3. SOLUTIONS\n2. To \ufb01nd the gradient, we differentiate once:\ng(\u03b3) = y\u03b3\u22121 \u2212 (n \u2212 y)(1 \u2212 \u03b3)\u22121 =\n(\u03b3(1 \u2212 \u03b3))\u22121y \u2212 n(1 \u2212 \u03b3)\u22121.\n(3.60)\n3. The Hessian is generated by differentiating g(\u03b3):\nH(\u03b3) = \u2212y\u03b3\u22122 \u2212 (n \u2212 y)(1 \u2212 \u03b3)\u22122\n(3.61)\n4. The Fisher information is calculated as follows:\nI(\u03b3) = \u2212E(H(\u03b3)) =\nn\n\u03b3(1 \u2212 \u03b3),\n(3.62)\nsince:\nE(y|\u03b3, n) = n \u2217 \u03b3\n(3.63)\n5. Equating the gradient to zero and solving for our parameter \u03b3, we get:\n\u02c6\u03b3 = y\nn\n(3.64)\nIn our case this equates to: 300/10000 = 0.03. Regarding the error, there is a close\nrelationship between the variance of \u03b3 and the Fisher information, as the former is the\ninverse of the latter:\nvar(\u03b3) = [I(\u03b3)]\u22121\nV (\u03b3) = \u03b3(1 \u2212 \u03b3)\nn\n(3.65)\nPlugging the numbers from our question:\n\u02c6V (\u02c6\u03b3) = 0.03(1 \u2212 0.03)\n10000\n= 2.9 \u00d7 10\u22127.\n(3.66)\n74\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nStatistically, the standard error that we are asked to \ufb01nd is the square root of eq. 3.66\nwhich equals 5.3 \u00d7 10\u22124. Note: What desired property is revealed in this experiment?\nAt was cost could we ensure a low standard error?\n\u25a0"
  },
  {
    "id": "PRB-57",
    "chapter": "",
    "question": "In this question, you are going to derive the Fisher information function for several\ndistributions. Given a probability density function (PDF) f(X|\u03b3), you are provided with\nthe following de\ufb01nitions:\n1. The natural logarithm of the PDF ln f(X|\u03b3) = \u03a6(X|\u03b3).\n2. The \ufb01rst partial derivative \u03a6\u2032(X|\u03b3).\n3. The second partial derivative \u03a6\u2032\u2032(X|\u03b3).\n4. The Fisher Information for a continuous random variable:\nI(\u03b3) = \u2212E\u03b3\n\ufffd\n\u03a6\u2032(X|\u03b3)2\ufffd\n.\n(3.7)\nFind the Fisher Information I(\u03b3) for the following distributions:\n1. The Bernoulli Distribution X \u223c B(1, \u03b3).\n2. The Poisson Distribution X \u223c Poiss(\u03b8).",
    "solution": "The Fisher Information for the distributions is as follows:\n1. Bernoulli:\n\u03a6(x|\u03b3) = x log \u03b3 + (1 \u2212 x) log(1 \u2212 \u03b3),\n(3.67)\n\u03a6\u2032(x|\u03b3) = x\n\u03b3 \u2212 1 \u2212 x\n1 \u2212 \u03b3 ,\n(3.68)\n\u03a6\u2032\u2032(x|\u03b3) = \u2212 x\n\u03b32 \u2212\n1 \u2212 x\n(1 \u2212 \u03b3)2,\n(3.69)\nI(\u03b3) = \u2212E\u03b3\n\ufffdX(1 \u2212 \u03b3)2 + (1 \u2212 X)\u03b32\n\u03b32(1 \u2212 \u03b3)2\n\ufffd\n=\n1\n\u03b3(1 \u2212 \u03b3).\n(3.70)\n2. Poisson:\n\u03bb(x|\u03b8) = x log \u03b8 \u2212 log x! \u2212 \u03b8,\n\u03bb\u2032(x|\u03b8) = x \u2212 \u03b8\n\u03b8\n,\n\u03bb\u2032\u2032(x|\u03b8) = \u2212 x\n\u03b82,\nI(\u03b8) = \u2212E\u03b8\n\ufffd(X \u2212 \u03b8)2\n\u03b82\n\ufffd\n= 1\n\u03b8.\n(3.71)\n\u25a0"
  },
  {
    "id": "PRB-58",
    "chapter": "",
    "question": "1. True or False: The Fisher Information is used to compute the Cramer-Rao bound on\nthe variance of any unbiased maximum likelihood estimator.\n2. True or False: The Fisher Information matrix is also the Hessian of the symmetrized\nKL divergence.\n53\n3.2. PROBLEMS\n3.2.6\nPosterior & prior predictive distributions",
    "solution": "75\n3.3. SOLUTIONS\n1. True.\n2. True.\n\u25a0\n3.3.6\nPosterior & prior predictive distributions"
  },
  {
    "id": "PRB-59",
    "chapter": "",
    "question": "In chapter 3 we discussed the notion of a prior and a posterior distribution.\n1. De\ufb01ne the term posterior distribution.\n2. De\ufb01ne the term prior predictive distribution.",
    "solution": "1. Given a sample of the form x = (x1, \u00b7 \u00b7 \u00b7 , xn) drawn from a density p(\u03b8; x) and \u03b8 is\nrandomly generated according to a prior density of p(\u03b8). Then the posterior density is\nde\ufb01ned by:\np(\u03b8|x) = p(\u03b8; x)p(\u03b8)\np(x)\n.\n(3.72)\n2. The prior predictive density is:\np(x) =\n\ufffd\n\u03b8\u2208\u0398 p(\u03b8; x)p(\u03b8)d\u03b8\n(3.73)\n\u25a0"
  },
  {
    "id": "PRB-60",
    "chapter": "",
    "question": "Let y be the number of successes in 5 independent trials, where the probability of success\nis \u03b8 in each trial. Suppose your prior distribution for \u03b8 is as follows: P(\u03b8 = 1/2) = 0.25,\nP(\u03b8 = 1/6) = 0.5, and P(\u03b8 = 1/4) = 0.25.\n1. Derive the posterior distribution p(\u03b8|y) after observing y.\n2. Derive the prior predictive distribution for y.\n3.2.7\nConjugate priors",
    "solution": "1. The posterior p(\u03b8|y) \u221d p(y|\u03b8)p(\u03b8) is:\n\uf8f1\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f3\n\ufffd5\ny\n\ufffd\n(1/2)y(1/2)5\u2212y0.25,\n\u03b8 = 1/2\n\ufffd5\ny\n\ufffd\n(1/6)y(5/6)5\u2212y0.5,\n\u03b8 = 1/6\n\ufffd5\ny\n\ufffd\n(1/4)y(3/4)5\u2212y0.25,\n\u03b8 = 1/4\n0,\notherwise\n2. The prior predictive distribution p(y):\n\ufffd5\ny\n\ufffd\n((1/2)y(1/2)5\u2212y0.25\n(3.74)\n76\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\n+\n(1/6)y(5/6)5\u2212y0.5 + (1/4)y(3/4)5\u2212y0.25).\n(3.75)\n\u25a0\n3.3.7\nConjugate priors"
  },
  {
    "id": "PRB-61",
    "chapter": "",
    "question": "In chapter 3 we discussed the notion of a prior and a posterior.\n1. De\ufb01ne the term conjugate prior.\n2. De\ufb01ne the term non-informative prior.\nThe Beta-Binomial distribution",
    "solution": "1. A class F of prior distributions is said to form a conjugate family if the posterior density\nis in F for all each sample, whenever the prior density is in F.\n2. Often we would like a prior that favours no particular values of the parameter over\nothers. Bayesian analysis requires prior information, however sometimes there is no\nparticularly useful information before data is collected. In these situations, priors with\n\u201cno information\u201d are expected. Such priors are called non-informative priors.\n\u25a0"
  },
  {
    "id": "PRB-62",
    "chapter": "",
    "question": "The Binomial distribution was discussed extensively in chapter 3. Here, we are going to\nshow one of the most important results in Bayesian machine learning. Prove that the family\nof beta distributions is conjugate to a binomial likelihood, so that if a prior is in that\n54\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nfamily then so is the posterior. That is, show that:\nx \u223c Ber(\u03b3),\n\u03b3 \u223c B(\u03b1, \u03b2)\n\u21d2\n\u03b3|x \u223c B (\u03b1\u2032, \u03b2\u2032)\n(3.8)\nFor instance, for h heads and t tails, the posterior is:\nB(h + \u03b1, t + \u03b2)\n(3.9)\n3.2.8\nBayesian Deep Learning",
    "solution": "If x \u223c B(n, \u03b3) so\np(x|\u03b3) \u221d \u03b3x(1 \u2212 \u03b3)n\u2212x\nand the prior for \u03b3 is B(\u03b1, \u03b2) so\np(\u03b3) \u221d \u03b3\u03b1\u22121(1 \u2212 \u03b3)\u03b2\u22121\nthen the posterior is\n\u03b3|x \u223c B(\u03b1 + x, \u03b2 + n \u2212 x)\nIt is immediately clear the family of beta distributions is conjugate to a\nbinomial likelihood.\n\u25a0\n3.3.8\nBayesian Deep Learning\n77\n3.3. SOLUTIONS"
  },
  {
    "id": "PRB-63",
    "chapter": "",
    "question": "A recently published paper presents a new layer for a new Bayesian neural network\n(BNN). The layer behaves as follows. During the feed-forward operation, each of the hidden\nneurons Hn , n \u2208 1, 2 in the neural network (Fig. 3.10) may, or may not \ufb01re independently\nof each other according to a known prior distribution.\n\u03b81\n\u03b82\nH1\nH2\nFIGURE 3.10: Likelihood in a BNN model.\nThe chance of \ufb01ring, \u03b3, is the same for each hidden neuron. Using the formal de\ufb01nition,\ncalculate the likelihood function of each of the following cases:\n1. The hidden neuron is distributed according to X \u223c binomial(n, \u03b3) random variable\nand \ufb01res with a probability of \u03b3. There are 100 neurons and only 20 are \ufb01red.\n2. The hidden neuron is distributed according to X \u223c Uniform(0, \u03b3) random variable\nand \ufb01res with a probability of \u03b3.",
    "solution": "1. The hidden neuron is distributed according to:\nX \u223c binomial(n, \u03b3) random variable and \ufb01res with a probability of \u03b3. There are 100\nneurons and only 20 are \ufb01red.\nP(x = 20|\u03b8) =\n\uf8eb\n\uf8ed 100\n20\n\uf8f6\n\uf8f8 \u03b820(1 \u2212 \u03b8)80\n(3.76)\n2. The hidden neuron is distributed according to:\nX uniform(0, \u03b3) random variable and \ufb01res with a probability of \u03b3.\nThe uniform distribution is, of course, a very simple case:\nf(x; a, b) =\n1\nb \u2212 a\nfor\na \u2264 x \u2264 b\n(3.77)\nTherefore:\nf(x|\u03b3) =\n\uf8f1\n\uf8f2\n\uf8f3\n0\nif \u03b3 < x or x < 0\n1/\u03b3\nif 0 \u2264 x \u2264 \u03b8\n(3.78)\n\u25a0"
  },
  {
    "id": "PRB-64",
    "chapter": "",
    "question": "Your colleague, a veteran of the Deep Learning industry, comes up with an idea for for\n55\n3.2. PROBLEMS\na BNN layer entitled OnOffLayer. He suggests that each neuron will stay on (the other\nstate is off) following the distribution f(x) = e\u2212x for x > 0 and f(x) = 0 otherwise\n(Fig. 3.11). X indicates the time in seconds the neuron stays on. In a BNN, 200 such\nneurons are activated independently in said OnOffLayer. The OnOffLayer is set to off (e.g.\nnot active) only if at least 150 of the neurons are shut down. Find the probability that\nthe OnOffLayer will be active for at least 20 seconds without being shut down.\non\noff\ntime = f(x) = e\u2212x\nFIGURE 3.11: OnOffLayer in a BNN model.",
    "solution": "The provided distribution is from the exponential family. Therefore, a single neuron be-\ncomes inactive with a probability of:\np = P(X < 20) =\n\ufffd 20\n0\ne\u2212x dx = 1 \u2212 e\u221220.\n(3.79)\nThe OnOffLayer is off only if at least 150 out of 200 neurons are off. Therefore, this may be\nrepresented as a Binomial distribution and the probability for the layer to be off is:\nV =\n\ufffd\nn\u2265150\n\uf8eb\n\uf8ed 200\nn\n\uf8f6\n\uf8f8 \u02dcpn(1 \u2212 \u02dcp)200\u2212n\n(3.80)\n78\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\nHence, the probability of the layer being active for at least 20 seconds is 1 minus this value:\n[1 \u2212 V ].\n(3.81)\n\u25a0"
  },
  {
    "id": "PRB-65",
    "chapter": "",
    "question": "A Dropout layer [12] (Fig. 3.12) is commonly used to regularize a neural network model\nby randomly equating several outputs (the crossed-out hidden node H) to 0.\n\u03b80\nH\nH\nDropout\nFIGURE 3.12: A Dropout layer (simpli\ufb01ed form).\nFor instance, in PyTorch [10], a Dropout layer is declared as follows (3.1):\n56\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\n1 import torch\n2 import torch.nn as nn\n3 nn.Dropout(0.2)\nCODE 3.1: Dropout in PyTorch\nWhere nn.Dropout(0.2) (Line #3 in 3.1) indicates that the probability of zeroing an\nelement is 0.2.\n\u03b81\n\u03b82\nH1\nH2\n\u03b31\nFIGURE 3.13: A Bayesian Neural Network Model\nA new data scientist in your team suggests the following procedure for a Dropout layer\nwhich is based on Bayesian principles. Each of the neurons \u03b8n in the neural network in (Fig.\n8.33) may drop (or not) independently of each other exactly like a Bernoulli trial.\nDuring the training of a neural network, the Dropout layer randomly drops out outputs\nof the previous layer, as indicated in (Fig. 3.12). Here, for illustration purposes, all two\nneurons are dropped as depicted by the crossed-out hidden nodes Hn.\nYou are interested in the proportion \u03b8 of dropped-out neurons. Assume that the chance of\ndrop-out, \u03b8, is the same for each neuron (e.g. a uniform prior for \u03b8). Compute the posterior\nof \u03b8.",
    "solution": "The observed data, e.g the dropped neurons are distributed according to:\n(x1, . . . , xn)|\u03b8\niid\n\u223c Bern(\u03b8)\n(3.82)\nDenoting s and f as success and failure respectively, we know that the likelihood is:\np (x1, . . . , xn|\u03b8) = \u03b8s(1 \u2212 \u03b8)f\n(3.83)\nWith the following parameters \u03b1 = \u03b2 = 1 the beta distribution acts like Uniform prior:\n\u03b8 \u223c Beta(\u03b1, \u03b2), given \u03b1 = \u03b2 = 1\n(3.84)\nHence, the prior density is:\np(\u03b8) =\n1\nB(\u03b1, \u03b2)\u03b8\u03b1\u22121(1 \u2212 \u03b8)\u03b2\u22121\n(3.85)\nTherefore the posterior is:\np (\u03b8|x1, . . . , xn) \u221d p (x1, . . . , xn|\u03b8) p(\u03b8)\n\u221d \u03b8S(1 \u2212 \u03b8)f\u03b8\u03b1\u22121(1 \u2212 \u03b8)\u03b2\u22121\n= \u03b8\u03b1+s\u22121(1 \u2212 \u03b8)\u03b2+f\u22121\n(3.86)\n\u25a0"
  },
  {
    "id": "PRB-66",
    "chapter": "",
    "question": "A new data scientist in your team, who was formerly a Quantum Physicist, suggests\nthe following procedure for a Dropout layer entitled QuantumDrop which is based on\nQuantum principles and the Maxwell Boltzmann distribution. In the Maxwell-Boltzmann\n57\n3.2. PROBLEMS\ndistribution, the likelihood of \ufb01nding a particle with a particular velocity v is provided by:\nn(v)dv = 4\u03c0N\nV\n\ufffd\nm\n2\u03c0kT\n\ufffd3/2\nv2e\u2212 mv2\n2kT dv\n(3.10)\n0\n1 000 2 000 3 000 4 000 5 000\n0\n2\n4\n\u00b710\u22124\nv in m\u00b7s\u22121\nP(v)\nHelium\nFIGURE 3.14: The Maxwell-Boltzmann distribution.\nIn the suggested QuantumDrop layer (3.15), each of the neurons behaves like a molecule\nand is distributed according to the Maxwell-Boltzmann distribution and \ufb01res only when\nthe most probable speed is reached. This speed is the velocity associated with the highest\npoint in the Maxwell distribution (3.14). Using calculus, brain power and some mathem-\natical manipulation, \ufb01nd the most likely value (speed) at which the neuron will \ufb01re.\noff\nfired\nneuron \u2212 fires\nFIGURE 3.15: A QuantumDrop layer.\n58\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\n3.3\nSolutions\n3.3.1\nExpectation and Variance",
    "solution": "Neurons are dropped whenever their value (or the equivalent quantum term- speed) reach\n79\nREFERENCES\nthe most likely value:\nn(v)dv = 4\u03c0N\nV\n\ufffd\nm\n2\u03c0kT\n\ufffd3/2\nv2e\u2212 mv2\n2kT dv\n(3.87)\nFrom calculus, we know that in order to maximize a function, we have to equate its \ufb01rst\nderivative to zero:\nd\ndvn(v) = 0\n(3.88)\nThe constants can be taken out as follows:\nd\ndvv2e\u2212 mv2\n2kT = 0\n(3.89)\nApplying the chain rule from calculus:\n2ve\u2212 mv2\n2kT + v2\n\ufffd\n\u2212 m\n2kT 2v\n\ufffd\ne\u2212 mv2\n2kT = 0\n(3.90)\nWe notice that several terms cancel out:\nv2 m\n2kT = 1\n(3.91)\nNow the quadratic equation can be solved yielding:\nvmost_probable =\n\ufffd\n2kT\nm\n(3.92)\nTherefore, this is the most probable value at which the dropout layer will \ufb01re.\n\u25a0\nReferences\n[1]\nM. Barati and P. \u2018Comparison of complications of chorionic villus sampling and\namniocentesis\u2019. In: 5.4 (2012), pp. 241\u2013244 (cit. on p. 46).\n[2]\nJ. D. e. a. Bell BP Damon IK. \u2018Overview, Control Strategies, and Lessons Learned\nin the CDC Response to the 20142016 Ebola Epidemic.\u2019 In: Morbidity and Mortal-\nity Weekly Report 65.3 (2016), pp. 4\u201311 (cit. on p. 52).\n80\nChapter 3\nPROBABILISTIC PROGRAMMING & BAYESIAN DL\n[3]\nJ. C. Cook and G. P. Gross. Adiposis Dolorosa (Dercum, Anders Disease). StatPearls\n[Internet], 2019 (cit. on p. 47).\n[4]\nG. Ecker. Particles, Field, From Quantum Mechanics to the Standard Model of Particle\nPhysics. Springer., 2019 (cit. on p. 45).\n[5]\nK. Gaj and A. Orlowski. \u2018Facts and Myths of Enigma: Breaking Stereotypes\u2019. In:\nInternational Conference on the Theory and Applications of Cryptographic Techniques.\n2003 (cit. on p. 50).\n[6]\nB. Gottschalk. \u2018Techniques of Proton Radiotherapy: Transport Theory\u2019. In: arXiv\n(2012) (cit. on p. 43).\n[7]\nT. S. O. of Investor Education and Advocacy. Binary options and Fraud (cit. on\np. 48).\n[8]\nE. T. Jaynes. Probability Theory as Logic. Ed. by P. F. Foug\u00e8re. Maximum-Entropy\nand Bayesian Methods. Kluwer, Dordrecht, 1990 (cit. on p. 42).\n[9]\nD. o. J. National Security Division. Conspiracy to Act as Unregistered Agents of a\nForeign Government. 2010 (cit. on p. 49).\n[10]\nA. Paszke et al. \u2018Automatic differentiation in PyTorch\u2019. In: 31st Conference on\nNeural Information Processing Systems. 2017 (cit. on p. 56).\n[11]\nJ. Salvatier, T. V. Wiecki and C. Fonnesbeck. \u2018Probabilistic programming in Py-\nthon using PyMC3\u2019. In: PeerJ Computer Science 2 (Jan. 2016), e55 (cit. on p. 42).\n[12]\nP. Sledzinski et al. \u2018The current state and future perspectives of cannabinoids in\ncancer biology\u2019. In: Cancer Medicine 7.3 (2018), pp. 765\u2013775 (cit. on p. 56).\n[13]\nE. B. Starikov. \u2018Bayesian Statistical Mechanics: Entropy Enthalpy Compensation\nand Universal Equation of State at the Tip of Pen\u2019. In: Frontiers in Physics 6 (2018),\np. 2 (cit. on p. 42).\n81\nREFERENCES\n82\nHIGH SCHOOL\nPART III\nCHAPTER\n4\nINFORMATION THEORY\nA basic idea in information theory is that information can be treated very much\nlike a physical quantity, such as mass or energy.\n\u2014 Claude Shannon, 1985\nContents\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n86\nProblems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n87\nLogarithms in Information Theory . . . . . . . . . . . . . . . . . . . . .\n87\nShannon's Entropy\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n89\nKullback-Leibler Divergence (KLD) . . . . . . . . . . . . . . . . . . . . .\n93\nClassi\ufb01cation and Information Gain\n. . . . . . . . . . . . . . . . . . . .\n94\nMutual Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n98\nMechanical Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\nJensen's inequality\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\nSolutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\nLogarithms in Information Theory . . . . . . . . . . . . . . . . . . . . . 101\nShannon's Entropy\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\nKullback-Leibler Divergence . . . . . . . . . . . . . . . . . . . . . . . . . 108\nClassi\ufb01cation and Information Gain\n. . . . . . . . . . . . . . . . . . . . 110\nMutual Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\nMechanical Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\nJensen's inequality\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\n4.1. INTRODUCTION\n4.1\nIntroduction\nI\nNDUCTIVE inference, is the problem of reasoning under conditions of in-\ncomplete information, or uncertainty. According to Shannon\u2019s theory [2],\ninformation and uncertainty are two sides of the same coin: the more uncer-\ntainty there is, the more information we gain by removing the uncertainty.\nEntropy plays central roles in many scienti\ufb01c realms ranging from physics and statist-\nics to data science and economics. A basic problem in information theory is encoding\nlarge quantities of information [2].\nShannon\u2019s discovery of the fundamental laws of data compression and transmis-\nsion marked the birth of information theory. In his fundamental paper of 1948, \u201cA\nMathematical Theory of Communication\u201d [4], Shannon proposed a measure of the uncer-\ntainty associated with a random memory-less source, called Entropy.\nH(X)\nH(Y )\nH(Z)\nH(Y |X)\nH(Z|XY )\nI(X; Z|Y )\nFIGURE 4.1: Mutual information\nEntropy \ufb01rst emerged in thermodynamics in the 18th century by\nCarnot, [1] in his pioneering work on steam entitled \u201cRe\ufb02ection on the Motive Power of\nFire\u201d (Fig. 4.2). Subsequently it appeared in statistical mechanics where it was viewed\nas a measure of disorder. However, it was Boltzmann (4.30) who found the connection\nbetween entropy and probability, and the notion of information as used by Shannon is\na generalization of the notion of entropy. Shannon\u2019s entropy shares some instinct with\nBoltzmann\u2019s entropy, and likewise the mathematics developed in information theory\nis highly relevant in statistical mechanics.\n86\nChapter 4\nINFORMATION THEORY\nFIGURE 4.2: Re\ufb02ection on the motive power of \ufb01re.\nThe majority of candidates I interview fail to come up with an answer to the fol-\nlowing question: what is the entropy of tossing a non-biased coin? Surprisingly, even after\nI explicitly provide them with Shannon\u2019s formulae for calculating entropy (4.4), many\nare still unable to calculate simple logarithms. The purpose of this chapter is to present\nthe aspiring data scientist with some of the most signi\ufb01cant notions of entropy and\nto elucidate its relationship to probability. Therefore, it is primarily focused on basic\nquantities in information theory such as entropy, cross-entropy, conditional entropy,\nmutual information and Kullback-Leibler divergence, also known as relative entropy.\nIt does not however, discuss more advanced topics such as the concept of \u2019active in-\nformation\u2019 introduced by Bohm and Hiley [3].\n4.2\nProblems\n4.2.1\nLogarithms in Information Theory\nIt is important to note that all numerical calculations in this chapter use the binary\nlogarithm log2. This speci\ufb01c logarithm produces units of bits, the commonly used units\nof information in the \ufb01eld on information theory.\n87\n4.2. PROBLEMS"
  },
  {
    "id": "PRB-67",
    "chapter": "",
    "question": "Run the following Python code (4.3) in a Python interpreter. What are the results?\n1 import math\n2 import numpy\n3 print (math.log(1.0/0.98)) # Natural log (ln)\n4 print (numpy.log(1.0/0.02)) # Natural log (ln)\n5\n6 print (math.log10(1.0/0.98)) # Common log (base 10)\n7 print (numpy.log10(1.0/0.02)) # Common log (base 10)\n8\n9 print (math.log2(1.0/0.98)) # Binary log (base 2)\n10 print (numpy.log2(1.0/0.02)) # Binary log (base 2)\nFIGURE 4.3: Natural (ln), binary (log2) and common (log10) logarithms.",
    "solution": "Numerical results (4.8) are provided using Python interpreter version 3.6.\n1\nimport math\n2\nimport numpy\n3\nprint (math.log(1.0/0.98)) # Natural log (ln)\n4\n> 0.02020270731751947\n5\nprint (numpy.log(1.0/0.02)) # Natural log (ln)\n6\n> 3.912023005428146\n7\nprint (math.log10(1.0/0.98)) # Common log (base 10)\n8\n> 0.008773924307505152\n9\nprint (numpy.log10(1.0/0.02)) # Common log (base 10)\n10\n> 1.6989700043360187\n11\nprint (math.log2(1.0/0.98)) # Binary log (base 2)\n12\n> 0.02914634565951651\n13\nprint (numpy.log2(1.0/0.02)) # Binary log (base 2)\n14\n> 5.643856189774724\nFIGURE 4.8: Logarithms in information theory.\n\u25a0"
  },
  {
    "id": "PRB-68",
    "chapter": "",
    "question": "The three basic laws of logarithms:\n1. First law\nlog A + log B = log AB.\n(4.1)\nCompute the following expression:\nlog10 3 + log10 4.\n2. Second law\nlog An = n log A.\n(4.2)\n88\nChapter 4\nINFORMATION THEORY\nCompute the following expression:\nlog2 46.\n3. Third law\nlog A \u2212 log B = log A\nB .\n(4.3)\nTherefore, subtracting log B from log A results in log A\nB.\nCompute the following expression:\nloge 15 \u2212 loge 3.\n4.2.2\nShannon's Entropy",
    "solution": "The logarithm base is explicitly written in each solution.\n1.\nlog10 3 + log10 4 = log10(3 \u00d7 4) = log10 12.\n2.\nlog2 46 = 6 log2 4.\n3.\nloge 15 \u2212 loge 3 = loge\n15\n3 = loge 5.\n102\nChapter 4\nINFORMATION THEORY\n\u25a0\n4.3.2\nShannon's Entropy"
  },
  {
    "id": "PRB-69",
    "chapter": "",
    "question": "Write Shannon's famous general formulae for uncertainty.",
    "solution": "Shannons famous general formulae for uncertainty is:\nH = \u2212\nN\n\ufffd\na=1\nPa log2 Pa\n(bits per symbol).\n(4.8)\n\u25a0"
  },
  {
    "id": "PRB-70",
    "chapter": "",
    "question": "Choose exactly one, and only one answer.\n1. For an event which is certain to happen, what is the entropy?\n(a) 1.0\n(b) 0.0\n(c) The entropy is unde\ufb01ned\n(d) \u22121\n(e) 0.5\n(f) log2(N), N being the number of possible events\n89\n4.2. PROBLEMS\n2. For N equiprobable events, what is the entropy?\n(a) 1.0\n(b) 0.0\n(c) The entropy is unde\ufb01ned\n(d) \u22121\n(e) 0.5\n(f) log2(N)",
    "solution": "1. No information is conveyed by an event which is a-priori known to occur for certain\n(Pa = 1), therefore the entropy is 0.\n2. Equiprobable events mean that Pi = 1/N \u2200i \u2208 [1, N]. Therefore for N equally-likely\nevents, the entropy is log2(N).\n\u25a0"
  },
  {
    "id": "PRB-71",
    "chapter": "",
    "question": "Shannon found that entropy was the only function satisfying three natural properties.\nEnumerate these properties.",
    "solution": "The three properties are as follows:\n1. H(X) is always non-negative, since information cannot be lost.\n2. The uniform distribution maximizes H(X), since it also maximizes uncertainty.\n3. The additivity property which relates the sum of entropies of two independent events.\nFor instance, in thermodynamics, the total entropy of two isolated systems which co-\nexist in equilibrium is the sum of the entropies of each system in isolation.\n\u25a0\n103\n4.3. SOLUTIONS"
  },
  {
    "id": "PRB-72",
    "chapter": "",
    "question": "In information theory, minus the logarithm of the probability of a symbol (essentially\nthe number of bits required to represent it ef\ufb01ciently in a binary code) is de\ufb01ned to be the\ninformation conveyed by transmitting that symbol. In this context, the entropy can be\ninterpreted as the expected information conveyed by transmitting a single symbol from an\nalphabet in which the symbols occur with the probabilities \u03c0k.\nMark the correct answer: Information is a/an [decrease/increase] in uncertainty.",
    "solution": "Information is an [increase] in uncertainty.\n\u25a0"
  },
  {
    "id": "PRB-73",
    "chapter": "",
    "question": "Claud Shannon's paper \u201cA mathematical theory of communication\u201d [4], marked the\nbirth of information theory. Published in 1948, it has become since the Magna Carta of the\ninformation age. Describe in your own words what is meant by the term Shannon bit.",
    "solution": "The Shannon bit has two distinctive states; it is either 0 or 1, but never both at the same\ntime. Shannon devised an experiment in which there is a question whose only two possible\nanswers were equally likely to happen.\nHe then de\ufb01ned one bit as the amount of information gained (or alternatively, the amount\nof entropy removed) once an answer to the question has been learned. He then continued to\nstate that when the a-priori probability of any one possible answer is higher than the other, the\nanswer would have conveyed less than one bit of information.\n\u25a0"
  },
  {
    "id": "PRB-74",
    "chapter": "",
    "question": "With respect to the notion of surprise in the context of information theory:\n1. De\ufb01ne what it actually meant by being surprised.\n90\nChapter 4\nINFORMATION THEORY\n2. Describe how it is related to the likelihood of an event happening.\n3. True or False: The less likely the occurrence of an event, the smaller information it\nconveys.",
    "solution": "The notion of surprise is directly related to the likelihood of an event happening. Mathem-\natically is it inversely proportional to the probability of that event.\nAccordingly, learning that a high-probability event has taken place, for instance the sun rising,\nis much less of a surprise and gives less information than learning that a low-probability\nevent, for instance, rain in a hot summer day, has taken place. Therefore, the less likely the\noccurrence of an event, the greater information it conveys.\nIn the case where an event is a-priori known to occur for certain (Pa = 1), then no inform-\nation is conveyed by it. On the other hand, an extremely intermittent event conveys a lot of\ninformation as it surprises us and informs us that a very improbable state exists. Therefore,\nthe statement in part 3 is false.\n\u25a0"
  },
  {
    "id": "PRB-75",
    "chapter": "",
    "question": "Assume a source of signals that transmits a given message a with probability Pa. Assume\nfurther that the message is encoded into an ordered series of ones and zeros (a bit string) and\nthat a receiver has a decoder that converts the bit string back into its respective message.\nShannon devised a formulae that describes the size that the mean length of the bit string can\nbe compressed to. Write the formulae.",
    "solution": "This quantity ISh, represented in the formulae is called the Shannon information of the\nsource:\nISh = \u2212\n\ufffd\na\npa log2 pa.\n(4.9)\nIt refers to the mean length in bits, per message, into which the messages can be compressed\n104\nChapter 4\nINFORMATION THEORY\nto. It is then possible for a communications channel to transmit ISh bits per message with a\ncapacity of ISh.\n\u25a0"
  },
  {
    "id": "PRB-76",
    "chapter": "",
    "question": "Answer the following questions:\n1. Assume a source that provides a constant stream of N equally likely symbols\n{x1, x2, . . . , xN}. What does Shannon's formulae (4.4) reduce to in this particular\ncase?\n2. Assume that each equiprobable pixel in a monochrome image that is fed to a DL classi-\n\ufb01cation pipeline, can have values ranging from 0 to 255. Find the entropy in bits.",
    "solution": "1. For N equiprobable events it holds that Pi = 1/N, \u2200i \u2208 [1, N]. Therefore if we substi-\ntute this into Shannon's equation we get:\nHequiprobable = \u2212\nN\n\ufffd\ni=1\n1\nN log2\n1\nN .\n(4.10)\nSince N does not depend on i, we can pull it out of the sum:\nHequiprobable\n=\n\u2212( 1\nN log2\n1\nN )\nN\n\ufffd\ni=1\n1\n(4.11)\n=\n\u2212\n\ufffd 1\nN log2\n1\nN\n\ufffd\nN\n=\n\u2212 log2\n1\nN\n(4.12)\n=\nlog2 N.\nIt can be shown that for a given number of symbols (i.e., N is \ufb01xed) the uncertainty H\nhas its largest value only when the symbols are equally probable.\n2. The probability for each pixel to be assigned a value in the given range is:\npi = 1/256.\n(4.13)\nTherefore the entropy is:\nH = \u2212(256)(1/256)(\u22128) = 8 [bits/symbol].\n(4.14)\n\u25a0"
  },
  {
    "id": "PRB-77",
    "chapter": "",
    "question": "Given Shannon's famous general formulae for uncertainty (4.4):\nH = \u2212\nN\n\ufffd\na=1\nPa log2 Pa\n(bits per symbol).\n(4.4)\n1. Plot a graph of the curve of probability vs. uncertainty.\n2. Complete the sentence: The curve is [symmetrical/asymmetrical].\n91\n4.2. PROBLEMS\n3. Complete the sentence: The curve rises to a [minimum/maximum] when the two\nsymbols are equally likely (Pa = 0.5).",
    "solution": "105\n4.3. SOLUTIONS\nRefer to Fig. 4.9 for the corresponding illustration of the graph, where information is\nshown as a function of p. It is equal to 0 for p = 0 and for p = 1. This is reasonable because for\nsuch values of p the outcome is certain, so no information is gained by learning the outcome.\nThe entropy in maximal uncertainty equals to 1 bit for p = 0.5. Thus, the information gain\nis maximal when the probabilities of two possible events are equal. Furthermore, for the entire\nrange of probabilities between p = 0.4 and p = 0.6 the information is close to 1 bit.\n\u25a0\nFIGURE 4.9: H vs. Probability"
  },
  {
    "id": "PRB-78",
    "chapter": "",
    "question": "Assume we are provided with biased coin for which the event \u2018heads\u2019 is assigned probab-\nility p, and \u2018tails\u2019 - a probability of 1 \u2212 p. Using (4.4), the respective entropy is:\nH(p) = \u2212p log p \u2212 (1 \u2212 p) log (1 \u2212 p) .\n(4.5)\nTherefore, H \u2265 0 and the maximum possible uncertainty is attained when p = 1/2, is\nHmax = log2 2.\nGiven the above formulation, describe a helpful property of the entropy that follows from\nthe concavity of the logarithmic function.",
    "solution": "An important set of properties of the entropy follows from the concavity of the entropy,\nwhich follows from the concavity of the logarithm. Suppose that in an experiment, we cannot\ndecide whether the actual probability of \u2018heads\u2019 is p1 or p2. We may decide to assign probability\nq to the \ufb01rst alternative and probability 1 \u2212 q to the second. The actual probability of \u2018heads\u2019\nthen is the mixture qp1 + (1 \u2212 q)p2. The corresponding entropies satisfy the inequality:\nS (qp1 + (1 \u2212 q)p2) \u2265 qS (p1) + (1 \u2212 q) S (p2) ,\n(4.15)\n106\nChapter 4\nINFORMATION THEORY\nThese probabilities, are equal in the extreme cases where p1 = p2, or q = 0, or q = 1.\n\u25a0"
  },
  {
    "id": "PRB-79",
    "chapter": "",
    "question": "True or False: Given random variables X, Y and Z where Y = X + Z then:\nH(X, Y ) = H(X, Z).\n(4.6)",
    "solution": "Given (X, Y ), we can determine X and Z = Y \u2212 X. Conversely, given (X, Z), we can\ndetermine X and Y = X + Z. Hence, H(X, Y ) = H(X, Z) due to the existence of this\nbijection.\n\u25a0"
  },
  {
    "id": "PRB-80",
    "chapter": "",
    "question": "What is the entropy of a biased coin? Suppose a coin is biased such that the probability\nof \u2018heads\u2019 is p(xh) = 0.98.\n1. Complete the sentence: We can predict \u2018heads\u2019 for each \ufb02ip with an accuracy of [__-\n_]%.\n2. Complete the sentence: If the result of the coin toss is \u2018heads\u2019, the amount of Shannon\ninformation gained is [___] bits.\n3. Complete the sentence: If the result of the coin toss is \u2018tails\u2019, the amount of Shannon\ninformation gained is [___] bits.\n4. Complete the sentence: It is always true that the more information is associated with\nan outcome, the [more/less] surprising it is.\n92\nChapter 4\nINFORMATION THEORY\n5. Provided that the ratio of tosses resulting in \u2018heads\u2019 is p(xh), and the ratio of tosses\nresulting in \u2018tails\u2019 is p(xt), and also provided that p(xh)+p(xt) = 1, what is formulae\nfor the average surprise?\n6. What is the value of the average surprise in bits?\n4.2.3\nKullback-Leibler Divergence (KLD)",
    "solution": "The solution and numerical calculations are provided using log2.\n1. We can predict \u2018heads\u2019 for each \ufb02ip with an accuracy of p(xh) = 98%.\n2. According to Fig. (4.10), if the result of the coin toss is \u2018heads\u2019, the amount of Shannon\ninformation gained is log2(1/0.98) [bits] .\n1\nimport\nmath\n2\nimport numpy\n3\nprint (math.log2(1.0/0.98)) # Binary log (base 2)\n4\n> 0.02914634565951651\n5\nprint (numpy.log2(1.0/0.02)) # Binary log (base 2)\n6\n> 5.643856189774724\nFIGURE 4.10: Shannon information gain for a biased coin toss.\n3. Likewise, if the result of the coin toss is \u2018tails\u2019, the amount of Shannon information\ngained is log2(1/0.02) [bits] .\n4. It is always true that the more information is associated with an outcome, the more\nsurprising it is.\n5. The formulae for the average surprise is:\nH(x)\n=\np(xh) log\n1\np(xh) + p(xt) log\n1\np(xt).\n(4.16)\n107\n4.3. SOLUTIONS\n6. The value of the average surprise in bits is (4.11):\nH(x) = [0.98 \u00d7 0.0291] + [0.02 \u00d7 5.643]\n(4.17)\n= 0.1414 [bits].\n1 import autograd.numpy as np\n2 def binaryEntropy (p):\n3\nreturn -p*np.log2(p) -(1-p)*np.log2(1-p)\n4\nprint (\"binaryEntropy(p) is:{}\nbits\".format(binaryEntropy(0.98)))\n\ufffd\u2192\n5 > binaryEntropy(p) is:0.1414 bits\nFIGURE 4.11: Average surprise\n\u25a0\n4.3.3\nKullback-Leibler Divergence"
  },
  {
    "id": "PRB-81",
    "chapter": "",
    "question": "Write the formulae for the Kullback-Leibler divergence between two discrete probability\ndensity functions P and Q.",
    "solution": "For discrete probability distributions P and Q, the Kullback-Leibler divergence from P\nto Q, the KLD is de\ufb01ned as:\nD(P \u2225 Q)\n=\n\ufffd\nx\nP(x) log P(x)\nQ(x)\n(4.18)\n=\nEP\n\ufffd\nlog\n1\nQ(x) \u2212 log\n1\nP(x)\n\ufffd\n=\nHP(Q)\n\ufffd\n\ufffd\ufffd\n\ufffd\nCross Entropy\n\u2212 H(P)\n\ufffd \ufffd\ufffd \ufffd\nEntropy\n.\n\u25a0\n108\nChapter 4\nINFORMATION THEORY"
  },
  {
    "id": "PRB-82",
    "chapter": "",
    "question": "Describe one intuitive interpretation of the KL-divergence with respect to bits.",
    "solution": "One interpretation is the following: the KL-divergence indicates the average number of\nadditional bits required for transmission of values x \u2208 X which are distributed according\nto P(x), but we erroneously encoded them according to distribution Q(x). This makes sense\nsince you have to \u201cpay\u201d for additional bits to compensate for not knowing the true distribution,\nthus using a code that was optimized according to other distribution. This is one of the reason\nthat the KL-divergence is also known as relative entropy. Formally, the cross entropy has an\ninformation interpretation quantifying how many bits are wasted by using the wrong code:\nHP(Q) =\n\ufffd\nx\nP(x)\n\ufffd \ufffd\ufffd \ufffd\nSending P\ncode for Q\n\ufffd\n\ufffd\ufffd\n\ufffd\nlog\n1\nQ(x) .\n(4.19)\n\u25a0"
  },
  {
    "id": "PRB-83",
    "chapter": "",
    "question": "1. True or False: The KL-divergence is not a symmetric measure of similarity, i.e.:\nDKL(P\u2225Q) \u0338= DKL(Q\u2225P).\n2. True or False: The KL-divergence satis\ufb01es the triangle inequality.\n3. True or False: The KL-divergence is not a distance metric.\n4. True or False: In information theory, KLD is regarded as a measure of the informa-\ntion gained when probability distribution Q is used to approximate a true probability\ndistribution P.\n5. True or False: The units of KL-divergence are units of information.\n6. True or False: The KLD is always non-negative, namely:\nDKL(P\u2225Q) \u2265 0.\n93\n4.2. PROBLEMS\n.\n7. True or False: In a decision tree, high information gain indicates that adding a split\nto the decision tree results in a less accurate model.",
    "solution": "1. True KLD is a non-symmetric measure, i.e. D(P \u2225 Q) \u0338= D(Q \u2225 P).\n2. False KLD does not satisfy the triangle inequality.\n3. True KLD is not a distance metric.\n4. True KLD is regarded as a measure of the information gain. Notice that, however, KLD\nis the amount of information lost.\n5. True The units of KL divergence are units of information (bits, nats, etc.).\n6. True KLD is a non-negative measure.\n7. True Performing splitting based on highly informative event usually leads to low model\ngeneralization and a less accurate one as well.\n\u25a0"
  },
  {
    "id": "PRB-84",
    "chapter": "",
    "question": "Given two distributions f1 and f2 and their respective joint distribution f, write the\nformulae for the mutual information of f1 and f2.",
    "solution": "109\n4.3. SOLUTIONS\nFormally, mutual information attempts to measure how correlated two variables are with\neach other:\nI(X; Y )\n=\n\ufffd\nx,y\nP(x, y) log\nP(x, y)\nP(x)P(y)\n(4.20)\n=\nE\n\ufffd\nlog\n1\nP(x) + log\n1\nP(y) \u2212 log\n1\nP(x, y)\n\ufffd\n=\nH(X) + H(Y ) \u2212 H(X, Y ).\nRegarding the question at hand, given two distributions f1 and f2 and their joint distri-\nbution f, the mutual information of f1 and f2 is de\ufb01ned as I(f1, f2) = H(f, f1f2). If the\ntwo distributions are independent, i.e. f = f1 \u00b7 f2, the mutual information will vanish. This\nconcept has been widely used as a similarity measure in image analysis.\n\u25a0"
  },
  {
    "id": "PRB-85",
    "chapter": "",
    "question": "The question was commented out but remained here for the consistency of the numbering\nsystem.\n4.2.4\nClassification and Information Gain",
    "solution": "The question was commented out but remained here for the consistency of the numbering\nsystem.\n\u25a0\n4.3.4\nClassification and Information Gain"
  },
  {
    "id": "PRB-86",
    "chapter": "",
    "question": "There are several measures by which one can determine how to optimally split attributes\nin a decision tree. List the three most commonly used measures and write their formulae.",
    "solution": "The three most widely used methods are:\n1.\nEntropy (t) = \u2212\nc\u22121\n\ufffd\ni=0\np(i) log2 p(i).\n(4.21)\n2.\n1 \u2212\nc\u22121\n\ufffd\ni=0\n[p(i)]2\n(4.22)\n110\nChapter 4\nINFORMATION THEORY\n3.\nClassi\ufb01cation error (t) = 1 \u2212 max\ni [p(i)].\n(4.23)\n\u25a0"
  },
  {
    "id": "PRB-87",
    "chapter": "",
    "question": "Complete the sentence: In a decision tree, the attribute by which we choose to split is\nthe one with [minimum/maximum] information gain.",
    "solution": "In a decision tree, the attribute by which we choose to split is the one with [maximum]\ninformation gain.\n\u25a0"
  },
  {
    "id": "PRB-88",
    "chapter": "",
    "question": "To study factors affecting the decision of a frog to jump (or not), a deep learning re-\nsearcher from a Brazilian rain-forest, collects data pertaining to several independent binary\nco-variates.\n94\nChapter 4\nINFORMATION THEORY\nFIGURE 4.4: A Frog in its natural habitat. Photo taken by my son.\nThe binary response variable Jump indicates whether a jump was observed. Referring to\nTable (4.1), each row indicates the observed values, columns denote features and rows denote\nlabelled instances while class label (Jump) denotes whether the frog had jumped.\nObservation\nGreen\nRain\nJump\nx1\n1\n0\n+\nx2\n1\n1\n+\nx3\n1\n0\n+\nx4\n1\n1\n+\nx5\n1\n0\n+\nx6\n0\n1\n+\nx7\n0\n0\n\u2212\nx8\n0\n1\n\u2212\nTABLE 4.1: Decision trees and frogs.\nWithout explicitly determining the information gain values for each of the three attrib-\nutes, which attribute should be chosen as the attribute by which the decision tree should be\n\ufb01rst partitioned? e.g which attribute has the highest predictive power regarding the decision\nof the frog (Fig. 4.4) to jump.\n95\n4.2. PROBLEMS",
    "solution": "It is clear that the entropy will be decreased more by \ufb01rst splitting on Green rather than\non Rain.\nFIGURE 4.12: First split.\n\u25a0"
  },
  {
    "id": "PRB-89",
    "chapter": "",
    "question": "This question discusses the link between binary classi\ufb01cation, information gain and de-\ncision trees. Recent research [5] suggests that Cannabis (Fig. 4.5), and Cannabinoids ad-\nministration in particular may reduce the size of malignant tumours in rodents. The data\n(Table 9.2) comprises a training set of feature vectors with corresponding class labels which\na researcher intents classifying using a decision tree.\nFIGURE 4.5: Cannabis\nTo study factors affecting tumour shrinkage, the deep learning researcher collects data\nregrading two independent binary variables; \u03b81 (T/F) indicating whether the rodent is a fe-\nmale, and \u03b82 (T/F) indicating whether the rodent was administrated with Cannabinoids. The\nbinary response variable, \u03b3, indicates whether tumour shrinkage was observed (e.g. shrink-\nage=+, no shrinkage=-). Referring to Table (9.2), each row indicates the observed values,\ncolumns (\u03b8i) denote features and class label (\u03b3) denotes whether shrinkage was observed.\n\u03b3\n\u03b81\n\u03b82\n+\nT\nT\n-\nT\nF\n+\nT\nF\n+\nT\nT\n-\nF\nT\nTABLE 4.2: Decision trees and Cannabinoids administration\n96\nChapter 4\nINFORMATION THEORY\n1. Describe what is meant by information gain.\n2. Describe in your own words how does a decision tree work.\n3. Using log2, and the provided dataset, calculate the sample entropy H(\u03b3).\n4. What is the information gain IG(X1) \u2261 H(\u03b3) \u2212 H(|\u03b81) for the provided training\ncorpus?",
    "solution": "1. Information gain is the expected reduction in entropy caused by partitioning values in\na dataset according to a given attribute.\n2. A decision tree learning algorithm chooses the next attribute to partition the currently\nselected node, by \ufb01rst computing the information gain from the entropy, for instance,\nas a splitting criterion.\n3. There are 3 positive examples corresponding to Shrinkage=+, and 2 negative examples\n111\n4.3. SOLUTIONS\ncorresponding to Shrinkage=-. Using the formulae:\nH(Y ) = \u2212\nk\n\ufffd\ni=1\nP(Y = yi) log2 P(Y = yi)\n(4.24)\nand the probabilities:\nP(\u03b3 = +) = 3\n5,\n(4.25)\nP(\u03b3 = \u2212) = 2\n5,\n(4.26)\nthe overall entropy before splitting is (4.13):\nEorig = \u2212(3/5) log(3/5) \u2212 (2/5) log(2/5)\n= H(\u03b3) \u2248 0.97095[bits/symbol].\n(4.27)\n1 import autograd.numpy as np\n2\ndef binaryEntropy (p):\n3\nreturn -p*np.log2(p) -(1-p)*np.log2(1-p)\n4\n5 print (\"binaryEntropy(p) is:{} bits\".format(binaryEntropy(4/7)))\n6 > binaryEntropy(p) is: 0.97095 bits\nFIGURE 4.13: Entropy before splitting.\n4. If we split on \u03b81, (4.5) the relative shrinkage frequency is:\n112\nChapter 4\nINFORMATION THEORY\nTotal\n\u03b81 = T\n\u03b81 = F\n+\n3\n0\n-\n1\n1\nTABLE 4.5: Splitting on \u03b81.\nTo compute the information gain (IG) based on feature \u03b81, we must \ufb01rst compute the\nentropy of \u03b3 after a split based on \u03b81, H(\u03b3|\u03b81):\nH(\u03b3|\u03b81)\n= \u2212\nv\n\ufffd\nj=1\n\ufffd k\n\ufffd\ni=1\nP(\u03b3 = \u03b3i|\u03b81 = \u03b8j) log2 P(\u03b3 = \u03b3i|\u03b81 = \u03b8j)\n\ufffd\nP(\u03b81 = \u03b8j).\nTherefore, using the data for the the relative shrinkage frequency (4.5), the information\ngain after splitting on \u03b81 is:\nE\u03b81=T = \u22123\n4 log 3\n4 \u2212 1\n4 log 1\n4 = 0.8112,\nE\u03b81=F = \u22120\n1 log 0\n1 \u2212 1\n1 log 1\n1 = 0.0.\n(4.28)\nNow we know that P(\u03b81 = T) = 4/5 and P(\u03b81 = F) = 1/5 , therefore:\n\u2206 = Eorig \u2212 (4/5) E\u03b81=T \u2212 (1/5) E\u03b81=F\n= 0.97095 \u2212 (4/5) \u2217 0.8112 \u2212 (1/5) \u2217 (0.0)\n=\u2248 0.32198 [bits/symbol].\n(4.29)\n\u25a0"
  },
  {
    "id": "PRB-90",
    "chapter": "",
    "question": "To study factors affecting the expansion of stars, a physicist is provided with data re-\ngrading two independent variables; \u03b81 (T/F) indicating whether a star is dense, and \u03b82 (T/F)\nindicating whether a star is adjacent to a black-hole. He is told that the binary response vari-\nable, \u03b3, indicates whether expansion was observed.\ne.g.:\nexpansion=+, no expansion=-. Referring to table (4.3), each row indicates the observed val-\nues, columns (\u03b8i) denote features and class label (\u03b3) denotes whether expansion was observed.\n\u03b3 (expansion)\n\u03b81 (dense)\n\u03b82 (black-hole)\n+\nF\nT\n+\nT\nT\n+\nT\nT\n-\nF\nT\n+\nT\nF\n-\nF\nF\n-\nF\nF\nTABLE 4.3: Decision trees and star expansion.\n1. Using log2 and the provided dataset, calculate the sample entropy H(\u03b3) (expansion)\nbefore splitting.\n2. Using log2 and the provided dataset, calculate the information gain of H(\u03b3|\u03b81).\n97\n4.2. PROBLEMS\n3. Using log2 and the provided dataset, calculate the information gain of H(\u03b3|\u03b82).",
    "solution": "There are 4 positive examples corresponding to Expansion=+, and 3 negative examples\n113\n4.3. SOLUTIONS\ncorresponding to Expansion=-.\n1. The overall entropy before splitting is (4.14):\nEorig = \u2212(4/7) log(4/7) \u2212 (3/7) log(3/7)\n= 0.9852281 [bits/symbol].\n(4.30)\n1 import autograd.numpy as np\n2\ndef binaryEntropy (p):\n3\nreturn -p*np.log2(p) -(1-p)*np.log2(1-p)\n4\n5 print (\"binaryEntropy(p) is:{} bits\".format(binaryEntropy(4/7)))\n6 > binaryEntropy(p) is:0.9852281 bits\nFIGURE 4.14: Entropy before splitting.\n2. If we split on \u03b81, (4.6) the relative star expansion frequency is:\nTotal\n\u03b81 = T\n\u03b81 = F\n+\n3\n1\n-\n0\n3\nTABLE 4.6: Splitting on \u03b81.\nTherefore, the information gain after splitting on A is:\nE\u03b81=T = \u22123\n3 log 3\n3 \u2212 0\n3 log 0\n3 = 0.0,\nE\u03b81=F = \u22123\n4 log 3\n4 \u2212 1\n4 log 1\n4 = 0.81127.\n(4.31)\n114\nChapter 4\nINFORMATION THEORY\nNow we know that P(\u03b81 = T) = 3/7 and P(\u03b81 = F) = 4/7 , therefore:\n\u2206 = Eorig \u2212 (3/7) E\u03b81=T \u2212 (4/7) E\u03b81=F\n= 0.98522 \u2212 (3/7) \u2217 0.0 \u2212 (4/7) \u2217 (0.81127)\n= 0.52163 [bits/symbol].\n(4.32)\n3. If we split on \u03b82, (4.7) the relative star expansion frequency is:\nTotal\n\u03b82 = T\n\u03b82 = F\n+\n3\n1\n-\n1\n2\nTABLE 4.7: Splitting on \u03b82.\nThe information gain after splitting on B is:\nE\u03b82=T = \u22123\n4 log 3\n4 \u2212 1\n4 log 1\n4 = 0.0.8112,\nE\u03b82=F = \u22121\n3 log 1\n3 \u2212 2\n3 log 2\n3 = 0.9182.\n(4.33)\nNow we know that P(\u03b82 = T) = 4/7 and P(\u03b82 = F) = 3/7 , therefore:\n\u2206 = Eorig \u2212 (4/7) E\u03b82=T \u2212 (3/7) E\u03b82=F\n= 0.98522 \u2212 (4/7) \u2217 0.8122 \u2212 (3/7) \u2217 (0.9182)\n0.1275 [bits/symbol].\n\u2206 = 0.98522 \u2212 (4/7) \u2217 0.8122 \u2212 (3/7) \u2217 (0.9182)\n0.1275 [bits/symbol].\n(4.34)\n\u25a0\n115\n4.3. SOLUTIONS"
  },
  {
    "id": "PRB-91",
    "chapter": "",
    "question": "To study factors affecting tumour shrinkage in humans, a deep learning researcher is\nprovided with data regrading two independent variables; \u03b81 (S/M/L) indicating whether the\ntumour is small(S), medium(M) or large(L), and \u03b82 (T/F) indicating whether the tumour\nhas undergone radiation therapy. He is told that the binary response variable, \u03b3, indicates\nwhether tumour shrinkage was observed (e.g. shrinkage=+, no shrinkage=-).\nReferring to table (4.4), each row indicates the observed values, columns (\u03b8i) denote\nfeatures and class label (\u03b3) denotes whether shrinkage was observed.\n\u03b3 (shrinkage)\n\u03b81\n\u03b82\n-\nS\nF\n+\nS\nT\n-\nM\nF\n+\nM\nT\n+\nH\nF\n+\nH\nT\nTABLE 4.4: Decision trees and radiation therapy.\n1. Using log2 and the provided dataset, calculate the sample entropy H(\u03b3) (shrinkage).\n2. Using log2 and the provided dataset, calculate the entropy of H(\u03b3|\u03b81).\n3. Using log2 and the provided dataset, calculate the entropy of H(\u03b3|\u03b82).\n4. True or false: We should split on a speci\ufb01c variable that minimizes the information\ngain, therefore we should split on \u03b82 (radiation therapy).\n4.2.5\nMutual Information",
    "solution": "1.\nH(\u03b3) = \u2212\n\ufffd2\n6 log2\n2\n6 + 4\n6 log2\n4\n6\n\ufffd\nH(\u03b3) = \u2212\n\ufffd1\n3 log2\n1\n3 + 2\n3 log2\n2\n3\n\ufffd\n\u2248 0.92 [bits/symbol].\n(4.35)\n2.\nH(\u03b3|\u03b81) = \u22121\n3\n\ufffd1\n2 log2\n1\n2 + 1\n2 log2\n1\n2\n\ufffd\n\u2212\n1\n3\n\ufffd1\n2 log2\n1\n2 + 1\n2 log2\n1\n2\n\ufffd\n\u2212 1\n3 (1 log2 1) .\nH(\u03b3|\u03b81) = 1\n3(1) + 1\n3(1) + 1\n3(0).\nH(\u03b3|\u03b81) = 2\n3 \u2248 0.66[bits/symbol].\n(4.36)\n3.\nH(\u03b3|\u03b82) = \u22121\n2\n\ufffd1\n3 log2\n1\n3 + 2\n3 log2\n2\n3\n\ufffd\n\u2212 1\n2 (1 log2 1) .\nH(\u03b3|\u03b82) = 1\n2\n\ufffd\nlog2 3 \u2212 2\n3\n\ufffd\n.\nH(\u03b3|\u03b82) = 1\n2 log2 3 \u2212 1\n3 \u2248 0.46 [bits/symbol].\n(4.37)\n4. False.\n\u25a0\n4.3.5\nMutual Information"
  },
  {
    "id": "PRB-92",
    "chapter": "",
    "question": "98\nChapter 4\nINFORMATION THEORY\nShannon described a communications system consisting \ufb01ve elements (4.6), two of which\nare the source S and the destination D.\nSourse S\nTrans\nT\nChannel\nCH\nReceiver\nR\nDest\nD\nMESSAGE\nSIGNAL\nSIGNAL\nMESSAGE\nFIGURE 4.6: Shannon's \ufb01ve element communications system.\n1. Draw a Venn diagram depicting the relationship between the entropies of the source\nH(S) and of the destination H(D).\n2. Annotate the part termed equivocation.\n3. Annotate the part termed noise.\n4. Annotate the part termed mutual information.\n5. Write the formulae for mutual information.",
    "solution": "1. The diagram is depicted in Fig. 4.15.\n116\nChapter 4\nINFORMATION THEORY\nE\nN\nH(S)\nH(D)\nFIGURE 4.15: Mutual Information between H(S) & H(D).\n2. Equivocation is annotated by E.\n3. Noise is annotated by N.\n4. The intersection (shaded area) in (4.15) corresponds to mutual information of the source\nH(S) and of the destination H(D).\n5. The formulae for mutual information is:\nH(S; D) = H(S) \u2212 E = H(D) \u2212 N.\n(4.38)\n\u25a0"
  },
  {
    "id": "PRB-93",
    "chapter": "",
    "question": "Complete the sentence: The relative entropy D(p||q) is the measure of (a) [___] between\n99\n4.2. PROBLEMS\ntwo distributions. It can also be expressed as a measure of the (b)[___] of assuming that the\ndistribution is q when the (c)[___] distribution is p.",
    "solution": "The relative entropy D(p||q) is the measure of difference between two distributions. It\ncan also be expressed like a measure of the inef\ufb01ciency of assuming that the distribution is q\nwhen the true distribution is p.\n\u25a0"
  },
  {
    "id": "PRB-94",
    "chapter": "",
    "question": "Complete the sentence: Mutual information is a Shannon entropy-based measure of\ndependence between random variables. The mutual information between X and Z can be\nunderstood as the (a) [___] of the (b) [___] in X given Z:\nI(X; Z) := H(X) \u2212 H(X | Z),\n(4.7)\nwhere H is the Shannon entropy, and H(X | Z) is the conditional entropy of Z given X.\n4.2.6\nMechanical Statistics\nSome books have a tendency of sweeping \"unseen\" problems under the rug. We will\nnot do that here. This subsection may look intimidating and for a good reason; it\ninvolves equations that, unless you are a physicists, you have probably never en-\ncountered before. Nevertheless, the ability to cope with new concepts lies at the heart\nof every job interview.\nFor some of the questions, you may need these constants:\nPHYSICAL CONSTANTS\nk\nBoltzmanns constant\n1.381 \u00d7 10\u221223 J K\u22121\nc\nSpeed of light in vacum\n2.998 \u00d7 108m s\u22121\nh\nPlanck\u2019s constant\n6.626 \u00d7 10\u221234 J s",
    "solution": "Mutual information is a Shannon entropy-based measure of dependence between random\nvariables. The mutual information between X and Z can be understood as the reduction of\n117\n4.3. SOLUTIONS\nthe uncertainty in X given Z:\nI(X; Z) := H(X) \u2212 H(X | Z),\n(4.39)\nwhere H is the Shannon entropy, and H(X | Z) is the conditional entropy of Z given X.\n\u25a0\n4.3.6\nMechanical Statistics"
  },
  {
    "id": "PRB-95",
    "chapter": "",
    "question": "What is the expression for the Boltzmann probability distribution?",
    "solution": "Is this question valuable?\n\u25a0"
  },
  {
    "id": "PRB-96",
    "chapter": "",
    "question": "Information theory, quantum physics and thermodynamics are closely interconnected.\nThere are several equivalent formulations for the second law of thermodynamics. One ap-\nproach to describing uncertainty stems from Boltzmanns fundamental work on entropy in\n100\nChapter 4\nINFORMATION THEORY\nstatistical mechanics. Describe what is meant by Boltzmanns entropy.",
    "solution": "Boltzmann related the degree of disorder of the state of a physical system to the logarithm\nof its probability. If, for example, the system has n non-interacting and identical particles,\neach capable of existing in each of K equally likely states, the leading term in the logarithm of\nthe probability of \ufb01nding the system in a con\ufb01guration with n1 particles in state 1, n2 in state\n2, etc, is given by the Boltzmann entropy H\u03c0 = \u2212 \ufffdK\n1 \u03c0i log(\u03c0i), where \u03c0i = ni/n.\n\u25a0"
  },
  {
    "id": "PRB-97",
    "chapter": "",
    "question": "From Boltzmanns perspective, what is the entropy of an octahedral dice (4.7)?\nFIGURE 4.7: An octahedral dice.\n4.2.7\nJensen's inequality",
    "solution": "There are 8 equiprobable events in each roll of the dice, therefore:\nH = \u2212\n8\n\ufffd\ni=1\n1\n8 log2\n1\n8 = 3 [bits] .\n(4.40)\n\u25a0\n4.3.7\nJensen's inequality"
  },
  {
    "id": "PRB-98",
    "chapter": "",
    "question": "1. De\ufb01ne the term concave function.\n2. De\ufb01ne the term convex function.\n3. State Jensen's inequality and its implications.",
    "solution": "1. A function f is concave in the range [a, b] if f\u03c62 is negative in the range [a, b].\n2. A function f is convex in the range [a, b] if f\u03c62 is positive in the range [a, b].\n118\nChapter 4\nINFORMATION THEORY\n3. The following inequality was published by J.L. Jensen in 1906:\n(Jensen\u2019s Inequality) Let f be a function convex up on (a, b). Then for any n \u2265 2\nnumbers xi \u2208 (a, b):\nf\n\ufffd\ufffdn\ni=1 xi\nn\n\ufffd\n\u2264\n\ufffdn\ni=1 f(xi)\nn\n,\nand that the equality is attained if and only if f is linear or all xi are equal.\nFor a convex down function, the sign of the inequality changes to \u2265.\nJensen\u2019s inequality states that if f is convex in the range [a, b], then:\nf(a) + f(b)\n2\n\u2265 f\n\ufffda + b\n2\n\ufffd\n.\nEquality holds if and only if a = b. Jensen\u2019s inequality states that if f is concave in the\nrange [a, b], then:\nf(a) + f(b)\n2\n\u2264 f\n\ufffda + b\n2\n\ufffd\n.\nEquality holds if and only if a = b.\n\u25a0"
  },
  {
    "id": "PRB-99",
    "chapter": "",
    "question": "True or False: Using Jensen's inequality, it is possible to show that the KL divergence\nis always greater or equal to zero.\n4.3\nSolutions\n4.3.1\nLogarithms in Information Theory\n101\n4.3. SOLUTIONS",
    "solution": "True The non-negativity of KLD can be proved using Jensen's inequality.\n\u25a0\nReferences\n[1]\nS. Carnot. Re\ufb02ections on the Motive Power of Fire: And Other Papers on the Second\nLaw of Thermodynamics. Dover books on physics. Dover Publications, 2012 (cit.\non p. 86).\n[2]\nT. M. Cover and J. A. Thomas. Elements of Information Theory. John Wiley and\nSons, Inc., 2006 (cit. on p. 86).\n[3]\nB. J. Hiley. \u2018From the Heisenberg Picture to Bohm: a New Perspective on Active\nInformation and its relation to Shannon Information\u2019. In: Proc. Conf. Quantum\nTheory: reconsideration of foundations (2002), pp. 141\u2013162 (cit. on p. 87).\n119\nREFERENCES\n[4]\nC. Shannon. \u2018A mathematical theory of communication\u2019. In: Bell System Technical\nJournal 27 (1948), pp. 379\u2013423 (cit. on pp. 86, 90).\n[5]\nP. Sledzinski et al. \u2018The current state and future perspectives of cannabinoids in\ncancer biology\u2019. In: Cancer Medicine 7.3 (2018), pp. 765\u2013775 (cit. on p. 96).\n120\nCHAPTER\n5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nThe true logic of this world is in the calculus of probabilities.\n\u2014 James C. Maxwell\nContents\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\nProblems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\nAD, Gradient descent & Backpropagation . . . . . . . . . . . . . . . . . 124\nNumerical differentiation\n. . . . . . . . . . . . . . . . . . . . . . . . . . 125\nDirected Acyclic Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . 126\nThe chain rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\nTaylor series expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\nLimits and continuity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130\nPartial derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130\nOptimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\nThe Gradient descent algorithm . . . . . . . . . . . . . . . . . . . . . . . 132\nThe Backpropagation algorithm . . . . . . . . . . . . . . . . . . . . . . . 134\nFeed forward neural networks\n. . . . . . . . . . . . . . . . . . . . . . . 135\nActivation functions, Autograd/JAX . . . . . . . . . . . . . . . . . . . . 136\nDual numbers in AD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138\nForward mode AD\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\nForward mode AD table construction\n. . . . . . . . . . . . . . . . . . . 142\nSymbolic differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\nSimple differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\nThe Beta-Binomial model\n. . . . . . . . . . . . . . . . . . . . . . . . . . 144\nSolutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\n5.1. INTRODUCTION\nAlgorithmic differentiation, Gradient descent . . . . . . . . . . . . . . . 146\nNumerical differentiation\n. . . . . . . . . . . . . . . . . . . . . . . . . . 146\nDirected Acyclic Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . 147\nThe chain rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149\nTaylor series expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150\nLimits and continuity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151\nPartial derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152\nOptimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153\nThe Gradient descent algorithm . . . . . . . . . . . . . . . . . . . . . . . 155\nThe Backpropagation algorithm . . . . . . . . . . . . . . . . . . . . . . . 156\nFeed forward neural networks\n. . . . . . . . . . . . . . . . . . . . . . . 158\nActivation functions, Autograd/JAX . . . . . . . . . . . . . . . . . . . . 158\nDual numbers in AD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163\nForward mode AD\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166\nForward mode AD table construction\n. . . . . . . . . . . . . . . . . . . 168\nSymbolic differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . 172\nSimple differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172\nThe Beta-Binomial model\n. . . . . . . . . . . . . . . . . . . . . . . . . . 174\n5.1\nIntroduction\nC\nALCULUS is the mathematics of change; the differentiation of a function is\nkey to almost every domain in the scienti\ufb01c and engineering realms and\ncalculus is also very much central to DL. A standard curriculum of \ufb01rst year\ncalculus includes topics such as limits, differentiation, the derivative, Taylor\nseries, integration, and the integral. Many aspiring data scientists who lack a relevant\nmathematical background and are shifting careers, hope to easily enter the \ufb01eld but\nfrequently encounter a mental barricade.\n122\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nf(x)\nf \u2032(x)\nsin(x)\ncos(x)\ncos(x)\n\u2212 sin(x)\nlog(x)\n1\nx\nex\nex\nThanks to the rapid advances in processing power and the proliferation of GPUs,\nit is possible to lend the burden of computation to a computer with high ef\ufb01ciency\nand precision. For instance, extremely fast implementations of backpropagation, the\ngradient descent algorithm, and automatic differentiation (AD) [5] brought arti\ufb01cial in-\ntelligence from a mere concept to reality.\nCalculus is frequently taught in a way that is very burdensome to the student,\ntherefore I tried incorporating the writing of Python code snippets into the learning\nprocess and the usage of:\nDAGs (Directed Acyclic Graphs). Gradient descent is the essence of optimization in\ndeep learning, which requires ef\ufb01cient access to \ufb01rst and second order derivatives that\nAD frameworks provide. While older AD frameworks were written in C++ ([4]), the\nnewer ones are Python-based such as Autograd ([10]) and JAX ([3], [1]).\nDerivatives are also crucial in graphics applications. For example, in a render-\ning technique entitled global illumination, photons bounce in a synthetically generated\nscene while their direction and colour has to be determined using derivatives based\non the speci\ufb01c material each photon hits. In ray tracing algorithms, the colour of the\npixels is determined by tracing the trajectory the photons travel from the eye of the\nobserver through a synthetic 3D scene.\nA function is usually represented by a DAG. For instance, one commonly used\nform is to represent intermediate values as nodes and operations as arcs (5.2). One\nother commonly used form is to represent not only the values but also the operations\nas nodes (5.11).\nThe \ufb01rst representation of a function by a DAG goes back to [7].\n123\n5.2. PROBLEMS\nx\ny\nk\nf(a)\nf(b)\na\nb\nc\nFIGURE 5.1: Intermediate value theorem\nManual differentiation is tedious and error-prone and practically unusable for real-\ntime graphics applications wherein numerous successive derivatives have to be re-\npeatedly calculated. Symbolic differentiation on the other hand, is a computer based\nmethod that uses a collection of differentiation rules to analytically calculate an exact\nderivative of a function resulting in a purely symbolic derivatives. Many symbolic\ndifferentiation libraries utilize what is known as operator-overloading ([9]) for both the\nforward and reverse forms of differentiation, albeit they are not quite as fast as AD.\n5.2\nProblems\n5.2.1\nAD, Gradient descent & Backpropagation\nAD [5] is the application of the chain rule to functions by computers in order to auto-\nmatically compute derivatives. AD plays a signi\ufb01cant role in training deep learning\nalgorithms and in order to understand AD you need a solid grounding in Calculus. As\nopposed to numerical differentiation, AD is a procedure for establishing exact deriv-\natives without any truncation errors. AD breaks a computer program into a series of\nfundamental mathematical operations, and the gradient or Hessian of the computer\nprogram is found by successive application of the chain rule (5.1) to it\u2019s elementary\nconstituents.\n124\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nFor instance, in the C++ programming language, two techniques ([4]) are com-\nmonly utilized in transforming a program that calculates numerical values of a func-\ntion into a program which calculates numerical values for derivatives of that function;\n(1) an operator overloading approach and (2) systematic source code transformation.\n\u2202\n\u2202tf(g(t))\n\ufffd\ufffd\ufffd\ufffd\ufffd\nt=t0\n=\n\uf8eb\n\uf8ed \u2202\n\u2202sf(s)\n\ufffd\ufffd\ufffd\ufffd\ufffd\ns=g(t0)\n\uf8f6\n\uf8f8\n\ufffd \u2202\n\u2202tg(t)\n\ufffd\ufffd\ufffd\ufffd\ufffd\nt=t0\n\ufffd\n(5.1)\nOne notable feature of AD is that the values of the derivatives produced by apply-\ning AD, as opposed to numerical differentiation (\ufb01nite difference formulas), are exact\nand accurate. Two variants of AD are widely adopted by the scienti\ufb01c community: the\nforward mode or the reverse mode where the underlying distinction between them is\nthe order in which the chain rule is being utilized. The forward mode, also entitled\ntangent mode, propagates derivatives from the dependent towards the independent\nvariables, whereas the reverse or adjoint mode does exactly the opposite. AD makes\nheavy use of a concept known as dual numbers (DN) \ufb01rst introduced by Clifford ([2]).\nx1\nv1\nv2\nf\n(x)2\nln(1 + v1)\nexp(v1)\nv2 + 1\nFIGURE 5.2: A Computation graph with intermediate values as nodes and operations as\narcs.\n5.2.2\nNumerical differentiation"
  },
  {
    "id": "PRB-100",
    "chapter": "",
    "question": "1. Write the formulae for the \ufb01nite difference rule used in numerical differentiation.\n2. What is the main problem with this formulae?\n125\n5.2. PROBLEMS\n3. Indicate one problem with software tools which utilize numerical differentiation and\nsuccessive operations on \ufb02oating point numbers.",
    "solution": "1. The formulae is:\nf \u2032(x) \u2248 f(x + h) \u2212 f(x)\nh\n.\n(5.28)\n2. The main problem with this formulae is that it suffers from numerical instability for\nsmall values of h.\n3. In some numerical software systems, the number\n\u221a\n2 may be represented as the a \ufb02oat-\ning point number \u2248 1.414213562. Therefore, the result of:\nfloat\n\ufffd\ufffd\n(2)\n\ufffd\n\u2217 float\n\ufffd\ufffd\n(2)\n\ufffd\nmay equal \u2248 2.000000446.\n\u25a0"
  },
  {
    "id": "PRB-101",
    "chapter": "",
    "question": "1. Given a function f(x) and a point a, de\ufb01ne the instantaneous rate of change of\nf(x) at a.\n2. What other commonly used alternative name does the instantaneous rate of change\nhave?\n3. Given a function f(x) and a point a, de\ufb01ne the tangent line of f(x) at a.\n5.2.3\nDirected Acyclic Graphs\nThere are two possible ways to traverse a DAG (Directed Acyclic Graph). One\nmethod is simple. Start at the bottom and go through all nodes to the top of the com-\nputational tree. That is nothing else than passing the corresponding computation se-\nquence top down. Based on this method, the so called forward mode or of AD was\ndeveloped [8]. In contrast to this forward mode the reverse mode was \ufb01rst used by\nSpeelpenning [13] who passed the underlying graph top down and propagated the\ngradient backwards.",
    "solution": "146\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1. The instantaneous rate of change equals:\nlim\nh\u21920\nf(a + h) \u2212 f(a)\na + h \u2212 a\n.\n(5.29)\n2. The instantaneous rate of change of f(x) at a is also commonly known as the tangent\nline of f(x) at a.\n3. Given a function f(x) and a point a, the tangent (Fig. 5.12) line of f(x) at a is a line\nthat touches f(a) but does not cross f(x) (suf\ufb01ciently close to a).\nFIGURE 5.12: A Tangent line\n\u25a0\n5.3.3\nDirected Acyclic Graphs"
  },
  {
    "id": "PRB-102",
    "chapter": "",
    "question": "1. State the de\ufb01nition of the derivative f(c) of a function f(x) at x = c.\n2. With respect to the DAG depicted in 5.3:\n126\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nx\n\u221ax\n1\n/\ng(x)\nFIGURE 5.3: An expression graph for g(x). Constants are shown in gray, crossed-out since\nderivatives should not be propagated to constant operands.\n(a) Traverse the graph 5.3 and \ufb01nd the function g(x) it represents.\n(b) Using the de\ufb01nition of the derivative, \ufb01nd g\u2032(9).",
    "solution": "147\n5.3. SOLUTIONS\n1. The de\ufb01nition is:\nf \u2032(c) = lim\nh\u21920\nf(c + h) \u2212 f(c)\nh\n.\n2. If we traverse the graph 5.3 from left to right we derive the following function:\ng(x) =\n1\n\u221ax.\n(5.30)\nf \u2032(9) = lim\nh\u21920\n1/\n\u221a\n9 + h \u2212 1/\n\u221a\n9\nh\n= lim\nh\u21920\n\u221a\n9 \u2212\n\u221a\n9 + h\n\u221a\n9 \u00b7\n\u221a\n9 + h \u00b7 h\n= lim\nh\u21920\n(3 \u2212\n\u221a\n9 + h)(3 +\n\u221a\n9 + h)\n3\n\u221a\n9 + h \u00b7 (3 +\n\u221a\n9 + h) \u00b7 h\n= lim\nh\u21920\n9 \u2212 (9 + h)\n9\n\u221a\n9 + h \u00b7 h + 3 \u00b7 (9 + h) \u00b7 h\n= \u2212\n1\n9 \u00b7 3 + 3 \u00b7 9\n= \u2212 1\n54\n\u25a0"
  },
  {
    "id": "PRB-103",
    "chapter": "",
    "question": "1. With respect to the expression graph depicted in 5.4, traverse the graph and \ufb01nd the\nfunction g(x) it represents.\nx\n**2\n2\n*\n-\n+\n1\ng(x)\nFIGURE 5.4: An expression graph for g(x). Constants are shown in gray, crossed-out since\nderivatives should not be propagated to constant operands.\n2. Using the de\ufb01nition of the derivative \ufb01nd the derivative of g(x).\n5.2.4\nThe chain rule",
    "solution": "1. The function g(x) = 2x2 \u2212 x + 1 represents the expression graph depicted in 5.4.\n148\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n2. By the de\ufb01nition:\nf \u2032(x) = lim\nh\u21920\nf(x + h) \u2212 f(x)\nx + h \u2212 x\n= lim\nh\u21920\n2(x + h)2 \u2212 (x + h) + 1 \u2212 2x2 + x \u2212 1\nh\n= lim\nh\u21920\n2(x2 + 2xh + h2) \u2212 x \u2212 h + 1 \u2212 2x2 + x \u2212 1\nh\n= lim\nh\u21920\n2x2 + 4xh + 2h2 \u2212 x \u2212 h + 1 \u2212 2x2 + x \u2212 1\nh\n= lim\nh\u21920\n4xh + 2h2 \u2212 h\nh\n= lim\nh\u21920 4x + 2h \u2212 1\n= 4x \u2212 1.\n(5.31)\nf(x) = 2x2 \u2212 x + 1\nf \u2032(x) = 4x \u2212 1\n\u25a0\n5.3.4\nThe chain rule"
  },
  {
    "id": "PRB-104",
    "chapter": "",
    "question": "127\n5.2. PROBLEMS\n1. The chain rule is key concept in differentiation. De\ufb01ne it.\n2. Elaborate how the chain rule is utilized in the context of neural networks.\n5.2.5\nTaylor series expansion\nThe idea behind a Taylor series is that if you know a function and all its derivatives\nat one point x = a, you can approximate the function at other points near a. As an\nexample, take f(x) = \u221ax. You can use Taylor series to approximate\n\u221a\n10 by knowing\nf(9) and all the derivatives f \u2032(9), f \u2032\u2032(9).\nThe MacLaurin series (5.2) is a special case of Taylor series when f(0), f \u2032(0) are\nknown:\nf(x) = f(0) + xf \u2032(0) + x2\n2! f \u2032\u2032(0) + x3\n3! f \u2032\u2032\u2032(0) + \u00b7 \u00b7 \u00b7 =\n\u221e\n\ufffd\np=0\nxp\np! f (p)(0)\n(5.2)\nFor instance, the Maclaurin expansion of cos(x) is:\nf(x) = cos x,\nf \u2032(x) = \u2212 sin x,\nf \u2032\u2032(x) = \u2212 cos x,\nf \u2032\u2032\u2032(x) = sin x\n(5.3)\nWhen evaluated at 0 results in:\ncos x = 1 \u2212 x2\n2! + x4\n4! \u2212 x6\n6! + \u00b7 \u00b7 \u00b7\n(5.4)",
    "solution": "1. The chain rule states that the partial derivative of E = E(x, y) with respect to x can be\ncalculated via another variable y = y(x), as follows:\n\u2202E\n\u2202x = \u2202E\n\u2202y \u00b7 \u2202y\n\u2202x\n(5.32)\n2. For instance, the chain rule [8] is applied in neural networks to calculate the change in\n149\n5.3. SOLUTIONS\nits weights resulting from tuning the cost function. This derivative is calculated via a\nchain of partial derivatives (e.g. of the activation functions).\n\u25a0\n5.3.5\nTaylor series expansion"
  },
  {
    "id": "PRB-105",
    "chapter": "",
    "question": "Find the Taylor series expansion for:\n1.\n1\n1 \u2212 x\n(5.5)\n128\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n2.\nex\n(5.6)\n3.\nsin(x)\n(5.7)\n4.\ncos(x)\n(5.8)",
    "solution": "1.\n1\n1 \u2212 x\n=\n\u221e\n\ufffd\nn=0\nxn = 1 + x + x2 + x3\n(when \u22121 < x < 1)\n(5.33)\n2.\nex\n=\n\u221e\n\ufffd\nn=0\nxn\nn! = 1 + x + x2\n2! + x3\n3! + \u00b7 \u00b7 \u00b7\n(5.34)\n3.\nsin x\n=\n\u221e\n\ufffd\nn=0\n(\u22121)n\n(2n + 1)!x2n+1\n= x \u2212 x3\n3! + x5\n5! \u2212 \u00b7 \u00b7 \u00b7\n(5.35)\n4.\ncos x\n=\n\u221e\n\ufffd\nn=0\n(\u22121)n\n(2n)! x2n\n= 1 \u2212 x2\n2! + x4\n4! \u2212 \u00b7 \u00b7 \u00b7\n(5.36)\n\u25a0"
  },
  {
    "id": "PRB-106",
    "chapter": "",
    "question": "Find the Taylor series expansion for:\nlog(x)\n(5.9)",
    "solution": "150\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nlog x =\n\u221e\n\ufffd\nn=1\n(\u22121)n+1 (x \u2212 1)n\nn\n= (x \u2212 1) \u2212 (x \u2212 1)2\n2\n+\n(x \u2212 1)3\n3\n\u2212 (x \u2212 1)4\n4\n+ \u00b7 \u00b7 \u00b7\n(5.37)\n\u25a0"
  },
  {
    "id": "PRB-107",
    "chapter": "",
    "question": "Find the Taylor series expansion centered at x = \u22123 for:\nf(x) = 5x2 \u2212 11x + 1\n(5.10)",
    "solution": "In this case, all derivatives can be computed:\nf 0(x) = 5x2 \u2212 11x + 1,\nf 0(\u22123) = 79,\nf 1(x) = 10x \u2212 11,\nf 1(\u22123) = \u221241,\nf 2(x) = 10,\nf 2(\u22123) = 10,\nf n(x)=0, \u2200n\u22653.\n(5.38)\n\u25a0"
  },
  {
    "id": "PRB-108",
    "chapter": "",
    "question": "Find the 101th degree Taylor polynomial centered at x = 0 for:\nf(x) = cos(x)\n(5.11)",
    "solution": "The immediate answer is 1. Refer to eq. 5.36 to verify this logical consequence.\n\u25a0"
  },
  {
    "id": "PRB-109",
    "chapter": "",
    "question": "At x = 1, compute the \ufb01rst 7 terms of the Taylor series expansion of:\nf(x) = ln 3x.\n(5.12)\n129\n5.2. PROBLEMS\n5.2.6\nLimits and continuity\nTheorem 1 (L\u2019Hopital\u2019s rule).\n[lim\nx\u2192a\nf(x)\ng(x) = lim\nx\u2192a\nf \u2032(x)\ng\u2032(x)].\n(5.13)",
    "solution": "By employing eq. 5.37, one can substitute x by 3 \u2212 x and generate the \ufb01rst 7 terms of the\nx-dependable outcome before assigning the point x = 1.\n\u25a0\n5.3.6\nLimits and continuity"
  },
  {
    "id": "PRB-110",
    "chapter": "",
    "question": "Find the following limits:\n1. lim\nx\u21923\nex3 \u2212 e27\n3x \u2212 9\n2. lim\nx\u21920\nex2 \u2212 x \u2212 1\n3 cos x \u2212 x \u2212 3\n3. lim\nx\u2192\u221e\nx \u2212 ln x\n100\u221ax + 4\n5.2.7\nPartial derivatives",
    "solution": "151\n5.3. SOLUTIONS\n1. With an indeterminate form 0/0, L\u2019Hopital\u2019s rule holds. We look at\nlim\nx\u21923\n3x2ex3\n3\n= 9e27,\nwhich equals to the original limit.\n2. Again, we yield 0/0 at interim, so we look at the \ufb01rst order derivative\nlim\nx\u21920\n2xex \u2212 1\n\u22123 sin x \u2212 1 = 1.\nThe original limit is also equal to 1.\n3. This time, the intermediate form is of \u221e/\u221e and L\u2019Hopital applies as well. The quotient\nof the derivatives is\n1 \u2212 1\nx\n0.01x\u221299/100 = 100(x \u2212 1)x1/99\nAs x \u2192 \u221e, this goes to \u221e, so the original limit is equal to \u221e also.\n\u25a0\n5.3.7\nPartial derivatives"
  },
  {
    "id": "PRB-111",
    "chapter": "",
    "question": "1. True or false: When applying a partial derivative, there are two variables considered\nconstants - the dependent and independent variable.\n2. Given g(x, y), \ufb01nd its partial derivative with respect to x:\ng(x, y) = x2y + yx + 8y.\n(5.14)",
    "solution": "1. True.\n2. By treating y as constant, one can derive that\n\u2202g\n\u2202x = 2xy + y.\n(5.39)\n\u25a0"
  },
  {
    "id": "PRB-112",
    "chapter": "",
    "question": "130\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nThe gradient of a two-dimensional function is given by\n\u2207f(x, y) = \u2202f\n\u2202xi + \u2202f\n\u2202y j\n(5.15)\n1. Find the gradient of the function:\nf(x, y) = xy2 \u2212 y2 + x3\n(5.16)\n2. Given the function:\ng(x, y) = x2y = xy2 \u2212 y \u2212 1,\n(5.17)\nevaluate it at (\u22121, 0), directed at (1, 1).",
    "solution": "152\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1.\n\u2207f(x, y) = \u2202f\n\u2202xi + \u2202f\n\u2202y j\n=\n\ufffd\ny2 + 3x2\ufffd\ni + (2xy \u2212 2y) j\n(5.40)\n2. It can be shown that \u2207g(x, y) = (2xy + y2) i + (x2 + 2xy \u2212 1) j at (\u22121, 0) equals\n(0, 0). According to the de\ufb01nition of directional derivative:\n(0, 0) \u00b7 (1, 1)\n|(1, 1)|\n= 0\n(5.41)\n\u25a0"
  },
  {
    "id": "PRB-113",
    "chapter": "",
    "question": "Find the partial derivatives of:\nf(x, y) = 3 sin2(x \u2212 y)\n(5.18)",
    "solution": "\u2202f\n\u2202x = 6 sin(x \u2212 y) cos(x \u2212 y)\n\u2202f\n\u2202y = \u22126 sin(x \u2212 y) cos(x \u2212 y)\n(5.42)\n\u25a0"
  },
  {
    "id": "PRB-114",
    "chapter": "",
    "question": "Find the partial derivatives of:\nz = 2 sin(x) sin(y)\n(5.19)\n5.2.8\nOptimization",
    "solution": "\u2202z\n\u2202x = 2 cos x sin y\n\u2202z\n\u2202y = 2 sin x cos y\n(5.43)\n\u25a0\n5.3.8\nOptimization"
  },
  {
    "id": "PRB-115",
    "chapter": "",
    "question": "Consider f(x) = x2 + 1\n(x + 2)2.\n1. Where is f(x) well de\ufb01ned?\n131\n5.2. PROBLEMS\n2. Where is f(x) increasing and decreasing?\n3. Where is f(x) reaching minimum and maximum values.",
    "solution": "153\n5.3. SOLUTIONS\n1. The function is only de\ufb01ned where x \u0338= \u22122, in the domain of:\n(\u2212\u221e, \u22122) \u222a (\u22122, +\u221e).\n2. By a simple quotient-based derivation:\nf \u2032(x) = 2(x + 2)(2x \u2212 1)\n(x + 2)4\n.\n(5.44)\nNamely, expect for the ill-de\ufb01ned x = \u22122, the critical point of x = 0.5 should be\nconsidered. For x > 0.5, the derivative is positive and the function increases, in contrast\nto x < 0.5.\n3. The requested coordinate is (0.5, 0.2).\n\u25a0"
  },
  {
    "id": "PRB-116",
    "chapter": "",
    "question": "Consider f(x) = 2x3 \u2212 x.\n1. Derive f(x) and conclude on its behavior.\n2. Derive once again and discuss the concavity of the function f(x).",
    "solution": "1. f \u2032(x) = 6x2 \u2212 1, which entails the behavior of the function changes around the points\nx = \u00b1 1\n\u221a\n6. The derivative is negative between x = \u2212 1\n\u221a\n6 and x =\n1\n\u221a\n6, i.e., it decreases\nin the domain, and increases otherwise.\n2. The second derivative is f \u2032\u2032(x) = 12x, which means the function is concave for negative\nx values and convex otherwise.\n\u25a0"
  },
  {
    "id": "PRB-117",
    "chapter": "",
    "question": "Consider the function\nf(x, y) = 2x2 \u2212 xy + y2,\nand \ufb01nd maximum, minimum, and saddle points.\n5.2.9\nThe Gradient descent algorithm",
    "solution": "The function should be derived according to each variable separately and be equated to 0,\nas follows:\nfx(x, y) = 4x \u2212 y = 0 ,\nfy(x, y) = \u2212y + 2y = 0 .\nSo, the solution to these equations yield the coordinate (0, 0), and f(0, 0) = 0.\nLet us derive the second order derivative, as follows:\n\u22022f\n\u2202x2 (x, y) = 4 , \u22022f\n\u2202y2 (x, y) = 2 ,\n\u22022f\n\u2202x\u2202y(x, y) = \u22121 ,\n154\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nAlso, the following relation exists:\nD(x, y) = \u22022f\n\u2202x2\n\u22022f\n\u2202y2 \u2212\n\ufffd \u22022f\n\u2202x\u2202y\n\ufffd2\n= 7 ,\nThus, the critical point (0, 0) is a minimum.\n\u25a0\n5.3.9\nThe Gradient descent algorithm"
  },
  {
    "id": "PRB-118",
    "chapter": "",
    "question": "The gradient descent algorithm can be utilized for the minimization of convex functions.\nStationary points are required in order to minimize a convex function. A very simple ap-\nproach for \ufb01nding stationary points is to start at an arbitrary point, and move along the\ngradient at that point towards the next point, and repeat until converging to a stationary\npoint.\n1. What is the term used to describe the vector of all partial derivatives for a function\nf(x)?\n2. Complete the sentence: when searching for a minima, if the derivative is positive, the\nfunction is increasing/decreasing.\n132\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n3. The function x2 as depicted in 5.5, has a derivative of f \u2032(x) = 2x. Evaluated at x =\n\u22121, the derivative equals f \u2032(x = \u22121) = \u22122. At x = \u22121, the function is decreasing\nas x gets larger. We will happen if we wish to \ufb01nd a minima using gradient descent,\nand increase (decrease) x by the size of the gradient, and then again repeatedly keep\njumping?\n4. How this phenomena can be alleviated?\n5. True or False: The gradient descent algorithm is guaranteed to \ufb01nd a local minimum\nif the learning rate is correctly decreased and a \ufb01nite local minimum exists.\n\u22124,0\n\u22123,0\n\u22122,0\n\u22121,0\n1,0\n2,0\n3,0\n4,0\n\u22121,0\n1,0\n2,0\n3,0\n4,0\nx = \u22121\nx\ny\nx2\nFIGURE 5.5: x2 Function",
    "solution": "1. It is the gradient of a function which is mathematically represented by:\n\u2207f(x, y) =\n\uf8eb\n\uf8ec\n\uf8ed\n\u2202f(x,y)\n\u2202x\n\u2202f(x,y)\n\u2202y\n\uf8f6\n\uf8f7\n\uf8f8\n(5.45)\n2. Increasing.\n3. We will keep jumping between the same two points without ever reaching a minima.\n4. This phenomena can be alleviated by using a learning rate or step size. For instance,\nx+ = 2 \u2217 \u03b7 where \u03b7 is a learning rate with small value such as \u03b7 = 0.25.\n5. True.\n\u25a0"
  },
  {
    "id": "PRB-119",
    "chapter": "",
    "question": "1. Is the data linearly separable?\nX1\nX2\nY\n1\n1\n+\n12\n12\n\u2212\n4\n5\n\u2212\n12\n12\n+\n(5.20)\n133\n5.2. PROBLEMS\n2. What is loss function for linear regression?\n3. What is the gradient descent algorithm to minimize a function f(x)?\n5.2.10\nThe Backpropagation algorithm\nThe most important, expensive and hard to implement part of any hardware realiz-\nation of ANNs is the non-linear activation function of a neuron. Commonly applied\nactivation functions are the sigmoid and the hyperbolic tangent. In the most used\nlearning algorithm in present day applications, back-propagation, the derivatives of\nthe sigmoid function are needed when back propagating the errors.\nThe backpropagation algorithm looks for the minimum of the error function in\nweight space using the method of gradient descent.",
    "solution": "1. The point (12,12) has two classes, so the classes cannot be separated by any line.\n2.\nJ(\u03b8) =\n1\n2m\nm\n\ufffd\ni=1\n(\u02c6yi \u2212 yi)2\n(5.46)\n155\n5.3. SOLUTIONS\n3. Simple but fundamental algorithm for minimizing f. Just repeatedly move in the direc-\ntion of the negative gradient\n(a) Start with initial guess \u03b8(0), step size \u03b7\n(b) For k = 1, 2, 3, . . .:\ni. Compute the gradient \u2207f(\u03b8(k\u22121))\nii. Check if gradient is close to zero; is so stop, otherwise continue\niii. Update \u03b8(k) = \u03b8(k\u22121) \u2212 \u03b7\u2207f(\u03b8(k\u22121))\n(c) Return \ufb01nal \u03b8(k) as approximate solution \u03b8\u2217\n\u25a0\n5.3.10\nThe Backpropagation algorithm"
  },
  {
    "id": "PRB-120",
    "chapter": "",
    "question": "1. During the training of an ANN, a sigmoid layer applies the sigmoid function to every\nelement in the forward pass, while in the backward pass the chain rule is being util-\nized as part of the backpropagation algorithm. With respect to the backpropagation\nalgorithm, given a sigmoid \u03c3(x) =\nex\n1+ex activation function, and a J as the cost func-\ntion, annotate each part of equation (5.21):\ndZ =\ndJ\nd\u03c3(x)\nd\u03c3(x)\ndx\n= dA \u00b7 \u03c3(x) \u00b7\n\ufffd\n1 \u2212 \u03c3(x)\n\ufffd\n(5.21)\n2. Code snippet 5.6 provides a pure Python-based (e.g. not using Autograd) implement-\nation of the forward pass for the sigmoid function. Complete the backward pass that\ndirectly computes the analytical gradients.\n134\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 class Sigmoid:\n2\ndef forward(self,x):\n3\nself.x = x\n4\nreturn 1/(1+np.exp(-x))\n5\ndef backward(self, grad):\n6\ngrad_input = [???]\n7\nreturn grad_input\nFIGURE 5.6: Forward pass for the sigmoid function.",
    "solution": "1. The annotated parts of equation (5.21) appear in (5.47):\n\u03c3(x) =\nex\n1 + ex = The Sigmoid activation function\n\u03c3(x) \u00b7\n\ufffd\n1 \u2212 \u03c3(x)\n\ufffd\nThe deriviative of the Sigmoid activation function =\n1Z = The input\ndZ = The error introduced by input Z.\nA = The output\ndA = The error introduced by output A.\n(5.47)\n2. Code snippet 5.13 provides an implementation of both the forward and backward passes\nfor the sigmoid function.\n156\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 class Sigmoid:\n2\ndef forward(self,x):\n3\nself.x = x\n4\nreturn 1/(1+np.exp(-x))\n5\n6\ndef backward(self, grad):\n7\ngrad_input = self.x*(1-self.x) * grad\n8\nreturn grad_input\nFIGURE 5.13: Forward and backward passes for the sigmoid activation function in pure\nPython.\n\u25a0"
  },
  {
    "id": "PRB-121",
    "chapter": "",
    "question": "This question deals with the effect of customized transfer functions. Consider a neural\nnetwork with hidden units that use x3 and output units that use sin(2x) as transfer func-\ntions. Using the chain rule, starting from \u2202E/\u2202yk, derive the formulas for the weight updates\n\u2206wjk and \u2206wij. Notice - do not include partial derivatives in your \ufb01nal answer.\n5.2.11\nFeed forward neural networks\nUnderstanding the inner-workings of Feed Forward Neural Networks (FFNN) is\ncrucial to the understanding of other, more advanced Neural Networks such as CNN\u2019s.\nA Neural Network (NN) is an interconnected assembly of simple processing\nelements, units or nodes, whose functionality is loosely based on the animal\nneuron. The processing ability of the network is stored in the inter-unit\nconnection strengths, or weights, obtained by a process of adaptation to, or\nlearning from, a set of training patterns. [6]\nThe Backpropagation Algorithm is the most widely used learning algorithm for\nFFNN. Backpropagation is a training method that uses the Generalized Delta Rule. Its\nbasic idea is to perform a gradient descent on the total squared error of the network\noutput, considered as a function of the weights. It was \ufb01rst described by Werbos and\nmade popular by Rumelhart\u2019s, Hinton\u2019s and Williams\u2019 paper [12].\n135\n5.2. PROBLEMS\n5.2.12\nActivation functions, Autograd/JAX\nActivation functions, and most commonly the sigmoid activation function, are\nheavily used for the construction of NNs. We utilize Autograd ([10]) and the recently\npublished JAX ([1]) library to learn about the relationship between activation func-\ntions and the Backpropagation algorithm.\nUsing a logistic, or sigmoid, activation function has some bene\ufb01ts in being able\nto easily take derivatives and then interpret them using a logistic regression model.\nAutograd is a core module in PyTorch ([11]) and adds inherit support for automatic\ndifferentiation for all operations on tensors and functions. Moreover, one can imple-\nment his own custom Autograd function by sub classing the autograd Function and\nimplementing the forward and backward passes which operate on PyTorch tensors.\nPyTorch provides a simple syntax (5.7) which is transparent to both CPU/GPU sup-\nport.\nimport torch\nfrom torch.autograd import Function\nclass DLFunction(Function):\n@staticmethod\ndef forward(ctx, input):\n...\n@staticmethod\ndef backward(ctx, grad_output):\n...\nFIGURE 5.7: PyTorch syntax for autograd.",
    "solution": "The key concept in this question is merely understanding that the transfer function and\nits derivatives are changing compared to traditional activation functions, namely:\n\u2202E\n\u2202yk\n= (yk \u2212 dk)\n(5.48)\n\u2202E\n\u2202netk\n= \u2202E\n\u2202yk\n\u00b7 \u2202yk\n\u2202netk\n= (yk \u2212 dk) \u00b7 2 cos(2netk)\n(5.49)\n\u2206wjk = \u2212\u03b7 \u2202E\n\u2202wjk\n= \u2212\u03b7 \u2202E\n\u2202netk\n\u00b7 \u2202netk\n\u2202wjk\n= \u2212\u03b7 \u00b7 (yk \u2212 dk) \u00b7 2 cos(2netk) \u00b7 yj\n(5.50)\n\u2202E\n\u2202yj\n=\n\ufffd\nk\n\ufffd \u2202E\n\u2202netk\n\u00b7 \u2202netk\n\u2202yj\n\ufffd\n=\n\ufffd\nk\n\ufffd \u2202E\n\u2202netk\nwjk\n\ufffd\n(5.51)\n\u2202E\n\u2202netj\n= \u2202E\n\u2202yj\n\u00b7 \u2202yj\n\u2202netj\n= \u2202E\n\u2202yj\n\u00b7 3net2\nj\n(5.52)\n157\n5.3. SOLUTIONS\n\u2206wij\n=\n\u2212\u03b7 \u2202E\n\u2202wij\n=\n\u2212\u03b7 \u2202E\n\u2202netj \u00b7 \u2202netj\n\u2202wij\n=\n\u2212\u03b7 \u00b7 (\ufffd\nk [(yk \u2212 dk) \u00b7 2 cos(2netk) \u00b7 wjk]) \u00b7 3net2\nj \u00b7 yi\n(5.53)\n\u25a0\n5.3.11\nFeed forward neural networks\n5.3.12\nActivation functions, Autograd/JAX"
  },
  {
    "id": "PRB-122",
    "chapter": "",
    "question": "1. True or false: In Autograd, if any input tensor of an operation has requires_grad=True,\nthe computation will be tracked. After computing the backward pass, a gradient w.r.t.\nthis tensor is accumulated into .grad attribute\n136\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n2. True or false: In Autograd, multiple calls to backward will sum up previously com-\nputed gradients if they are not zeroed.",
    "solution": "1. True.\n2. True.\n\u25a0"
  },
  {
    "id": "PRB-123",
    "chapter": "",
    "question": "Your friend, a veteran of the DL community wants to use logistic regression and im-\nplement custom activation functions using Autograd. Logistic regression is used when the\nvariable y that we want to predict can only take on discrete values (i.e. classi\ufb01cation). Con-\nsidering a binary classi\ufb01cation problem (y = 0 or y = 1) (5.8), the hypothesis function could\nbe de\ufb01ned so that it is bounded between [0, 1] in which we use some form of logistic function,\nsuch as the sigmoid function. Other, more ef\ufb01cient functions exist such as the ReLU (Rec-\nti\ufb01ed Linear Unit) which we discussed later. Note: The weights in (5.8) are only meant for\nillustration purposes and are not part of the solution.\nxn\nx2\nx1\n1\n\ufffd\nwn\nw2\nw1\nw0\n0\n1\n0\n1\nSummation\nActivation\nyk = f (netk)\ninputs weights\nFIGURE 5.8: A typical binary classi\ufb01cation problem.\n1. Given the sigmoid function: g(x) =\n1\n1+e\u2212z what is the expression for the corresponding\nhypothesis in logistic regression?\n2. What is the decision boundary?\n3. What does h\u0398(x) = 0.8 mean?\n4. Using an Autograd based Python program, implement both the forward and backward\npass for the sigmoid activation function and evaluate it\u2019s derivative at x = 1\n137\n5.2. PROBLEMS\n5. Using an Autograd based Python program, implement both the forward and backward\npass for the ReLU activation function and evaluate it\u2019s derivative at x = 1",
    "solution": "The answers are as follows:\n1. h\u0398(x) = g(\u0398Tx) =\n1\n1+e\u2212\u0398\nT\nx.\n2. The decision boundary for the logistic sigmoid function is where h\u0398(x) = 0.5 (values\nless than 0.5 mean false, values equal to or more than 0.5 mean true).\n3. That there is a 80% chance that the instance is of the corresponding class, therefore:\n\u2022 h\u0398(x) = g(\u03980 + \u03981x1 + \u03982x2). We can predict y = 1 if x0 + x1 + x2 \u2265 0.\n4. The code snippet in 5.14 implements the function using Autograd.\n158\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 from torch.autograd import Function\n2 class Sigmoid(Function):\n3\n@staticmethod\n4\ndef forward(ctx, x):\n5\noutput = 1 / (1 + torch.exp(-x))\n6\nctx.save_for_backward(output)\n7\nreturn output\n8\n9\n@staticmethod\n10\ndef backward(ctx, grad_output):\n11\noutput,\n= ctx.saved_tensors\n12\ngrad_x = output * (1 - output) * grad_output\n13\nreturn grad_x\nFIGURE 5.14: Forward and backward for the sigmoid function in Autograd.\n5. The code snippet in 5.15 implements the function using Autograd.\n159\n5.3. SOLUTIONS\n1 from torch.autograd import Function\n2 class ReLU(torch.autograd.Function):\n3\n@staticmethod\n4\ndef forward(ctx, input):\n5\nctx.save_for_backward(input)\n6\nreturn input.clamp(min=0)\n7\n8\n@staticmethod\n9\ndef backward(ctx, grad_output):\n10\ninput, = ctx.saved_tensors\n11\ngrad_input = grad_output.clone()\n12\ngrad_input[input < 0] = 0\n13\nreturn grad_input\nFIGURE 5.15: Forward and backward for the ReLU function in Autograd.\n\u25a0"
  },
  {
    "id": "PRB-124",
    "chapter": "",
    "question": "For real values, \u22121 < x < 1 the hyperbolic tangent function is de\ufb01ned as:\ntanh\u22121 x = 1\n2[ln(1 + x) \u2212 ln(1 \u2212 x)]\n(5.22)\nOn the other hand, the artanh function, which returns the inverse hyperbolic tangent of\nits argument x, is implemented in numpy as arctanh().\nIts derivative is given by:\n(arctanh(x))\u2032 =\n1\n1 \u2212 x2\n(5.23)\nYour friend, a veteran of the DL community wants to implement a custom activation\nfunction for the arctanh function using Autograd. Help him in realize the method.\n1. Use this numpy array as an input [[0.37, 0.192, 0.571]] and evaluate the result using\npure Python.\n2. Use the PyTorch based torch.autograd.Function class to implement a custom Func-\ntion that implements the forward pass for the arctanh function in Python.\n3. Use the PyTorch based torch.autograd.Function class to implement a custom Func-\ntion that implements the backward pass for the arctanh function in Python.\n4. Name the class ArtanhFunction, and using the gradcheck method from torch.autograd,\nverify that your numerical values equate the analytical values calculated by gradcheck.\nRemember you must implement a method entitled .apply(x) so that the function can\nbe invoked by Autograd.\n5.2.13\nDual numbers in AD\nDual numbers (DN) are analogous to complex numbers and augment real numbers\n138\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nwith a dual element by adjoining an in\ufb01nitesimal element d, for which d2 = 0.",
    "solution": "The answers are as follows:\n1. Code snippet 5.16 implements the forward pass using pure Python.\n160\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 import numpy as np\n2 xT = torch.abs(torch.tensor([[0.37,0.192,0.571]],\n3 requires_grad=True)).type(torch.DoubleTensor)\n4 xT_np=xT.detach().cpu().numpy()\n5 print (\"Input: \\n\",xT_np)\n6 arctanh_values = np.arctanh(xT_np)\n7 print (\"Numpy:\", arctanh_values)\n8 > Numpy: [[0.38842311 0.1944129\n0.64900533]]\nFIGURE 5.16: Forward pass for equation (5.23) using pure Python.\n2. Code snippet 5.17 implements the forward pass using Autograd.\n1 import torch\n2 from torch.autograd import Function\n3 class ArtanhFunction(Function):\n4\n@staticmethod\n5\ndef forward(ctx, x):\n6\nctx.save_for_backward(x)\n7\nr = (torch.log_(1 + x).sub_(torch.log_(1 - x))).mul_(0.5)\n8\nreturn r\nFIGURE 5.17: Forward pass for equation (5.23).\n3. Code snippet 5.18 implements the backward pass using Autograd.\n161\n5.3. SOLUTIONS\n1 from torch.autograd import Function\n2 class ArtanhFunction(Function):\n3 @staticmethod\n4\ninput, = ctx.saved_tensors\n5\nout= grad_output / (1 - input ** 2)\n6\nprint (\"backward:{}\".format(out))\n7\nreturn out\nFIGURE 5.18: Backward pass for equation (5.23).\n4. Code snippet 5.19 veri\ufb01es the correctness of the implementation using gradcheck.\n1 import numpy as np\n2\n3 xT =\ntorch.abs(torch.tensor([[0.11,0.19,0.57]],requires_grad=True))\n\ufffd\u2192\n4 .type(torch.DoubleTensor)\n5 arctanh_values_torch = arctanhPyTorch(xT)\n6 print (\"Torch:\", arctanh_values_torch)\n7 from torch.autograd import gradcheck, Variable\n8 f = ArtanhFunction.apply\n9 test=gradcheck(lambda t: f(t), xT)\n10 print(test)\n11\n12 > PyTorch version: 1.7.0\n13 > Torch: tensor([[0.3884, 0.1944, 0.6490]], dtype=torch.float64,\n14 >\ngrad_fn=<ArtanhFunctionBackward>)\n15 > backward:tensor([[1.1586, 1.0383,1.4838]], dtype=torch.float64,\n16\ngrad_fn=<CopyBackwards>)\nFIGURE 5.19: Invoking arctanh using gradcheck\n162\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n\u25a0\n5.3.13\nDual numbers in AD"
  },
  {
    "id": "PRB-125",
    "chapter": "",
    "question": "1. Explain how AD uses \ufb02oating point numerical rather than symbolic expressions.\n2. Explain the notion of DN as introduced by ([2]).\n3. What arithmetic operations are possible on DN?.\n4. Explain the relationship between a Taylor series and DN.",
    "solution": "The answers are as follows:\n1. The procedure of AD is to use verbatim text of a computer program which calculates\na numerical value and to transform it into the text of a computer program called the\ntransformed program which calculates the desired derivative values. The transformed\ncomputer program carries out these derivative calculations by repeated use of the chain\nrule however applied to actual \ufb02oating point values rather than to a symbolic rep-\nresentation.\n2. Dual numbers extend all numbers by adding a second component x \ufffd\u2192 x + \u02d9xd where\nx + \u02d9x is the dual part.\n3. The following arithmetic operations are possible on DN:\n(a) d2 = 0\n(b) (x + \u02d9xd) + (y + \u02d9yd) = x + y + ( \u02d9x + \u02d9y)d\n(c) \u2212(x + \u02d9xd) = \u2212x \u2212 \u02d9xd\n(d)\n1\nx+ \u02d9xd = 1\nx \u2212\n\u02d9x\nx2d\n4. For f(x + \u02d9xd) the Taylor series expansion is:\nf(x + \u02d9xd) = f(x) + f \u2032(x)\n1!\n\u02d9xd + . . . 0\n(5.54)\nThe immediate and important result is that all higher-order terms (n >= 2) disappear\nwhich provides closed-form mathematical expression that represents a function and its\nderivative.\n\u25a0"
  },
  {
    "id": "PRB-126",
    "chapter": "",
    "question": "1. Expand the following function using DN:\nsin(x + \u02d9xd)\n(5.24)\n2. With respect to the expression graph depicted in 5.9:\nx\n3\n*\n+\n2\ng(x)\nFIGURE 5.9: An expression graph for g(x). Constants are shown in gray, crossed-out since\nderivatives should not be propagated to constant operands.\n(a) Traverse the graph 5.9 and \ufb01nd the function g(x) it represents.\n(b) Expand the function g(x) using DN.\n3. Show that the general identity :\ng(x + \u02d9xd) = g(x) + g\u2032(x) \u02d9xd\n(5.25)\n139\n5.2. PROBLEMS\nholds in this particular case too.\n4. Using the derived DN, evaluate the function g(x) at x = 2.\n5. Using an Autograd based Python program implement the function and evaluate it\u2019s\nderivative at x = 2.",
    "solution": "163\n5.3. SOLUTIONS\nThe answers are as follows:\n1.\nsin(x + \u02d9xd) = sin(x) + cos(x) \u02d9xd\n(5.55)\n2. If we traverse the graph 5.9 from left to right we drive the following simple function:\ng(x) = 3 \u2217 x + 2\n(5.56)\n3. We know that:\ng(x) = 3 \u2217 x + 2\n(5.57)\ng\u2032(x) = 3\n(5.58)\nNow if we expand the function using DN:\ng(x + \u02d9xd) = 3 \u2217 (x + \u02d9xd) + 2 =\n(5.59)\n3 \u2217 x + 3 \u2217 ( \u02d9xd) + 2\n(5.60)\nRearranging:\n3 \u2217 x + 2 + 3 \u2217 ( \u02d9xd)\n(5.61)\nBut since g(x) = 3 \u2217 x + 2 then:\ng(x + \u02d9xd) = g(x) + g\u2032(x) \u02d9xd\n(5.62)\n4. Evaluating the function g(x) at x = 2 using DN we get:\ng(x = 2) = (3 \u2217 2 + 2) + (3) \u02d9xd =\n(5.63)\n8 + (3) \u02d9xd\n(5.64)\n5. The code snippet in 5.20 implements the function using Autograd.\n164\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 import autograd.numpy as np\n2 from autograd import grad\n3 x = np.array([2.0], dtype=float)\n4 def f1(x):\n5\nreturn 3*x + 2\n6 grad_f1 = grad(f1)\n7 print(f1(x)) # > 8.0\n8 print(grad_f1(x)) # > 3.0\nFIGURE 5.20: Autograd\n\u25a0"
  },
  {
    "id": "PRB-127",
    "chapter": "",
    "question": "With respect to the expression graph depicted in 5.10:\nx\n**2\n5\n*\n*\n+\n1\n4\ng(x)\nFIGURE 5.10: An expression graph for g(x). Constants are shown in gray, crossed-out\nsince derivatives should not be propagated to constant operands.\n1. Traverse the graph 5.10 and \ufb01nd the function g(x) it represents.\n2. Expand the function g(x) using DN.\n3. Using the derived DN, evaluate the function g(x) at x = 5.\n4. Using an AutoGrad based Python program implement the function and evaluate it\u2019s\nderivative at x = 5.\n5.2.14\nForward mode AD",
    "solution": "The answers are as follows:\n1. If we traverse the graph 5.9 from left to right we drive the following function:\ng(x) = 5 \u2217 x2 + 4 \u2217 x + 1\n(5.65)\n2. We know that:\ng(x1) = 5 \u2217 x2 + 4 \u2217 x + 1\n(5.66)\ng\u2032(x1) = 10 \u2217 x1 + 4\n(5.67)\nNow if we expand the function using DN we get:\ng(x + \u02d9xd) = 5 \u2217 (x + \u02d9xd)2 + 4 \u2217 (x + \u02d9xd) + 1 =\n(5.68)\n5 \u2217 (x2 + 2 \u2217 x + \u02d9xd + ( \u02d9xd)2) + 4 \u2217 x + 4 \u2217 ( \u02d9xd) + 1\n(5.69)\n165\n5.3. SOLUTIONS\nHowever by de\ufb01nition (d2) = 0 and therefore that term vanishes. Rearranging the\nterms:\n(5 \u2217 x2 + 4 \u2217 x + 1) + (10 \u2217 x + 4) \u02d9xd\n(5.70)\nBut since g(x) = (5 \u2217 x2 + 4 \u2217 x + 1) then:\ng(x + \u02d9xd) = g(x) + g\u2032(x) \u02d9xd\n(5.71)\n3. Evaluating the function g(x) at x = 5 using DN we get:\ng(x = 4) = (5 \u2217 52 + 4 \u2217 5 + 1) + (10 \u2217 5 + 4) \u02d9xd =\n146 + (54) \u02d9xd\n(5.72)\n4. The code snippet in 5.21 implements the function using Autograd.\n1 import autograd.numpy as np\n2 from autograd import grad\n3 x = np.array([5.0], dtype=float)\n4 def f1(x):\n5\nreturn 5*x**2 + 4*x +1\n6 grad_f1 = grad(f1)\n7 print(f1(x)) # > 146.0\n8 print(grad_f1(x)) # > 54.0\nFIGURE 5.21: Autograd\n\u25a0\n5.3.14\nForward mode AD"
  },
  {
    "id": "PRB-128",
    "chapter": "",
    "question": "140\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nWhen differentiating a function using forward-mode AD, the computation of such an\nexpression can be computed from its corresponding directed a-cyclical graph by propagating\nthe numerical values.\n1. Find the function, g(A, B, C) represented by the expression graph in 5.11.\nA\nB\nC\nln\n+\n*\ng (A, B, C))\nFIGURE 5.11: A computation graph for g(x)\n2. Find the partial derivatives for the function g(x).",
    "solution": "The answers are as follows:\n166\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1. The function g(x) represented by the expression graph in 5.11 is:\ng(x) = A + B \u2217 ln(C)\n(5.73)\n2. For a logarithmic function:\nd\ndx ln(x) = 1\nx\n(5.74)\nTherefore, the partial derivatives for the function g(x) are:\n\u2202f\n\u2202A = 1\n\u2202f\n\u2202B = ln(C)\n\u2202f\n\u2202C = B \u2217 1\nC\n(5.75)\n\u25a0"
  },
  {
    "id": "PRB-129",
    "chapter": "",
    "question": "Answer the following given that a computational graph of a function has N inputs and\nM outputs.\n1. True or False?:\n(a) Forward and reverse mode AD always yield the same result.\n(b) In reverse mode AD there are fewer operations (time) and less space for interme-\ndiates (memory).\n(c) The cost for forward mode grows with N.\n(d) The cost for reverse mode grows with M.",
    "solution": "The answers are as follows:\n1. True. Both directions yield the exact same results.\n2. True. Reverse mode is more ef\ufb01cient than forward mode AD (why?).\n3. True.\n4. True.\n\u25a0"
  },
  {
    "id": "PRB-130",
    "chapter": "",
    "question": "141\n5.2. PROBLEMS\n1. Transform the source code in code snippet 5.1 into a function g(x1, x2).\nCODE 5.1: A function, g(x1, x2) in the C programming language.\n1 float g( float x1 , float x2) {\n2\nfloat v1, v2, v3 , v4 , v5;\n3\nv1=x1;\n4\nv2=x2;\n5\nv3 = v1 * v2;\n6\nv4 = ln (v1 );\n7\nv5 = v3 + v4;\n8\nreturn v5;\n9 }\n2. Transform the function g(x1, x2) into an expression graph.\n3. Find the partial derivatives for the function g(x1, x2).\n5.2.15\nForward mode AD table construction",
    "solution": "The answers are as follows:\n167\n5.3. SOLUTIONS\n1. The function is\nf (x1, x2) = x1x2 + ln (x1)\n(5.76)\n2. The graph associated with the forward mode AD is as follows:\nx1\nx2\n*\n+\nln\nf(x1, x2)\nFIGURE 5.22: A Computation graph for g(x1, x2) in 5.1\n3.\nThe partial derivatives are:\n\u2202f\n\u2202x1\n= x2 \u2212\n1\n(x1)\n\u2202f\n\u2202x2\n= x1\n(5.77)\n\u25a0\n5.3.15\nForward mode AD table construction"
  },
  {
    "id": "PRB-131",
    "chapter": "",
    "question": "1. Given the function:\nf (x1, x2) = x1x2 + ln (x1)\n(5.26)\nand the graph 5.1, annotate each vertex (edge) of the graph with the partial derivatives\nthat would be propagated in forward mode AD.\n2. Transform the graph into a table that computes the function:\ng(x1, x2) evaluated at (x1; x2) = (e2; \u03c0) using forward-mode AD.\n3. Write and run a Python code snippet to prove your results are correct.\n4. Describe the role of seed values in forward-mode AD.\n142\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n5. Transform the graph into a table that computes the derivative of g(x1, x2) evalu-\nated at (x1; x2) = (e2; \u03c0) using forward-mode AD for x1 as the chosen independent\nvariable.\n6. Write and run a Python code snippet to prove your results are correct.\n5.2.16\nSymbolic differentiation\nIn this section, we introduce the basic functionality of the SymPy (SYMbolic Python)\nlibrary commonly used for symbolic mathematics as a means to deepen your under-\nstanding in both Python and calculus. If you are using Sympy in a Jupyter notebook\nin Google Colab (e.g. https://colab.research.google.com/) then rendering\nsympy equations requires MathJax to be available within each cell output. The follow-\ning is a hook function that will make this possible:\nCODE 5.2: Sympy in Google Colab\n1 from IPython.display import Math, HTML\n2 def enable_sympy_in_cell():\n3 display(HTML(\"<script\nsrc='https://cdnjs.cloudflare.com/ajax/libs/\"\n\ufffd\u2192\n4 \"mathjax/2.7.3/latest.js?config=default'>\n5 </script>\"))\n6 get_ipython().events.register('pre_run_cell',\nenable_sympy_in_cell)\n\ufffd\u2192\nAfter successfully registering this hook, SymPy rendering (5.3) will work correctly:\nCODE 5.3: Rendering Sympy in Google Colab\n1 import sympy\n2 from sympy import *\n3 init_printing()\n4 x, y, z = symbols('x y z')\n5 Integral(sqrt(1/x), (x, 0, oo))\n143\n5.2. PROBLEMS\nIt is also recommended to use the latest version of Sympy:\nCODE 5.4: Updating Sympy\n> pip install --upgrade sympy\n5.2.17\nSimple differentiation",
    "solution": "The answers are as follows:\n1. The graph with the intermediate values is depicted in (5.23)\n168\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nx1\nx2\n*\n+\nln\ng(x1, x2)\nv1\nv2\nv1\nv4\nv3\nv5\nFIGURE 5.23: A derivative graph for g(x1, x2) in 5.1\n2. Forward mode AD for g (x1, x2) = ln (x1) + x1x2 evaluated at (x1, x2) = (e2, \u03c0).\nForward-mode function evaluation\nv\u22121 = x1\n= e2\nv0\n= x2\n= \u03c0\nv1\n= ln v\u22121\n= ln (e2) = 2\nv2\n= v\u22121 \u00d7v0\n= e2 \u00d7 \u03c0 = 23.2134\nv3\n= v1 + v2\n2 + 23.2134 = 25.2134\nf\n= v3\n=\u2248 25.2134\nTABLE 5.1: Forward-mode AD table for y = g(x1, x2) = ln(x1)+x1x2 evaluated at (x1, x2) =\n(e2; \u03c0) and setting \u02d9x1 = 1 to compute \u2202y\n\u2202x1 .\n3. The following Python code (5.24) proves that the numerical results are correct:\n169\n5.3. SOLUTIONS\n1 import math\n2 print (math.log(math.e*math.e) + math.e*math.e*math.pi)\n3 > 25.2134^^I\nFIGURE 5.24: Python code- AD of the function g(x1, x2)\n4. Seed values indicate the values by which the dependent and independent variables are\ninitialized to before being propagated in a computation graph. For instance:\n\u02d9v1 = \u2202x1\n\u2202x1 = 1\n\u02d9v2 = \u2202x2\n\u2202x1 = 0\nTherefore we set \u02d9x1 = 1 to compute \u2202y\n\u2202x1.\n5. Here we construct a table for the forward-mode AD for the derivative of f (x1, x2) =\nln (x1) + x1x2 evaluated at (x1, x2) = (e2, \u03c0) while setting \u02d9x1 = 1 to compute \u2202y\n\u2202x1.. In\nforward-mode AD a derivative is called a tangent.\nIn the derivation that follows, note that mathematically using manual differentiation:\nd\ndx1 [ln(x) + x2x]\n=\nd\ndx1[ln(x1)] + x2 \u00b7\nd\ndx1[x1]\n=\n1\nx1 + x2 \u00b7 1\n=\n1\nx1 + x2\nand also since\nd\ndx ln(x) = 1\nx then \u02d9v1 =\n1\nv\u22121 \u2217 \u02d9v\u22121 = \u02d9v\u22121/v\u22121 =\n1\ne2 \u2217 1 = 1/e2.\n170\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nForward-mode AD derivative evaluation\nv\u22121 = x1 = e2\nv0\n= x2 = \u03c0\n\u02d9v\u22121 = \u02d9x1 = 1\n\u02d9v0\n= \u02d9x2 = 0\n\u02d9v1\n= \u02d9v\u22121/v\u22121 = 1/e2\n\u02d9v2\n= \u02d9v\u22121 \u00d7 v0 + \u02d9v0 \u00d7\nv\u22121 = 1 \u00d7 \u03c0 + 0 \u00d7\ne2 = \u03c0\n\u02d9v4\n= \u02d9v1 + \u02d9v2 = 1/e2 +\n\u03c0\n\u02d9f\n= \u02d9v4 = 1/e2 +\n\u03c0 =\u2248 3.2769\nTABLE 5.3: Forward-mode AD table for y = g(x1, x2) = ln(x1)+x1x2 evaluated at (x1, x2) =\n(e2; \u03c0) and setting \u02d9x1 = 1 (seed values are mentioned here: 3) to compute \u2202y\n\u2202x1 .\n6. The following Python code (5.25) proves that the numerical results are correct:\n171\n5.3. SOLUTIONS\n1 import autograd.numpy as np\n2 from autograd import grad\n3 import math\n4\n5 x1 = math.e* math.e\n6 x2 = math.pi\n7\n8 def f1(x1,x2):\n9 return (np.log(x1) + x1*x2)\n10\n11 grad_f1 = grad(f1)\n12\n13 print(f1(x1,x2)) # > 25.2134\n14 print(grad_f1(x1,x2)) # > 3.2769\nFIGURE 5.25: Python code- AD of the function g(x1, x2)\n\u25a0\n5.3.16\nSymbolic differentiation\n5.3.17\nSimple differentiation"
  },
  {
    "id": "PRB-132",
    "chapter": "",
    "question": "Answer the following questions:\n1. Which differentiation method is inherently prone to rounding errors?\n2. De\ufb01ne the term symbolic differentiation.",
    "solution": "The answers are as follows:\n1. Approximate methods such as numerical differentiation suffer from numerical instabil-\nity and truncation errors.\n2. In symbolic differentiation, a symbolic expression for the derivative of a function is\ncalculated. This approach is quite slow and requires symbols parsing and manipulation.\nFor example, the number\n\u221a\n2 is represented in SymPy as the object Pow(2,1/2). Since\nSymPy employees exact representations Pow(2,1/2)*Pow(2,1/2) will always equal 2.\n\u25a0\n172\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION"
  },
  {
    "id": "PRB-133",
    "chapter": "",
    "question": "Answer the following questions:\n1. Implement the sigmoid function \u03c3(x) =\n1\n1+e\u2212x symbolically using a Python based\nSymPy program.\n2. Differentiate the sigmoid function using SymPy and compare it with the analytical\nderivation \u03c3\u2032(x) = \u03c3(x)(1 \u2212 \u03c3(x)).\n3. Using SymPy, evaluate the gradient of the sigmoid function at x = 0.\n4. Using SymPy, plot the resulting gradient of the sigmoid function.\n5.2.18\nThe Beta-Binomial model",
    "solution": "1. First:\n1 import sympy\n2 sympy.init_printing()\n3 from sympy import Symbol\n4 from sympy import diff, exp, sin, sqrt\n5 y = Symbol('y')\n6 y = sympy.Symbol(\"y\")\n7 sigmoid = 1/(1+sympy.exp(-y))^^I\nFIGURE 5.26: Sigmoid in SymPy\n2. Second:\n1 sig_der=sym.diff(sigmoid, y)\nFIGURE 5.27: Sigmoid gradient in SymPy\n3. Third:\n1 sig_der.evalf(subs={y:0})\n2 > 0.25\nFIGURE 5.28: Sigmoid gradient in SymPy\n173\n5.3. SOLUTIONS\n4. The plot is depicted in 5.29.\n1 p = sym.plot(sig_der);\n10.0\n7.5\n5.0\n2.5\n0.0\n2.5\n5.0\n7.5\n10.0\ny\n0.00\n0.05\n0.10\n0.15\n0.20\n0.25\nf(y)\nFIGURE 5.29: SymPy gradient of the Sigmoid() function\n\u25a0\n5.3.18\nThe Beta-Binomial model"
  },
  {
    "id": "PRB-134",
    "chapter": "",
    "question": "144\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\nYou will most likely not be given such a long programming task during a face-to-face\ninterview. Nevertheless, an extensive home programming assignment is typically given at\nmany of the start-ups I am familiar with. You should allocate around approximately four to\nsix hours to completely answer all questions in this problem.\nWe discussed the Beta-Binomial model extensively in chapter 3. Recall that the Beta-\nBinomial distribution is frequently used in Bayesian statistics to model the number of suc-\ncesses in n trials. We now employ SymPy to do the same; demonstrate computationally how\na prior distribution is updated to develop into a posterior distribution after observing the\ndata via the relationship of the Beta-Binomial distribution.\nProvided the probability of success, the number of successes after n trials follows a bino-\nmial distribution. Note that the beta distribution is a conjugate prior for the parameter of\nthe binomial distribution. In this case, the likelihood function is binomial, and a beta prior\ndistribution yields a beta posterior distribution.\nRecall that for the Beta-Binomial distribution the following relationships exist:\nPrior of \u03b8\nBeta(a,b)\nLikelihood\nbinomial (n, \u03b8)\nPosterior of \u03b8\nBeta (a + x, b + n \u2212 x)\nPosterior Mean\n(a + x)/(a + b + n \u2212 x)\n(5.27)\n1. Likelihood: The starting point for our inference problem is the Likelihood, the prob-\nability of the observed data. Find the Likelihood function symbolically using sympy.\nConvert the SymPy representation to a purely Numpy based callable function with a\nLambda expression. Evaluate the Likelihood function at \u03b8 = 0.5 with 50 successful\ntrials out of 100.\n2. Prior: The Beta Distribution. De\ufb01ne the Beta distribution which will act as our prior\ndistribution symbolically using sympy. Convert the SymPy representation to a purely\nNumpy based callable function. Evaluate the Beta Distribution at \u03b8 : 0.5, a : 2, b : 7\n3. Plot the Beta distribution, using the Numpy based function.\n4. Posterior: Find the posterior distribution by multiplying our Beta prior by the Bi-\nnomial Likelihood symbolically using sympy. Convert the SymPy representation to\n145\n5.3. SOLUTIONS\na purely Numpy based callable function. Evaluate the Posterior Distribution at \u03b8 :\n0.5, a : 2, b : 7\n5. Plot the posterior distribution, using the Numpy based function.\n6. Show that the posterior distribution has the same functional dependence on \u03b8 as the\nprior, and it is just another Beta distribution.\n7. Given:\nPrior : Beta(\u03b8|a = 2, b = 7) = 56\u03b8 (\u2212\u03b8 + 1)6 and:\nLikelihood : Bin(r = 3|n = 6, \u03b8) = 19600\u03b83 (\u2212\u03b8 + 1)47 \ufb01nd the resulting posterior\ndistribution and plot it.\n5.3\nSolutions\n5.3.1\nAlgorithmic differentiation, Gradient descent\n5.3.2\nNumerical differentiation",
    "solution": "To correctly render the generated LaTeX in this problem, we import and con\ufb01gure several\nlibraries as depicted in 5.30.\n174\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 import numpy as np\n2 import scipy.stats as st\n3 import matplotlib.pyplot as plt\n4 import sympy as sp\n5 sp.interactive.printing.\n6 init_printing(use_latex=True)\n7 from IPython.display import display, Math, Latex\n8 maths = lambda s: display(Math(s))\n9 latex = lambda s: display(Latex(s))^^I\nFIGURE 5.30: SymPy imports\n1. The Likelihood function can be created as follows. Note the speci\ufb01c details of generating\nthe Factorial function in SymPy.\n175\n5.3. SOLUTIONS\n1 n = sp.Symbol('n', integer=True, positive=True)\n2 r = sp.Symbol('r', integer=True, positive=True)\n3 theta = sp.Symbol('theta')\n4 # Create the function symbolically\n5 from sympy import factorial\n6 cNkSym=\n(factorial(n))/ (factorial(r) *factorial(n-r))\n7 cNkSym.evalf()\n8 binomSym= cNkSym*((theta **r)*(1-theta)**(n-r))\n9 binomSym.evalf()\n10 #Convert it to a Numpy-callable function\n11 binomLambda = sp.Lambda((theta,r,n), binomSym)\n12 maths(r\"\\operatorname{Bin}(r|n,\\theta) = \")\n13 display (binomLambda.expr)\n14 #Evaluating the SymPy version results in:\n15 > binomSym.subs({theta:0.5,r:50,n:100})\n16 #Evaluating the pure Numpy version results in:\n17 > binomLambda(0.5,50,100)= 0.07958923\nFIGURE 5.31: Likelihood function using SymPy\nThe Symbolic representation results in the following LaTeX:\nBin(r|n, \u03b8) = \u03b8r (\u2212\u03b8 + 1)n\u2212r n!\nr! (n \u2212 r)!\n(5.78)\n2. The Beta distribution can be created as follows.\n176\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 a = sp.Symbol('a', integer=False, positive=True)\n2 b = sp.Symbol('b', integer=False, positive=True)\n3 #mu = sp.Symbol('mu', integer=False, positive=True)\n4 # Create the function symbolically\n5 G = sp.gamma\n6 # The normalisation factor\n7 BetaNormSym = G(a + b)/(G(a)*G(b))\n8 # The functional form\n9 BetaFSym = theta**(a-1) * (1-theta)**(b-1)\n10 BetaSym=BetaNormSym * BetaFSym\n11 BetaSym.evalf() # this works\n12 # Turn Beta into a function\n13 BetaLambda = sp.Lambda((theta,a,b), BetaNormSym * BetaFSym)\n14 maths(r\"\\operatorname{Beta}(\\theta|a,b) = \")\n15 display(BetaSym)\n16 #Evaluating the SymPy version results in:\n17 > BetaLambda(0.5,2,7)=0.4375\n18 #Evaluating the pure Numpy version results in:\n19 > BetaSym.subs({theta:0.5,a:2,b:7})=0.4375\nFIGURE 5.32: Beta distribution using SymPy\nThe result is:\nBeta(\u03b8|a, b) = \u03b8a\u22121\u0393(a + b)\n\u0393(a)\u0393(b)\n(\u2212\u03b8 + 1)b\u22121\n(5.79)\n3. The plot is depicted in 5.33.\n177\n5.3. SOLUTIONS\n1 %pylab inline\n2 mus = arange(0,1,.01)\n3 # Plot for various values of a and b\n4 for ab in [(.1,.1),(.5,.5),(2,20),(2,3), (1,1)]:\n5 plot(mus, vectorize(BetaLambda)(mus,*ab), label=\"a=%s b=%s\" % ab)\n6 legend(loc=0)\n7 xlabel(r\"$\\theta$\", size=22)\nFIGURE 5.33: A plot of the Beta distribution\n4. We can \ufb01nd the posterior distribution by multiplying our Beta prior by the Binomial\nLikelihood.\n178\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 a = sp.Symbol('a', integer=False, positive=True)\n2 b = sp.Symbol('b', integer=False, positive=True)\n3 BetaBinSym=BetaSym * binomSym\n4 # Turn Beta-bin into a function\n5 BetaBinLambda = sp.Lambda((theta,a,b,n,r), BetaBinSym)\n6 BetaBinSym=BetaBinSym.powsimp()\n7 display(BetaBinSym)\n8 maths(r\"\\operatorname{Beta}(\\theta|a,b) \\times\n\\operatorname{Bin}(r|n,\\theta) \\propto %s\" %\nsp.latex(BetaBinSym))\n\ufffd\u2192\n\ufffd\u2192\n9 > BetaBinSym.subs({theta:0.5,a:2,b:7,n:10,r:3})= 0.051269\n10 > BetaBinLambda (0.5,2,7, 10,3)= 0.051269\nFIGURE 5.34: A plot of the Beta distribution\nThe result is:\nBeta(\u03b8|a, b) \u00d7 Bin(r|n, \u03b8) \u221d\n\u03b8a+r\u22121 (\u2212\u03b8 + 1)b+n\u2212r\u22121 n!\nr! (n \u2212 r)!\u0393(a)\u0393(b)\n\u0393(a + b)\nSo the posterior distribution has the same functional dependence on \u03b8 as the prior, it is\njust another Beta distribution.\n5. Mathematically, the relationship is as follows:\n179\n5.3. SOLUTIONS\nPrior :\nBeta(\u03b8|a = 2, b = 7)\n= 56\u03b8 (\u2212\u03b8 + 1)6\nLikelihood :\nBin(r = 3|n = 6, \u03b8) = 19600\u03b83 (\u2212\u03b8 + 1)47\nPosterior(normalised) :\nBeta(\u03b8|2, 7) \u00d7 Bin(3|50, \u03b8) = 1097600\u03b84 (\u2212\u03b8 + 1)53\n(5.80)\n180\nChapter 5\nDEEP LEARNING: CALCULUS, ALGORITHMIC DIFFERENTIATION\n1 prior = BetaLambda(theta,2,7)\n2 maths(\"\\mathbf{Prior}:\\operatorname{Beta}(\\theta|a=2,b=7) = %s\" %\nsp.latex(prior))\n\ufffd\u2192\n3 likelihood = binomLambda(theta,3,50) # = binomLambda(0.5,3,10)\n4 maths(\"\\mathbf{Likelihood}: \\operatorname{Bin}(r=3|n=6,\\theta) =\n%s\" % sp.latex(likelihood))\n\ufffd\u2192\n5 posterior = prior * likelihood\n6 posterior=posterior.powsimp()\n7 maths(r\"\\mathbf{Posterior\n(normalised)}:\\operatorname{Beta}(\\theta|2,7) \\times\n\\operatorname{Bin}(3|50,\\theta)=%s\"\n\ufffd\u2192\n\ufffd\u2192\n8 posterior.subs({theta:0.5})\n9 plt.plot(mus, (sp.lambdify(theta,posterior))(mus), 'r')\n10 xlabel(\"$\\\\theta$\", size=22)\nFIGURE 5.35: A plot of the Posterior with the provided data samples.\n\u25a0\nReferences\n[1]\nJ. Bradbury et al. JAX: composable transformations of NumPy programs. 2018 (cit. on\npp. 123, 136).\n181\nREFERENCES\n[2]\nW. K. Clifford. \u2018Preliminary Sketch of Bi-quaternions\u2019. In: Proceedings of the Lon-\ndon Mathematical Society 4 (1873), pp. 381\u201395 (cit. on pp. 125, 139).\n[3]\nR. Frostig et al. JAX: Autograd and XLA. 2018 (cit. on p. 123).\n[4]\nA. Griewank, D. Juedes and J. Utke. \u2018Algorithm 755; ADOL-C: a package for the\nautomatic differentiation of algorithms written in C/C++\u2019. In: ACM Transactions\non Mathematical Software 22.2 (June 1996), pp. 131\u2013167 (cit. on pp. 123, 125).\n[5]\nA. Griewank and A. Walther. Evaluating Derivatives: Principles and Techniques\nof Algorithmic Differentiation. Second. USA: Society for Industrial and Applied\nMathematics, 2008 (cit. on pp. 123, 124).\n[6]\nK. Gurney. An Introduction to Neural Networks. 1 Gunpowder Square, London\nEC4A 3DE, UK: UCL Press, 1998 (cit. on p. 135).\n[7]\nL. V. Kantorovich. \u2018On a mathematical symbolism convenient for performing\nmachine calculations\u2019. In: Dokl. Akad. Nauk SSSR. Vol. 113. 4. 1957, pp. 738\u2013741\n(cit. on p. 123).\n[8]\nG. Kedem. \u2018Automatic differentiation of computer programs\u2019. In: ACM Transac-\ntions on Mathematical Software (TOMS) 6.2 (1980), pp. 150\u2013165 (cit. on pp. 126,\n149).\n[9]\nS. Laue. On the Equivalence of Forward Mode Automatic Differentiation and Symbolic\nDifferentiation. 2019. arXiv: 1904.02990 [cs.SC] (cit. on p. 124).\n[10]\nD. Maclaurin, D. Duvenaud and R. P. Adams. \u2018Autograd: Effortless gradients in\nnumpy\u2019. In: ICML 2015 AutoML Workshop. Vol. 238. 2015 (cit. on pp. 123, 136).\n[11]\nA. Paszke et al. \u2018Automatic differentiation in PyTorch\u2019. In: (2017) (cit. on p. 136).\n[12]\nD. Rumelhart, G. Hinton and R. Williams. \u2018Learning representations by back\npropagating errors\u2019. In: Nature 323 (1986), pp. 533\u2013536 (cit. on p. 135).\n[13]\nB. Speelpenning. Compiling fast partial derivatives of functions given by algorithms.\nTech. rep. Illinois Univ Urbana Dept of Computer Science, 1980 (cit. on p. 126).\n182\nBACHELORS\nPART IV\nCHAPTER\n6\nDEEP LEARNING: NN ENSEMBLES\nThe saddest aspect of life right now is that gathers knowledge faster than society\ngathers wisdom.\n\u2014 Isaac Asimov\nContents\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\nProblems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\nBagging, Boosting and Stacking . . . . . . . . . . . . . . . . . . . . . . . 186\nApproaches for Combining Predictors . . . . . . . . . . . . . . . . . . . 190\nMonolithic and Heterogeneous Ensembling . . . . . . . . . . . . . . . . 191\nEnsemble Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\nSnapshot Ensembling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\nMulti-model Ensembling . . . . . . . . . . . . . . . . . . . . . . . . . . . 196\nLearning-rate Schedules in Ensembling\n. . . . . . . . . . . . . . . . . . 197\nSolutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\nBagging, Boosting and Stacking . . . . . . . . . . . . . . . . . . . . . . . 198\nApproaches for Combining Predictors . . . . . . . . . . . . . . . . . . . 199\nMonolithic and Heterogeneous Ensembling . . . . . . . . . . . . . . . . 200\nEnsemble Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\nSnapshot Ensembling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\nMulti-model Ensembling . . . . . . . . . . . . . . . . . . . . . . . . . . . 202\nLearning-rate Schedules in Ensembling\n. . . . . . . . . . . . . . . . . . 202\n6.1. INTRODUCTION\n6.1\nIntroduction\nI\nNtuition and practice demonstrate that a poor or an inferior choice may\nbe altogether prevented merely by motivating a group (or an ensemble)\nof people with diverse perspectives to make a mutually acceptable choice.\nLikewise, in many cases, neural network ensembles signi\ufb01cantly improve\nthe generalization ability of single-model based AI systems [5, 11]. Shortly follow-\ning the foundation of Kaggle, research in the \ufb01eld had started blooming; not only\nbecause researchers are advocating and using advanced ensembling approaches in\nalmost every competition, but also by the empirical success of the top winning mod-\nels. Though the whole process of training ensembles typically involves the utilization\nof dozens of GPUs and prolonged training periods, ensembling approaches enhance\nthe predictive power of a single model. Though ensembling obviously has a signi\ufb01c-\nant impact on the performance of AI systems in general, research shows its effect is\nparticularly dramatic in the \ufb01eld of neural networks [Russakovsky_2015, 1, 4, 7, 13].\nTherefore, while we could examine combinations of any type of learning algorithms,\nthe focus of this chapter is the combination of neural networks.\n6.2\nProblems\n6.2.1\nBagging, Boosting and Stacking"
  },
  {
    "id": "PRB-135",
    "chapter": "",
    "question": "Mark all the approaches which can be utilized to boost a single model performance:\n(i) Majority Voting\n(ii) Using K-identical base-learning algorithms\n(iii) Using K-different base-learning algorithms\n(iv) Using K-different data-folds\n(v) Using K-different random number seeds\n(vi) A combination of all the above approaches\n186\nChapter 6\nDEEP LEARNING: NN ENSEMBLES",
    "solution": "All the presented options are correct.\n\u25a0"
  },
  {
    "id": "PRB-136",
    "chapter": "",
    "question": "An argument erupts between two senior data-scientists regarding the choice of an ap-\nproach for training of a very small medical corpus. One suggest that bagging is superior\nwhile the other suggests stacking. Which technique, bagging or stacking, in your opinion is\nsuperior? Explain in detail.\n(i) Stacking since each classier is trained on all of the available data.\n(ii) Bagging since we can combine as many classi\ufb01ers as we want by training each on a\ndifferent sub-set of the training corpus.",
    "solution": "The correct choice would be stacking. In cases where the given corpus is small, we would\nmost likely prefer training our models on the full data-set.\n\u25a0"
  },
  {
    "id": "PRB-137",
    "chapter": "",
    "question": "Complete the sentence: A random forest is a type of a decision tree which utilizes [bag-\nging/boosting]",
    "solution": "A random forest is a type of a decision tree which utilizes bagging.\n\u25a0\n198\nChapter 6\nDEEP LEARNING: NN ENSEMBLES"
  },
  {
    "id": "PRB-138",
    "chapter": "",
    "question": "The algorithm depicted in Fig. 6.1 was found in an old book about ensembling. Name the\nalgorithm.\n187\n6.2. PROBLEMS\nAlgorithm 1: Algo 1\nData: A set of training data, Q with N elements has been established\nwhile K times do\nCreate a random subset of N \u2032 data by sampling from Q containing the N\nsamples;\nN \u2032 < N;\nExecute algorithm Algo 2;\nReturn all N \u2032 back to Q\nAlgorithm 2: Algo 2\nChoose a learner hm;\nwhile K times do\nPick a training set and train with hm;\nFIGURE 6.1: A speci\ufb01c ensembling approach",
    "solution": "The presented algorithm is a classic bagging.\n\u25a0"
  },
  {
    "id": "PRB-139",
    "chapter": "",
    "question": "Fig. 6.2 depicts a part of a speci\ufb01c ensembling approach applied to the models x1, x2...xk.\nIn your opinion, which approach is being utilized?\nGenerelizer\nx3\nx2\nx1\n...\nxk\nBase Learners\nf\n?\nFIGURE 6.2: A speci\ufb01c ensembling approach\n(i) Bootstrap aggregation\n(ii) Snapshot ensembling\n(iii) Stacking\n188\nChapter 6\nDEEP LEARNING: NN ENSEMBLES\n(iv) Classical committee machines",
    "solution": "The approach which is depicted is the \ufb01rst phase of stacking. In stacking, we \ufb01rst (phase\n0) predict using several base learners and then use a generalizer (phase 1) that learns on top\nof the base learners predictions.\n\u25a0"
  },
  {
    "id": "PRB-140",
    "chapter": "",
    "question": "Consider training corpus consisting of balls which are glued together as triangles, each\nof which has either 1, 3, 6, 10, 15, 21, 28, 36, or 45 balls.\n1. We draw several samples from this corpus as presented in Fig. 6.3 wherein each sample\nis equiprobable. What type of sampling approach is being utilized here?\nFIGURE 6.3: Sampling approaches\n(i) Sampling without replacement\n(ii) Sampling with replacement\n2. Two samples are drawn one after the other. In which of the following cases is the\ncovariance between the two samples equals zero?\n(i) Sampling without replacement\n(ii) Sampling with replacement\n3. During training, the corpus sampled with replacement and is divided into several\nfolds as presented in Fig. 6.4.\nT1:\nT2:\nT3:\nT4:\nFIGURE 6.4: Sampling approaches\n189\n6.2. PROBLEMS\nIf 10 balls glued together is a sample event that we know is hard to correctly classify,\nthen it is impossible that we are using:\n(i) Bagging\n(ii) Boosting\n6.2.2\nApproaches for Combining Predictors",
    "solution": "1. Sampling with replacement\n2. Sampling without replacement\n3. This may be mostly a result of bagging, since in boosting we would have expected miss-\ncorrectly classi\ufb01ed observations to repeatedly appear in subsequent samples.\n\u25a0\n6.3.2\nApproaches for Combining Predictors"
  },
  {
    "id": "PRB-141",
    "chapter": "",
    "question": "There are several methods by which the outputs of base classi\ufb01ers can be combined to\nyield a single prediction. Fig. 6.5 depicts part of a speci\ufb01c ensembling approach applied to\nseveral CNN model predictions for a labelled data-set. Which approach is being utilized?\n(i) Majority voting for binary classi\ufb01cation\n(ii) Weighted majority voting for binary classi\ufb01cation\n(iii) Majority voting for class probabilities\n(iv) Weighted majority class probabilities\n(v) An algebraic weighted average for class probabilities\n(vi) An adaptive weighted majority voting for combining multiple classi\ufb01ers\n190\nChapter 6\nDEEP LEARNING: NN ENSEMBLES\n1 l = []\n2 for i,f in enumerate(filelist):\n3\ntemp =\npd.read_csv(f)\n4\nl.append(temp)\n5 arr = np.stack(l,axis=-1)\n6 avg_results = pd.DataFrame(arr[:,:-1,:].mean(axis=2))\n7 avg_results['image'] = l[0]['image']\n8 avg_results.columns = l[0].columns\nFIGURE 6.5: PyTorch code snippet for an ensemble",
    "solution": "An Algebraic weighted average for class probabilities.\n\u25a0"
  },
  {
    "id": "PRB-142",
    "chapter": "",
    "question": "Read the paper Neural Network Ensembles [3] and then complete the sentence: If the\naverage error rate for a speci\ufb01c instance in the corpus is less than [...]% and the respective\nclassi\ufb01ers in the ensemble produce independent [...], then when the number of classi\ufb01ers\ncombined approaches in\ufb01nity, the expected error can be diminished to zero.",
    "solution": "This is true, [3] provides a mathematical proof.\n\u25a0"
  },
  {
    "id": "PRB-143",
    "chapter": "",
    "question": "True or false: A perfect ensemble comprises of highly correct classi\ufb01ers that differ as\nmuch as possible.",
    "solution": "This is true. For extension, see instance [8].\n\u25a0"
  },
  {
    "id": "PRB-144",
    "chapter": "",
    "question": "True or false: In bagging, we re-sample the training corpus with replacement and there-\nfore this may lead to some instances being represented numerous times while other instances\nnot to be represented at all.\n6.2.3\nMonolithic and Heterogeneous Ensembling",
    "solution": "This is true. In a bagging approach, we \ufb01rst randomly draw (with replacement), K ex-\n199\n6.3. SOLUTIONS\namples where K is the size of the original training corpus therefore leading to an imbalanced\nrepresentation of the instances.\n\u25a0\n6.3.3\nMonolithic and Heterogeneous Ensembling"
  },
  {
    "id": "PRB-145",
    "chapter": "",
    "question": "191\n6.2. PROBLEMS\n1. True or false: Training an ensemble of a single monolithic architecture results in\nlower model diversity and possibly decreased model prediction accuracy.\n2. True or false: The generalization accuracy of an ensemble increases with the number\nof well-trained models it consists of.\n3. True or false: Bootstrap aggregation (or bagging), refers to a process wherein a CNN\nensemble is being trained using a random subset of the training corpus.\n4. True or false: Bagging assumes that if the single predictors have independent errors,\nthen a majority vote of their outputs should be better than the individual predictions.",
    "solution": "1. True Due to their lack of diversity, an ensemble of monolithic architectures tends to\nperform worse than an heterogeneous ensemble.\n2. True This has be consistently demonstrated in [11, 5].\n3. True In [6] there is a discussion about both using the whole corpus and a subset much\nlike in bagging.\n4. True The total error decreases with the addition of predictors to the ensemble.\n\u25a0"
  },
  {
    "id": "PRB-146",
    "chapter": "",
    "question": "Refer to the papers: Dropout as a Bayesian Approximation [2] and Can You Trust\nYour Model\u2019s Uncertainty? [12] and answer the following question: Do deep ensembles\nachieve a better performance on out-of-distribution uncertainty benchmarks compared with\nMonte-Carlo (MC)-dropout?",
    "solution": "Yes, they do.\n\u25a0"
  },
  {
    "id": "PRB-147",
    "chapter": "",
    "question": "1. In a transfer-learning experiment conducted by a researcher, a number of ImageNet-\npretrained CNN classi\ufb01ers, selected from Table 6.1 are trained on \ufb01ve different folds\ndrawn from the same corpus. Their outputs are fused together producing a composite\nmachine. Ensembles of these convolutional neural networks architectures have been\nextensively studies an evaluated in various ensembling approaches [4, 9]. Is it likely\nthat the composite machine will produce a prediction with higher accuracy than that\nof any individual classi\ufb01er? Explain why.\n192\nChapter 6\nDEEP LEARNING: NN ENSEMBLES\nCNN Model\nClasses\nImage Size\nTop-1 accuracy\nResNet152\n1000\n224\n78.428\nDPN98\n1000\n224\n79.224\nSeNet154\n1000\n224\n81.304\nSeResneXT101\n1000\n224\n80.236\nDenseNet161\n1000\n224\n77.560\nInceptionV4\n1000\n299\n80.062\nTABLE 6.1: ImageNet-pretrained CNNs. Ensembles of these CNN architectures have been\nextensively studies and evaluated in various ensembling approaches.\n2. True or False: In a classi\ufb01cation task, the result of ensembling is always superior.\n3. True or False: In an ensemble, we want differently trained models converge to differ-\nent local minima.",
    "solution": "1. Yes, it is very likely, especially if their errors are independent.\n2. True It may be proven that ensembles of models perform at least as good as each of the\nensemble members it consists of.\n3. True Different local minima add to the diversi\ufb01cation of the models.\n\u25a0"
  },
  {
    "id": "PRB-148",
    "chapter": "",
    "question": "In committee machines, mark all the combiners that do not make direct use of the input:\n(i) A mixture of experts\n(ii) Bagging\n(iii) Ensemble averaging\n(iv) Boosting",
    "solution": "Boosting is the only one that does not.\n\u25a0\n200\nChapter 6\nDEEP LEARNING: NN ENSEMBLES"
  },
  {
    "id": "PRB-149",
    "chapter": "",
    "question": "True or False: Considering a binary classi\ufb01cation problem (y = 0 or y = 1), ensemble\naveraging, wherein the outputs of individual models are linearly combined to produce a fused\noutput is a form of a static committee machine.\n193\n6.2. PROBLEMS\nMn\nM2\nM1\n\ufffd\nwn\nw2\nw1\n0\n1\n0\n1\nFIGURE 6.6: A typical binary classi\ufb01cation problem.",
    "solution": "False By de\ufb01nition, static committee machines use only the output of the single predict-\nors.\n\u25a0"
  },
  {
    "id": "PRB-150",
    "chapter": "",
    "question": "True or false: When using a single model, the risk of over\ufb01tting the data increases when\nthe number of adjustable parameters is large compared to cardinality (i.e., size of the set) of\nthe training corpus.",
    "solution": "True\n\u25a0"
  },
  {
    "id": "PRB-151",
    "chapter": "",
    "question": "True or false: If we have a committee of K trained models and the errors are uncorrelated,\nthen by averaging them the average error of a model is reduced by a factor of K.\n6.2.4\nEnsemble Learning",
    "solution": "False Though this may be theoretically true, in practice the errors are rarely uncorrelated\nand therefore the actual error can not be reduced by a factor of K.\n\u25a0\n6.3.4\nEnsemble Learning"
  },
  {
    "id": "PRB-152",
    "chapter": "",
    "question": "1. De\ufb01ne ensemble learning in the context of machine learning.\n2. Provide examples of ensemble methods in classical machine-learning.\n3. True or false: Ensemble methods usually have stronger generalization ability.\n4. Complete the sentence: Bagging is variance/bias reduction scheme while boosting\nreduced variance/bias.\n194\nChapter 6\nDEEP LEARNING: NN ENSEMBLES\n6.2.5\nSnapshot Ensembling",
    "solution": "1. Ensemble learning is an excellent machine learning idea which displays noticeable bene-\n\ufb01ts in many applications, one such notable example is the widespread use of ensembles\nin Kaggle competitions. In an ensemble several individual models (for instance Res-\nNet18 and VGG16) which were trained on the same corpus, work in tandem and during\ninference, their predictions are fused by a pre-de\ufb01ned strategy to yield a single predic-\ntion.\n2. In classical machine learning Ensemble methods usually refer to bagging, boosting and\nthe linear combination of regression or classi\ufb01cation models.\n3. True The stronger generalization ability stems from the voting power of diverse models\nwhich are joined together.\n4. Bagging is variance reduction scheme while boosting reduced bias.\n\u25a0\n6.3.5\nSnapshot Ensembling\n201\n6.3. SOLUTIONS"
  },
  {
    "id": "PRB-153",
    "chapter": "",
    "question": "Your colleague, a well-known expert in ensembling methods, writes the following pseudo\ncode in Python shown in Fig. 6.7 for the training of a neural network. This runs inside a\nstandard loop in each training and validation step.\n1 import torchvision.models as models\n2 ...\n3 models = ['resnext']\n4\nfor m in models:\n5\ntrain ...\n6\ncompute VAL loss ...\n7\namend LR ...\n8\nif (val_acc > 90.0):\n9\nsaveModel()\nFIGURE 6.7: PyTorch code snippet for an ensemble\n1. What type of ensembling can be used with this approach? Explain in detail.\n2. What is the main advantage of snapshot ensembling? What are the disadvantages, if\nany?",
    "solution": "1. Since only a single model ie being utilized, this type of ensembling is known as snap-\nshot ensembling. Using this approach, during the training of a neural network and\nin each epoch, a snapshot, e.g. the weights of a trained instance of a model (a PTH\n\ufb01le in PyTorch nomenclature) are persisted into permanent storage whenever a certain\nperformance metrics, such as accuracy or loss is being surpassed. Therefore the name\n\u201csnapshot\u201d; weights of the neural network are being snapshot at speci\ufb01c instances in\ntime. After several such epochs the top-5 performing Snapshots which converged to\nlocal minima [4] are combined as part of an ensemble to yield a single prediction.\n2. Advantages: during a single training cycle, many model instances may be collected.\nDisadvantages: inherent lack of diversity by virtue of the fact that the same models is\nbeing repeatedly used.\n\u25a0"
  },
  {
    "id": "PRB-154",
    "chapter": "",
    "question": "Assume further that your colleague amends the code as follows in Fig. 6.8.\n195\n6.2. PROBLEMS\n1 import torchvision.models as models\n2 import random\n3 import np\n4 ...\n5 models = ['resnext']\n6\nfor m in models:\n7\ntrain ...\n8\ncompute loss ...\n9\namend LR ...\n10\nmanualSeed= draw a new random number\n11\nrandom.seed(manualSeed)\n12\nnp.random.seed(manualSeed)\n13\ntorch.manual_seed(manualSeed)\n14\nif (val_acc > 90.0):\n15\nsaveModel()\nFIGURE 6.8: PyTorch code snippet for an ensemble\nExplain in detail what would be the possible effects of adding lines 10-13.\n6.2.6\nMulti-model Ensembling",
    "solution": "Changing the random seed at each iteration/epoch, helps in introducing variation which\nmay contribute to diversifying the trained neural network models.\n\u25a0\n6.3.6\nMulti-model Ensembling"
  },
  {
    "id": "PRB-155",
    "chapter": "",
    "question": "1. Assume your colleague, a veteran in DL and an expert in ensembling methods writes\nthe following Pseudo code shown in Fig. 6.9 for the training of several neural networks.\nThis code snippet is executed inside a standard loop in each and every training/valida-\ntion epoch.\n196\nChapter 6\nDEEP LEARNING: NN ENSEMBLES\n1 import torchvision.models as models\n2 ...\n3 models = ['resnext','vgg','dense']\n4\nfor m in models:\n5\ntrain ...\n6\ncompute loss/acc ...\n7\nif (val_acc > 90.0):\n8\nsaveModel()\nFIGURE 6.9: PyTorch code snippet for an ensemble\nWhat type of ensembling is being utilized in this approach? Explain in detail.\n2. Name one method by which NN models may be combined to yield a single prediction.\n6.2.7\nLearning-rate Schedules in Ensembling",
    "solution": "1. Multi-model ensembling.\n2. Both averaging and majority voting.\n\u25a0\n6.3.7\nLearning-rate Schedules in Ensembling"
  },
  {
    "id": "PRB-156",
    "chapter": "",
    "question": "1. Referring to Fig. (6.10) which depicts a speci\ufb01c learning rate schedule, describe the\nbasic notion behind its mechanism.\n197\n6.3. SOLUTIONS\n1\n0,5\n1\nx\ny\nFIGURE 6.10: A learning rate schedule.\n2. Explain how cyclic learning rates [10] can be effective for the training of convolutional\nneural networks such as the ones in the code snippet of Fig. 6.10.\n3. Explain how a cyclic cosine annealing schedule as proposed by Loshchilov [10] and\n[13] is used to converge to multiple local minima.\n6.3\nSolutions\n6.3.1\nBagging, Boosting and Stacking",
    "solution": "202\nChapter 6\nDEEP LEARNING: NN ENSEMBLES\n1. Capturing the best model of each training cycle allows to obtain multiple models settled\non various local optima from cycle to cycle at the cost of training a single mode\n2. The approach is based on the non-convex nature of neural networks and the ability to\nconverge and escape from local minima using a speci\ufb01c schedule to adjust the learning\nrate during training.\n3. Instead of monotonically decreasing the learning rate, this method lets the learning rate\ncyclically vary between reasonable boundary values.\n\u25a0\nReferences\n[1]\nB. Chu et al. \u2018Best Practices for Fine-Tuning Visual Classi\ufb01ers to New Domains\u2019.\nIn: Computer Vision \u2013 ECCV 2016 Workshops. Ed. by G. Hua and H. J\u00e9gou. Cham:\nSpringer International Publishing, 2016, pp. 435\u2013442 (cit. on p. 186).\n[2]\nY. Gal and Z. Ghahramani. \u2018Dropout as a Bayesian approximation\u2019. In: arXiv\npreprint arXiv:1506.02157 (2015) (cit. on p. 192).\n[3]\nL. K. Hansen and P. Salamon. \u2018Neural Network Ensembles\u2019. In: IEEE Trans. Pat-\ntern Anal. Mach. Intell. 12 (1990), pp. 993\u20131001 (cit. on pp. 191, 199).\n[4]\nG. Huang et al. \u2018Snapshot ensembles: Train 1, get M for free. arXiv 2017\u2019. In:\narXiv preprint arXiv:1704.00109 () (cit. on pp. 186, 192, 202).\n[5]\nJ. Huggins, T. Campbell and T. Broderick. \u2018Coresets for scalable Bayesian logistic\nregression\u2019. In: Advances in Neural Information Processing Systems. 2016, pp. 4080\u2013\n4088 (cit. on pp. 186, 200).\n[6]\nC. Ju, A. Bibaut and M. van der Laan. \u2018The relative performance of ensemble\nmethods with deep convolutional neural networks for image classi\ufb01cation\u2019. In:\nJournal of Applied Statistics 45.15 (2018), pp. 2800\u20132818 (cit. on p. 200).\n[7]\nS. Kornblith, J. Shlens and Q. V. Le. Do Better ImageNet Models Transfer Better?\n2018. arXiv: 1805.08974 [cs.CV] (cit. on p. 186).\n[8]\nA. Krogh and J. Vedelsby. \u2018Neural Network Ensembles, Cross Validation, and\nActive Learning\u2019. In: NIPS. 1994 (cit. on p. 199).\n[9]\nS. Lee et al. \u2018Stochastic multiple choice learning for training diverse deep en-\nsembles\u2019. In: Advances in Neural Information Processing Systems. 2016, pp. 2119\u2013\n2127 (cit. on p. 192).\n203\nREFERENCES\n[10]\nI. Loshchilov and F. Hutter. \u2018Sgdr: Stochastic gradient descent with warm re-\nstarts\u2019. In: arXiv preprint arXiv:1608.03983 (2016) (cit. on p. 198).\n[11]\nP. Oshiro et al.(2012)Oshiro and Baranauskas. \u2018How many trees in a random\nforest?\u2019 In: International Workshop on Machine Learning and Data Mining in Pattern\nRecognition. 2012 (cit. on pp. 186, 200).\n[12]\nY. Ovadia et al. \u2018Can you trust your model\u2019s uncertainty? Evaluating predict-\nive uncertainty under dataset shift\u2019. In: Advances in Neural Information Processing\nSystems. 2019, p. 13991 (cit. on p. 192).\n[13]\nL. N. Smith. \u2018Cyclical learning rates for training neural networks\u2019. In: 2017 IEEE\nWinter Conference on Applications of Computer Vision (WACV). IEEE. 2017, pp. 464\u2013\n472 (cit. on pp. 186, 198).\n204\nCHAPTER\n7\nDEEP LEARNING: CNN FEATURE EXTRACTION\nWhat goes up must come down.\n\u2014 Isaac Newton\nContents\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205\nProblems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206\nCNN as Fixed Feature Extractor . . . . . . . . . . . . . . . . . . . . . . . 206\nFine-tuning CNNs\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213\nNeural style transfer, NST . . . . . . . . . . . . . . . . . . . . . . . . . . 214\nSolutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216\nCNN as Fixed Feature Extractor . . . . . . . . . . . . . . . . . . . . . . . 216\nFine-tuning CNNs\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222\nNeural style transfer\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224\n7.1\nIntroduction\nT\nHE extraction of an n-dimensional feature vector (FV) or an embedding from\none (or more) layers of a pre-trained CNN, is termed feature extraction (FE).\nUsually, FE works by \ufb01rst removing the last fully connected (FC) layer from\na CNN and then treating the remaining layers of the CNN as a \ufb01xed FE. As\nexempli\ufb01ed in Fig. (7.1) and Fig. (7.2), applying this method to the ResNet34 archi-\ntecture, the resulting FV consists of 512 \ufb02oating point values. Likewise, applying the\nsame logic on the ResNet152 architecture, the resulting FV has 2048 \ufb02oating point ele-\nments.\n7.2. PROBLEMS\n1\n2\n3\n4\n\u00b7 \u00b7 \u00b7\nk = 512\nA \ufb01xed k-element FV.\n0.7766 0.4455 0.8342 0.6324 \u00b7 \u00b7 \u00b7\nk = 512\nActual values of a normalized k-element FV.\nFIGURE 7.1: A one-dimensional 512-element embedding for a single image from the Res-\nNet34 architecture. While any neural network can be used for FE, depicted is\nthe ResNet CNN architecture with 34 layers.\n1\nimport torchvision.models as models\n2\n...\n3\nres_model = models.resnet34(pretrained=True)\nFIGURE 7.2: PyTorch decleration for a pre-trained ResNet34 CNN (simpli\ufb01ed).\nThe premise behind FE is that CNNs which were originally trained on the Im-\nageNet Large Scale Visual Recognition Competition [7], can be adapted and used (for\ninstance in a classi\ufb01cation task) on a completely different (target) domain without any\nadditional training of the CNN layers. The power of a CNN to do so lies in its ability\nto generalize well beyond the original data-set it was trained on, therefore FE on a\nnew target data-set involves no training and requires only inference.\n7.2\nProblems\n7.2.1\nCNN as Fixed Feature Extractor\nBefore attempting the problems in this chapter you are highly encouraged to read the\nfollowing papers [1, 3, 7]. In many DL job interviews, you will be presented with a\npaper you have never seen before and subsequently be asked questions about it; so\nreading these references would be an excellent simulation of this real-life task.\n206\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION"
  },
  {
    "id": "PRB-157",
    "chapter": "",
    "question": "True or False: While AlexNet [4] used 11 \u00d7 11 sized \ufb01lters, the main novelty presented\nin the VGG [8] architecture was utilizing \ufb01lters with much smaller spatial extent, sized\n3 \u00d7 3.",
    "solution": "True. The increased depth in VGG-Net was made possible using smaller \ufb01lters without\nsubstantially increasing the number of learnable parameters. Albeit an unwanted side effect\nof the usage of smaller \ufb01lters is the increase in the number of \ufb01lters per-layer.\n\u25a0"
  },
  {
    "id": "PRB-158",
    "chapter": "",
    "question": "True or False: Unlike CNN architectures such as AlexNet or VGG, ResNet does not\nhave any hidden FC layers.",
    "solution": "True. The ResNet architecture terminates with a global average pooling layer followed\nby a K-way FC layer with a softmax activation function, where K is the number of classes\n(ImageNet has 1000 classes). Therefore, the ResNet has no hidden FC layers.\n\u25a0"
  },
  {
    "id": "PRB-159",
    "chapter": "",
    "question": "Assuming the VGG-Net has 138, 357, 544 \ufb02oating point parameters, what is the phys-\nical size in Mega-Bytes (MB) required for persisting a trained instance of VGG-Net on\npermanent storage?",
    "solution": "138, 357544 \u00d7 32 = 4427441408bits = 553.430176 MB.\n(7.1)\n\u25a0"
  },
  {
    "id": "PRB-160",
    "chapter": "",
    "question": "True or False: Most attempts at researching image representation using FE, focused\nsolely on reusing the activations obtained from layers close to the output of the CNN, and\nmore speci\ufb01cally the fully-connected layers.",
    "solution": "True. There are dozens of published papers supporting this claim. You are encouraged to\nsearch them on Arxiv or Google Scholar.\n\u25a0"
  },
  {
    "id": "PRB-161",
    "chapter": "",
    "question": "True or False: FE in the context of deep learning is particularly useful when the target\nproblem does not include enough labeled data to successfully train CNN that generalizes\nwell.",
    "solution": "True. One of the major hurdles of training a medical AI system is the lack of annotated\ndata. Therefore, extensive research is conducted to exploit ways for FE and transfer learning,\ne.g., in the application of ImageNet trained CNNs, to target datasets in which labeled data is\nscarce.\n\u25a0"
  },
  {
    "id": "PRB-162",
    "chapter": "",
    "question": "Why is a CNN trained on the ImageNet dataset [7] a good candidate for a source prob-\nlem?",
    "solution": "There are two main reasons why this is possible:\n1. The huge number of images inside the ImageNet dataset ensures a CNN model that gen-\neralizes to additional domains, like the histopathology domain, which is substantially\ndifferent from the original domain the model was trained one (e.g., cats and dogs).\n217\n7.3. SOLUTIONS\n2. A massive array of disparate visual patterns is produced by an ImageNet trained CNN,\nsince it consists of 1, 000 different groups.\n\u25a0"
  },
  {
    "id": "PRB-163",
    "chapter": "",
    "question": "207\n7.2. PROBLEMS\nComplete the missing parts regarding the VGG19 CNN architecture:\n1. The VGG19 CNN consists of [...] layers.\n2. It consists of [...] convolutional and 3 [...] layers.\n3. The input image size is [...].\n4. The number of input channels is [...].\n5. Every image has it\u2019s mean RGB value [subtracted / added].\n6. Each convolutional layer has a [small/large] kernel sized [...].\n7. The number of pixels for padding and stride is [...].\n8. There are 5 [...] layers having a kernel size of [...] and a stride of [...] pixels.\n9. For non-linearity a [recti\ufb01ed linear unit (ReLU [5])/sigmoid] is used.\n10. The [...] FC layers are part of the linear classi\ufb01er.\n11. The \ufb01rst two FC layers consist of [...] features.\n12. The last FC layer has only [...] features.\n13. The last FC layer is terminated by a [...] activation layer.\n14. Dropout [is / is not] being used between the FC layers.",
    "solution": "Complete the missing parts regarding the VGG19 CNN architecture:\n1. The VGG19 CNN consists of 19 layers.\n2. It consists of 5 convolutional and 3 FC layers.\n3. The input image size is 244 , the default size most ImageNet trained CNNs work on.\n4. The number of input channels is 3 .\n5. Every image has its mean RGB value subtracted . (why?)\n6. Each convolutional layer has a small kernel sized 3 \u00d7 3 . (why?)\n7. The number of pixels for padding and stride is the same and equals 1 .\n8. There are 5 convolutional layers having a kernel size of 2 \u00d7 2 and a stride of 2 pixels.\n9. For non-linearity a recti\ufb01ed linear unit (ReLU [5]) is used.\n10. The 3 FC layers are part of the linear classi\ufb01er.\n11. The \ufb01rst two FC layers consist of 4096 features.\n12. The last FC layer has only 1000 features.\n13. The last FC layer is terminated by a softmax activation layer.\n14. Dropout is being used between the FC layers.\n\u25a0"
  },
  {
    "id": "PRB-164",
    "chapter": "",
    "question": "The following question discusses the method of \ufb01xed feature extraction from layers of the\nVGG19 architecture [8] for the classi\ufb01cation of pancreatic cancer. It depicts FE principles\nwhich are applicable with minor modi\ufb01cations to other CNNs as well. Therefore, if you hap-\npen to encounter a similar question in a job interview, you are likely be able to cope with\nit by utilizing the same logic.\nIn Fig. (9.7) three different classes of pancreatic cancer are\ndisplayed: A, B and C, curated from a dataset of 4K Whole Slide Images (WSI) labeled by\na board certi\ufb01ed pathologist. Your task is to use FE to correctly classify the images in the\ndataset.\n208\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION\nFIGURE 7.3: A dataset of 4K histopathology WSI from three severity classes: A, B and C.\nTable (9.3) presents an incomplete listing of the of the VGG19 architecture [8]. As de-\npicted, for each layer the number of \ufb01lters (i. e., neurons with unique set of parameters),\nlearnable parameters (weights,biases), and FV size are presented.\nLayer name\n#Filters\n#Parameters\n# Features\nconv4_3\n512\n2.3M\n512\nfc6\n4,096\n103M\n4,096\nfc7\n4,096\n17M\n4,096\noutput\n1,000\n4M\n-\nTotal\n13,416\n138M\n12,416\nTABLE 7.1: Incomplete listing of the VGG19 architecture\n1. Describe how the VGG19 CNN may be used as \ufb01xed FE for a classi\ufb01cation task. In\nyour answer be as detailed as possible regarding the stages of FE and the method used\nfor classi\ufb01cation.\n2. Referring to Table (9.3), suggest three different ways in which features can be extrac-\nted from a trained VGG19 CNN model. In each case, state the extracted feature layer\nname and the size of the resulting FE.\n3. After successfully extracting the features for the 4K images from the dataset, how can\nyou now classify the images into their respective categories?\n209\n7.2. PROBLEMS",
    "solution": "218\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION\n1. One or more layers of the VGG19 CNN are selected for extraction and a new CNN\nis designed on top of it. Thus, during inference our target layers are extracted and\nnot the original softmax layer. Subsequently, we iterate and run inference over all\nthe images in our pancreatic cancer data-set, extract the features, and persist them to\npermanent storage such as a solid-state drive (SSD) device. Ultimately, each image has\na corresponding FV.\n2. Regarding the VGG19 CNN, there are numerous ways of extracting and combining\nfeatures from different layers. Of course, these different layers, e.g., the FC, conv4_3,\nand fc7 layer may be combined together to form a larger feature vector. To determine\nwhich method works best, you shall have to experiment on your data-set; there is no way\nof a-priory determining the optimal combination of layers. Here are several examples:\n(a) Accessing the last FC layer resulting in a 1000-D FV. The output is the score for\neach of the 1000 classes of the ImageNet data-set.\n(b) Removing the last FC layer leaves the fc7 layer, resulting in a 4096-D FV.\n(c) Directly accessing the conv4_3 layer results in a 512-D FV.\n3. Once the FVs are extracted, we can train any linear classi\ufb01er such as an SVM or\nsoftmax classi\ufb01er on the FV data-set, and not on the original images.\n\u25a0"
  },
  {
    "id": "PRB-165",
    "chapter": "",
    "question": "Still referring to Table (9.3), a data scientist suggests using the output layer of the\nVGG19 CNN as a \ufb01xed FE. What is the main advantage of using this layer over using\nfor instance, the fc7 layer? (Hint: think about an ensemble of feature extractors)",
    "solution": "One bene\ufb01t of using the FC layer is that other ImageNet CNNs can be used in tandem\nwith the VGG19 to create an ensemble since they all produce the same 1000-D sized FV.\n\u25a0"
  },
  {
    "id": "PRB-166",
    "chapter": "",
    "question": "Still referring to Table (9.3) and also to the code snippet in Fig. (7.4), which represents a\nnew CNN derived from the VGG19 CNN:\n1 import torchvision.models as models\n2 ...\n3 class VGG19FE(torch.nn.Module):\n4\ndef __init__(self):\n5\nsuper(VGG19FE, self).__init__()\n6\noriginal_model = models.VGG19(pretrained=[???])\n7\nself.real_name = (((type(original_model).__name__)))\n8\nself.real_name = \"vgg19\"\n9\n10\nself.features = [???]\n11\nself.classifier = torch.nn.Sequential([???])\n12\nself.num_feats = [???]\n13\n14\ndef forward(self, x):\n15\nf = self.features(x)\n16\nf = f.view(f.size(0), -1)\n17\nf = [???]\n18\nprint (f.data.size())\n19\nreturn f\nFIGURE 7.4: PyTorch code snippet for extracting the fc7 layer from a pre-trained VGG19\nCNN model.\n210\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION\n1. Complete line 6; what should be the value of pretrained ?\n2. Complete line 10; what should be the value of self.features ?\n3. Complete line 12; what should be the value of self.num_feats ?\n4. Complete line 17; what should be the value of f ?",
    "solution": "219\n7.3. SOLUTIONS\n1 import torchvision.models as models\n2 ...\n3 class VGG19FE(torch.nn.Module):\n4\ndef __init__(self):\n5\nsuper(VGG19FE, self).__init__()\n6\noriginal_model = models.VGG19(pretrained=True)\n7\nself.real_name = (((type(original_model).__name__)))\n8\nself.real_name = \"vgg19\"\n9\n10\nself.features = original_model.features\n11\nself.classifier = torch.nn.Sequential(\n12\n(*list(original_model.classifier.\n13\nchildren())[:-1]))\n14\nself.num_feats = 4096\n15\n16\ndef forward(self, x):\n17\nf = self.features(x)\n18\nf = f.view(f.size(0), -1)\n# (1, 4096) -> (4096,)\n19\nf = self.classifier(f)\n20\nprint (f.data.size())\n21\nreturn f\nFIGURE 7.10: PyTorch code snippet for extracting the fc7 layer from a pre-trained VGG19\nCNN model.\n1. The value of the parameter pretrained should be True in order to instruct PyTorch to\nload an ImageNet trained weights.\n2. The value of self.features should be original_model.features . This is because we like to\nretain the layers of the original classi\ufb01er (original_model).\n3. The value of self.num_feats should be 4096 . (Why?)\n4. The value of f should be self.classi\ufb01er(f) since our newly created CNN has to be in-\nvoked to generate the FV.\n220\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION\n\u25a0"
  },
  {
    "id": "PRB-167",
    "chapter": "",
    "question": "We are still referring to Table (9.3) and using the skeleton code provided in Fig. (7.5)\nto derive a new CNN entitled ResNetBottom from the ResNet34 CNN, to extract a 512-\ndimensional FV for a given input image. Complete the code as follows:\n1. The value of self.features in line 7.\n2. The forward method in line 11.\n1 import torchvision.models as models\n2 res_model = models.resnet34(pretrained=True)\n3 class ResNetBottom(torch.nn.Module):\n4\ndef __init__(self, original_model):\n5\nsuper(ResNetBottom, self).__init__()\n6\nself.features = [???]\n7\n8\ndef forward(self, x):\n9\nx = [???]\n10\nx = x.view(x.size(0), -1)\n11\nreturn x\nFIGURE 7.5: PyTorch code skeleton for extracting a 512-dimensional FV from a pre-trained\nResNet34 CNN model.\n211\n7.2. PROBLEMS",
    "solution": "1. Line number 7 in Fig. (7.11) takes care of extracting the the correct 512-D FV.\n2. Line number 11 in Fig. (7.11) extracts the correct 512-D FV by creating a sequential\nmodule on top of the existing features.\n1 import torchvision.models as models\n2 res_model = models.resnet34(pretrained=True)\n3 class ResNetBottom(torch.nn.Module):\n4 def __init__(self, original_model):\n5\nsuper(ResNetBottom, self).__init__()\n6\nself.features = [???]\n7 def forward(self, x):\n8\nx = [???]\n9\nx = x.view(x.size(0), -1)\n10\nreturn x\nFIGURE 7.11: PyTorch code snippet for extracting the fc7 layer from a pre-trained VGG19\nCNN model.\n\u25a0"
  },
  {
    "id": "PRB-168",
    "chapter": "",
    "question": "Still referring to Table (9.3), the PyTorch based pseudo code snippet in Fig. (7.6) returns\nthe 512-dimensional FV from the modi\ufb01ed ResNet34 CNN, given a 3-channel RGB image\nas an input.\n1 import torchvision.models as models\n2 from torchvision import transforms\n3 ...\n4\n5 test_trans = transforms.Compose([\n6\ntransforms.Resize(imgnet_size),\n7\ntransforms.ToTensor(),\n8\ntransforms.Normalize([0.485, 0.456, 0.406],\n9\n[0.229, 0.224, 0.225])])\n10\n11 def ResNet34FE(image, model):\n12\nf=None\n13\nimage = test_trans(image)\n14\nimage = Variable(image, requires_grad=False).cuda()\n15\nimage= image.cuda()\n16\nf = model(image)\n17\nf = f.view(f.size(1), -1)\n18\nprint (\"Size : {}\".format(f.shape))\n19\nf = f.view(f.size(1),-1)\n20\nprint (\"Size : {}\".format(f.shape))\n21\nf =f.cpu().detach().numpy()[0]\n22\nprint (\"Size : {}\".format(f.shape))\n23\nreturn f\nFIGURE 7.6: PyTorch code skeleton for extracting a 512-dimensional FV from a pre-trained\nResNet34 CNN model.\nAnswer the following questions regarding the code in Fig. (7.6):\n212\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION\n1. What is the purpose of test_trans in line 5?\n2. Why is the parameter requires_grad set to False in line 14?\n3. What is the purpose of f.cpu() in line 23?\n4. What is the purpose of detach() in line 23?\n5. What is the purpose of numpy()[0] in line 23?\n7.2.2\nFine-tuning CNNs",
    "solution": "1. Transforms are incorporated into deep learning pipelines in order to apply one or more\noperations on images which are represented as tensors. Different transforms are usu-\nally utilized during training and inference. For instance, during training we can use a\ntransform to augment our data-set, while during inference our transform may be lim-\nited only to normalizing an image. PyTorch allows the use of transforms either during\ntraining or inference. The purpose of test_trans in line 5 is to normalize the data.\n221\n7.3. SOLUTIONS\n2. The parameter requires_grad is set to False in line 14 since during inference the com-\nputation of gradients is obsolete.\n3. The purpose of f.cpu() in line 11 is to move a tensor that was allocated on the GPU\nto the CPU. This may be required if we want to apply a CPU-based method from the\nPython numpy package on a Tensor that does not live in the CPU.\n4. detach() in line 23 returns a newly created tensor without affecting the current tensor.\nIt also detaches the output from the current computational graph, hence no gradient is\nbackpropagated for this speci\ufb01c variable.\n5. The purpose of numpy()[0] in line 23 is to convert the variable (an array) to a numpy\ncompatible variable and also to retrieve the \ufb01rst element of the array.\n\u25a0\n7.3.2\nFine-tuning CNNs"
  },
  {
    "id": "PRB-169",
    "chapter": "",
    "question": "De\ufb01ne the term \ufb01ne-tuning (FT) of an ImageNet pre-trained CNN.",
    "solution": "The term \ufb01ne-tuning (FT) of an ImageNet pre-trained CNN refers to the method by which\none or more of the weights of the CNN are re-trained on a new target data-set, which may or\nmay-not have similarities with the ImageNet data-set.\n\u25a0"
  },
  {
    "id": "PRB-170",
    "chapter": "",
    "question": "Describe three different methods by which one can \ufb01ne-tune an ImageNet pre-trained\nCNN.",
    "solution": "1. Replacing and re-training only the classi\ufb01er (usually the FC layer) of the ImageNet\npre-trained CNN, on a target data-set.\n2. FT all of the layers of the ImageNet pre-trained CNN, on a target data-set.\n3. FT part of the layers of the ImageNet pre-trained CNN, on a target data-set.\n\u25a0"
  },
  {
    "id": "PRB-171",
    "chapter": "",
    "question": "Melanoma is a lethal form of malignant skin cancer, frequently misdiagnosed as a benign\nskin lesion or even left completely undiagnosed.\nIn the United States alone, melanoma accounts for an estimated 6, 750 deaths per annum\n[6]. With a 5-year survival rate of 98%, early diagnosis and treatment is now more likely\nand possibly the most suitable means for melanoma related death reduction. Dermoscopy\nimages, shown in Fig. (7.7) are widely used in the detection and diagnosis of skin lesions.\nDermatologists, relying on personal experience, are involved in a laborious task of manually\nsearching dermoscopy images for lesions.\nTherefore, there is a very real need for automated analysis tools, providing assistance to\nclinicians screening for skin metastases. In this question, you are tasked with addressing\nsome of the fundamental issues DL researchers face when building deep learning pipelines.\nAs suggested in [3], you are going to use ImageNet pre-trained CNN to resolve a classi\ufb01ca-\ntion task.\n213\n7.2. PROBLEMS\nFIGURE 7.7: Skin lesion categories. An exemplary visualization of melanoma.\n1. Given that the skin lesions fall into seven distinct categories, and you are training us-\ning cross-entropy loss, how should the classes be represented so that a typical PyTorch\ntraining loop will successfully converge?\n2. Suggest several data augmentation techniques to augment the data.\n3. Write a code snippet in PyTorch to adapt the CNN so that it can predict 7 classes\ninstead of the original source size of 1000.\n4. In order to \ufb01ne tune our CNN, the (original) output layer with 1000 classes was\nremoved and the CNN was adjusted so that the (new) classi\ufb01cation layer comprised\nseven softmax neurons emitting posterior probabilities of class membership for each\nlesion type.\n7.2.3\nNeural style transfer, NST\nBefore attempting the problems in the section, you are strongly recommended to read\nthe paper: \u201cA Neural Algorithm of Artistic Style\u201d [2].",
    "solution": "222\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION\n1. The categories have to be represented numerically. One such option is presented in Code\n(7.1).\n1 'MEL': 0, 'NV': 1, 'BCC': 2, 'AKIEC': 3, 'BKL': 4, 'DF': 5,\n'VASC': 6\n\ufffd\u2192\nCODE 7.1: The seven categories of skin lesions.\n2. Several possible augmentations are presented in Code (7.2). It is usually, that by trial\nand error one \ufb01nds the best possible augmentation for a target data-set. However, meth-\nods such as AutoAugment may render the manual selection of augmentations obsolete.\n1 self.transforms = []\n2 if rotate:\n3\nself.transforms.append(RandomRotate())\n4 if flip:\n5\nself.transforms.append(RandomFlip())\n6 if brightness != 0:\n7\nself.transforms.append(PILBrightness())\n8 if contrast != 0:\n9\nself.transforms.append(PILContrast())\n10 if colorbalance != 0:\n11\nself.transforms.append(PILColorBalance())\n12 if sharpness != 0:\n13\nself.transforms.append(PILSharpness())\nCODE 7.2: Pseudeo code for augmentations.\n3. In contrast to the ResNet CNN which ends by an FC layer, the ImageNet pre-trained\nDPN CNN family, in this case the pretrainedmodels.dpn107, terminated by a Conv2d\n223\n7.3. SOLUTIONS\nlayer and hence must be adapted accordingly if one wishes to change the number fo\nclasses from the 1000 (ImageNet) classes to our skin lession classi\ufb01cation problem (7\nclasses). Line 7 in Code (7.3) demonstrated this idiom.\n1 import torch\n2 class Dpn107Finetune(nn.Module):\n3 def __init__(self, num_classes: int, net_kwards):\n4\nsuper().__init__()\n5\nself.net = pretrainedmodels.dpn107(**net_kwards)\n6\nself.net.__name__= str (self.net)\n7\nself.net.classifier = torch.nn.Conv2d(2688,\nnum_classes,kernel_size=1)\n\ufffd\u2192\n8\nprint(self.net)\nCODE 7.3: Change between 1000 classes to 7 classes for the ImageNet pre-trained DPN\nCNN family.\n\u25a0\n7.3.3\nNeural style transfer"
  },
  {
    "id": "PRB-172",
    "chapter": "",
    "question": "Brie\ufb02y describe how neural style transfer (NST) [2] works.",
    "solution": "The images are: a content image, a style image and lastly a combined image.\n\u25a0"
  },
  {
    "id": "PRB-173",
    "chapter": "",
    "question": "Complete the sentence: When using the VGG-19 CNN [8] for neural-style transfer,\nthere different images are involved. Namely they are: [...], [...] and [...].\n214\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION",
    "solution": "The algorithm presented in the paper suggests how to combine the content a \ufb01rst image\nwith the style of a second image to generate a third, stylized image using CNNs.\n\u25a0"
  },
  {
    "id": "PRB-174",
    "chapter": "",
    "question": "Refer to Fig. 7.8 and answer the following questions:\nFIGURE 7.8: Artistic style transfer using the style of Francis Picabia\u2019s Udnie painting.\n1. Which loss is being utilized during the training process?\n2. Brie\ufb02y describe the use of activations in the training process.",
    "solution": "The answers are as follows:\n224\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION\n1. The training pipeline uses a combined loss which consists of a weighted average of the\nstyle loss and the content loss.\n2. Different CNN layers at different levels are utilized to capture both \ufb01ne-grained styl-\nistic details as well as larger stylistic features.\n\u25a0"
  },
  {
    "id": "PRB-175",
    "chapter": "",
    "question": "Still referring to Fig. 7.8:\n1. How are the activations utilized in comparing the content of the content image to the\ncontent of the combined image?.\n2. How are the activations utilized in comparing the style of the content image to the\n215\n7.3. SOLUTIONS\nstyle of the combined image?.",
    "solution": "1. The content loss is the mean square error (MSE) calculated as the difference between\nthe CNN activations of the last convolutional layer of both the content image and the\nstyle images.\n2. The style loss amalgamates the losses of several layers together. For each layer, the gram\nmatrix (see 7.2) for the activations at that layer is obtained for both the style and the\ncombined images. Then, just like in the content loss, the MSE of the Gram matrices is\ncalculated.\n\u25a0"
  },
  {
    "id": "PRB-176",
    "chapter": "",
    "question": "Still referring to Fig. 7.8. For a new style transfer algorithm, a data scientist extracts a\nfeature vector from an image using a pre-trained ResNet34 CNN (7.9).\n1 import torchvision.models as models\n2 ...\n3 res_model = models.resnet34(pretrained=True)\nFIGURE 7.9: PyTorch declaration for a pre-trained ResNet34 CNN.\nHe then de\ufb01nes the cosine similarity between two vectors:\nu = {u1, u2, . . . , uN} and :\nv = {v1, v2, . . . , vN}\nas:\nsim(u, v) = u \u00b7 v\n|u||v| =\n\ufffdN\ni=1 uivi\n\ufffd\ufffd\ufffdN\ni=1 u2\ni\n\ufffd \ufffd\ufffdN\ni=1 v2\ni\n\ufffd\nThus, the cosine similarity between two vectors measures the cosine of the angle between\nthe vectors irrespective of their magnitude. It is calculated as the dot product of two numeric\nvectors, and is normalized by the product of the length of the vectors.\nAnswer the following questions:\n1. De\ufb01ne the term Gram matrix.\n2. Explain in detail how vector similarity is utilised in the calculation of the Gram mat-\nrix during the training of NST.\n7.3\nSolutions\n7.3.1\nCNN as Fixed Feature Extractor\n216\nChapter 7\nDEEP LEARNING: CNN FEATURE EXTRACTION",
    "solution": "For each feature map, a feature vector is extracted. The gram matrix captures the correl-\nation between these feature vectors which is then being used in the loss function. Provided a\nlist of feature vectors extracted from the images, u1, . . . , uk \u2208 Rn, the Gram matrix is de\ufb01ned\nas:\n\uf8eb\n\uf8ec\n\uf8ec\n\uf8ec\n\uf8ed\nu1 \u00b7 u1\n. . .\nu1 \u00b7 uk\n...\n. . .\n...\nuk \u00b7 u1\n. . .\nuk \u00b7 uk\n\uf8f6\n\uf8f7\n\uf8f7\n\uf8f7\n\uf8f8\n(7.2)\nThe Gram matrix\n\u25a0\nReferences\n[1]\nB. Chu et al. \u2018Best Practices for Fine-Tuning Visual Classi\ufb01ers to New Domains\u2019.\nIn: Computer Vision \u2013 ECCV 2016 Workshops. Ed. by G. Hua and H. J\u00e9gou. Cham:\nSpringer International Publishing, 2016, pp. 435\u2013442 (cit. on p. 206).\n225\nREFERENCES\n[2]\nL. A. Gatys, A. S. Ecker and M. Bethge. A Neural Algorithm of Artistic Style. 2015.\narXiv: 1508.06576 [cs.CV] (cit. on p. 214).\n[3]\nS. Kornblith, J. Shlens and Q. V. Le. Do Better ImageNet Models Transfer Better?\n2018. arXiv: 1805.08974 [cs.CV] (cit. on pp. 206, 213).\n[4]\nA. Krizhevsky. One weird trick for parallelizing convolutional neural networks. 2014.\narXiv: 1404.5997 [cs.NE] (cit. on p. 207).\n[5]\nV. Nair and G. E. Hinton. \u2018Recti\ufb01ed Linear Units Improve Restricted Boltzmann\nMachines\u2019. In: ICML 10. Madison, WI, USA: Omnipress, 2010, pp. 807\u2013814 (cit.\non pp. 208, 218).\n[6]\nA. J. R. L. Siegel K. D. Miller. \u2018Cancer statistics 2016\u2019. In: CA: a cancer journal for\nclinicians 66,1 (2016), pp. 7\u201330 (cit. on p. 213).\n[7]\nRussakovsky. \u2018ImageNet Large Scale Visual Recognition Challenge\u2019. In: Journal\nof Computer Vision 115.3 (Apr. 2015), pp. 211\u2013252 (cit. on pp. 206, 207).\n[8]\nK. Simonyan and A. Zisserman. Very Deep Convolutional Networks for Large-Scale\nImage Recognition. 2014. arXiv: 1409.1556 [cs.CV] (cit. on pp. 207\u2013209, 214).\n226\nCHAPTER\n8\nDEEP LEARNING\nIt is the weight, not numbers of experiments that is to be regarded.\n\u2014 Isaac Newton.\nContents\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231\nProblems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231\nCross Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231\nCV approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231\nK-Fold CV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232\nStrati\ufb01cation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233\nLOOCV\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234\nConvolution and correlation . . . . . . . . . . . . . . . . . . . . . . . . . 234\nThe convolution operator . . . . . . . . . . . . . . . . . . . . . . 234\nThe correlation operator . . . . . . . . . . . . . . . . . . . . . . . 235\nPadding and stride . . . . . . . . . . . . . . . . . . . . . . . . . . 236\nKernels and \ufb01lters\n. . . . . . . . . . . . . . . . . . . . . . . . . . 239\nConvolution and correlation in python\n. . . . . . . . . . . . . . 240\nSeparable convolutions\n. . . . . . . . . . . . . . . . . . . . . . . 241\nSimilarity measures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\nImage, text similarity . . . . . . . . . . . . . . . . . . . . . . . . . 241\nJacard similarity\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 244\nThe Kullback-Leibler Distance\n. . . . . . . . . . . . . . . . . . . 244\nMinHash . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\nPerceptrons\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246\nThe Single Layer Perceptron\n. . . . . . . . . . . . . . . . . . . . 246\nThe Multi Layer Perceptron . . . . . . . . . . . . . . . . . . . . . 247\nActivation functions in perceptrons\n. . . . . . . . . . . . . . . . 248\nBack-propagation in perceptrons . . . . . . . . . . . . . . . . . . 249\nThe theory of perceptrons . . . . . . . . . . . . . . . . . . . . . . 251\nLearning logical gates\n. . . . . . . . . . . . . . . . . . . . . . . . 251\nActivation functions (recti\ufb01cation) . . . . . . . . . . . . . . . . . . . . . 253\nSigmoid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253\nTanh\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256\nReLU . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258\nSwish . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\nPerformance Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260\nConfusion matrix, precision, recall . . . . . . . . . . . . . . . . . 260\nROC-AUC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261\nNN Layers, topologies, blocks . . . . . . . . . . . . . . . . . . . . . . . . 263\nCNN arithmetics . . . . . . . . . . . . . . . . . . . . . . . . . . . 263\nDropout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266\nConvolutional Layer . . . . . . . . . . . . . . . . . . . . . . . . . 268\nPooling Layers\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\nMaxPooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\nBatch normalization, Gaussian PDF . . . . . . . . . . . . . . . . 273\nThe Gaussian distribution . . . . . . . . . . . . . . . . . . . . . . 274\nBN\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274\nTheory of CNN design . . . . . . . . . . . . . . . . . . . . . . . . 276\nCNN residual blocks . . . . . . . . . . . . . . . . . . . . . . . . . 279\nTraining, hyperparameters . . . . . . . . . . . . . . . . . . . . . . . . . . 280\nHyperparameter optimization\n. . . . . . . . . . . . . . . . . . . 280\nLabelling and bias\n. . . . . . . . . . . . . . . . . . . . . . . . . . 282\nValidation curve ACC . . . . . . . . . . . . . . . . . . . . . . . . 283\nValidation curve Loss\n. . . . . . . . . . . . . . . . . . . . . . . . 284\nInference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286\n228\nChapter 8\nDEEP LEARNING\nOptimization, Loss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286\nStochastic gradient descent, SGD . . . . . . . . . . . . . . . . . . 286\nMomentum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287\nNorms, L1, L2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288\nSolutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289\nCross Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289\nCV approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289\nK-Fold CV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289\nStrati\ufb01cation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\nLOOCV\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\nConvolution and correlation . . . . . . . . . . . . . . . . . . . . . . . . . 291\nThe convolution operator . . . . . . . . . . . . . . . . . . . . . . 291\nThe correlation operator . . . . . . . . . . . . . . . . . . . . . . . 291\nPadding and stride . . . . . . . . . . . . . . . . . . . . . . . . . . 292\nKernels and \ufb01lters\n. . . . . . . . . . . . . . . . . . . . . . . . . . 293\nConvolution and correlation in python\n. . . . . . . . . . . . . . 294\nSeparable convolutions\n. . . . . . . . . . . . . . . . . . . . . . . 295\nSimilarity measures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296\nImage, text similarity . . . . . . . . . . . . . . . . . . . . . . . . . 296\nJacard similarity\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 297\nThe Kullback-Leibler Distance\n. . . . . . . . . . . . . . . . . . . 297\nMinHash . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298\nPerceptrons\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\nThe Single Layer Perceptron\n. . . . . . . . . . . . . . . . . . . . 299\nThe Multi Layer Perceptron . . . . . . . . . . . . . . . . . . . . . 300\nActivation functions in perceptrons\n. . . . . . . . . . . . . . . . 301\nBack-propagation in perceptrons . . . . . . . . . . . . . . . . . . 301\nThe theory of perceptrons . . . . . . . . . . . . . . . . . . . . . . 304\nLearning logical gates\n. . . . . . . . . . . . . . . . . . . . . . . . 305\nActivation functions (recti\ufb01cation) . . . . . . . . . . . . . . . . . . . . . 306\n229\nSigmoid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306\nTanh\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310\nReLU . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314\nSwish . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315\nPerformance Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316\nConfusion matrix, precision, recall . . . . . . . . . . . . . . . . . 316\nROC-AUC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316\nNN Layers, topologies, blocks . . . . . . . . . . . . . . . . . . . . . . . . 318\nCNN arithmetics . . . . . . . . . . . . . . . . . . . . . . . . . . . 318\nDropout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319\nConvolutional Layer . . . . . . . . . . . . . . . . . . . . . . . . . 321\nPooling Layers\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 322\nMaxPooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322\nBatch normalization, Gaussian PDF . . . . . . . . . . . . . . . . 324\nThe Gaussian distribution . . . . . . . . . . . . . . . . . . . . . . 324\nBN\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325\nTheory of CNN design . . . . . . . . . . . . . . . . . . . . . . . . 326\nCNN residual blocks . . . . . . . . . . . . . . . . . . . . . . . . . 326\nTraining, hyperparameters . . . . . . . . . . . . . . . . . . . . . . . . . . 327\nHyperparameter optimization\n. . . . . . . . . . . . . . . . . . . 327\nLabelling and bias\n. . . . . . . . . . . . . . . . . . . . . . . . . . 328\nValidation curve ACC . . . . . . . . . . . . . . . . . . . . . . . . 329\nValidation curve Loss\n. . . . . . . . . . . . . . . . . . . . . . . . 329\nInference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330\nOptimization, Loss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331\nStochastic gradient descent, SGD . . . . . . . . . . . . . . . . . . 331\nMomentum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\nNorms, L1, L2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n230\nChapter 8\nDEEP LEARNING\n8.1\nIntroduction\nI\nT was Alex Krizhevsky who \ufb01rst demonstrated that a convolutional neural\nnetwork (CNN) can be effectively trained on the ImageNet large scale visual\nrecognition challenge. A CNN automatically provides some degree of trans-\nlation and assumes that we wish to learn \ufb01lters, in a data-driven fashion, as\na means to extract features describing the inputs. CNNs are applied to numerous com-\nputer vision, imaging, and computer graphics tasks as in [24], [23], [15], [5]. Further-\nmore, they have become extremely popular, and novel architectures and algorithms\nare continually popping up overnight.\n8.2\nProblems\n8.2.1\nCross Validation\nOn the signi\ufb01cance of cross validation and strati\ufb01cation in particular, refer to \u201cA study\nof cross-validation and bootstrap for accuracy estimation and model selection\u201d [17].\nCV approaches"
  },
  {
    "id": "PRB-177",
    "chapter": "",
    "question": "Fig (8.1) depicts two different cross-validation approaches. Name them.\n1\n2\n3\n4\n5\n6\n7\n8\n10\n9\n1\n2\n3\n4\n5\n6\n7\n8\n10\n9\n1\n2\n3\n4\n5\n6\n7\n8\n10\n9\nTRAIN\nVAL\nFIGURE 8.1: Two CV approaches\n231\n8.2. PROBLEMS",
    "solution": "The \ufb01rst approach is a leave-one-out CV (LOOCV) and the second is a K-fold cross-\nvalidation approach.\n\u25a0"
  },
  {
    "id": "PRB-178",
    "chapter": "",
    "question": "1. What is the purpose of the following Python code snippet 8.2 ?\n1 skf = StratifiedKFold(y, n_folds=5, random_state=989,\nshuffle=True)\n\ufffd\u2192\nFIGURE 8.2: Strati\ufb01ed K-fold\n2. Explain the bene\ufb01ts of using the K-fold cross validation approach.\n3. Explain the bene\ufb01ts of using the Strati\ufb01ed K-fold cross validation approach.\n4. State the difference between K-fold cross validation and strati\ufb01ed cross validation.\n5. Explain in your own words what is meant by \u201cWe adopted a 5-fold cross-validation\napproach to estimate the testing error of the model\u201d.\nK-Fold CV",
    "solution": "Cross Validation is a cornerstone in machine learning, allowing data scientists to take\nfull gain of restricted training data. In classi\ufb01cation, effective cross validation is essential to\nmaking the learning task ef\ufb01cient and more accurate. A frequently used form of the technique\nis identi\ufb01ed as K-fold cross validation. Using this approach, the full data set is divided into K\nrandomly selected folds, occasionally strati\ufb01ed, meaning that each fold has roughly the\nsame class distribution as the overall data set. Subsequently, for each fold, all the other\n(K \u2212 1) folds are used for training, while the present fold is used for testing. This process\nguarantees that sets used for testing, are not used by a classi\ufb01er that also saw it during\ntraining.\n\u25a0\nK-Fold CV\n289\n8.3. SOLUTIONS"
  },
  {
    "id": "PRB-179",
    "chapter": "",
    "question": "True or False: In a K-fold CV approach, the testing set is completely excluded from the\nprocess and only the training and validation sets are involved in this approach.",
    "solution": "True. We never utilize the test set during a K-fold CV process.\n\u25a0"
  },
  {
    "id": "PRB-180",
    "chapter": "",
    "question": "True or False: In a K-fold CV approach, the \ufb01nal test error is:\nCV(k) = 1\nk\nk\n\ufffd\ni=1\nMSEi\n(8.1)\n232\nChapter 8\nDEEP LEARNING",
    "solution": "True. This is the average of the individual errors of K estimates of the test error:\nMSE1, . . . , MSEk\n(8.43)\n\u25a0"
  },
  {
    "id": "PRB-181",
    "chapter": "",
    "question": "Mark all the correct choices regarding a cross-validation approach:\n(i) A 5-fold cross-validation approach results in 5-different model instances being \ufb01tted.\n(ii) A 5-fold cross-validation approach results in 1 model instance being \ufb01tted over and\nover again 5 times.\n(iii) A 5-fold cross-validation approach results in 5-different model instances being \ufb01tted\nover and over again 5 times.\n(iv) Uses K-different data-folds.",
    "solution": "The correct answer is: A 5-fold cross-validation approach results in 5-different model in-\nstances being \ufb01tted. It is a common misconception to think that in a K-fold approach the same\nmodel instance is repeatedly used. We must create a new model instance in each fold.\n\u25a0"
  },
  {
    "id": "PRB-182",
    "chapter": "",
    "question": "Mark all the correct choices regarding the approach that should be taken to compute the\nperformance of K-fold cross-validation:\n(i) We compute the cross-validation performance as the arithmetic mean over the K per-\nformance estimates from the validation sets.\n(ii) We compute the cross-validation performance as the best one over the K performance\nestimates from the validation sets.\nStratification",
    "solution": "The correct answer is: we compute the cross-validation performance as the arithmetic\nmean over the K performance estimates from the validation sets.\n\u25a0\nStratification"
  },
  {
    "id": "PRB-183",
    "chapter": "",
    "question": "A data-scientist who is interested in classifying cross sections of histopathology image\nslices (8.3) decides to adopt a cross-validation approach he once read about in a book. Name\nthe approach from the following options:\n233\n8.2. PROBLEMS\n1st\n2nd\n3rd\nK-fold CV\nVAL FOLD\nTRAIN FOLD\nFIGURE 8.3: A speci\ufb01c CV approach\n(i) 3-fold CV\n(ii) 3-fold CV with strati\ufb01cation\n(iii) A (repeated) 3-fold CV\nLOOCV",
    "solution": "The correct answer is: 3-fold CV. A k-fold cross-validation is a special case of cross-\nvalidation where we iterate over a dataset set k times. In each round, we split the dataset\ninto k parts: one part is used for validation, and the remaining k \u2212 1 parts are merged into\na training subset for model evaluation. Strati\ufb01cation is used to balance the classes in the\ntraining and validation splits in cases where the corpus is imbalanced.\n\u25a0\nLOOCV"
  },
  {
    "id": "PRB-184",
    "chapter": "",
    "question": "1. True or false: The leave-one-out cross-validation (LOOCV) approach is a sub-case of\nk-fold cross-validation wherein K equals N, the sample size.\n2. True or false: It is always possible to \ufb01nd an optimal value n, K = n in K-fold\ncross-validation.\n8.2.2\nConvolution and correlation\nThe convolution operator",
    "solution": "1. True: In (LOOCV) K = N the full sample size.\n2. False: There is no way of a-priori \ufb01nding an optimal value for K, and the relationship\n290\nChapter 8\nDEEP LEARNING\nbetween the actual sample size and the resulting accuracy is unknown.\n\u25a0\n8.3.2\nConvolution and correlation\nThe convolution operator"
  },
  {
    "id": "PRB-185",
    "chapter": "",
    "question": "Equation 8.2 is commonly used in image processing:\n(f \u2217 g)(t) =\n\ufffd \u221e\n\u2212\u221e f(\u03c4)g(t \u2212 \u03c4)d\u03c4\n(8.2)\n234\nChapter 8\nDEEP LEARNING\n1. What does equation 8.2 represent?\n2. What does g(t) represent?",
    "solution": "1. This is the de\ufb01nition of a convolution operation on the two signals f and g.\n2. In image processing, the term g(t) represents a \ufb01ltering kernel.\n\u25a0"
  },
  {
    "id": "PRB-186",
    "chapter": "",
    "question": "A data-scientist assumes that:\ni A convolution operation is both linear and shift invariant.\nii A convolution operation is just like correlation, except that we \ufb02ip over the \ufb01lter before\napplying the correlation operator.\niii The convolution operation reaches a maximum, only in cases where the \ufb01lter is mostly\nsimilar to a speci\ufb01c section of the input signal.\nIs he right in assuming so? Explain in detail the meaning of these statements.\nThe correlation operator",
    "solution": "1. True. These operations have two key features: they are shift invariant, and they are\nlinear. Shift invariance means that we perform the same operation at every point in the\nimage. Linearity means that this operation is linear, that is, we replace every pixel with\na linear combination of its neighbours\n2. True. See for instance Eq. (8.3).\n3. True.\n\u25a0\nThe correlation operator"
  },
  {
    "id": "PRB-187",
    "chapter": "",
    "question": "Mark the correct choice(s):\n1. The cross-correlation operator is used to \ufb01nd the location where two different signals\nare most similar.\n2. The autocorrelation operator is used to \ufb01nd when a signal is similar to a delayed ver-\nsion of itself.",
    "solution": "1. True.\n2. True.\n\u25a0\n291\n8.3. SOLUTIONS"
  },
  {
    "id": "PRB-188",
    "chapter": "",
    "question": "A data-scientist provides you with a formulae for a discrete 2D convolution operation\n(8.3):\nf(x, y) \u2217 h(x, y) =\nM\u22121\n\ufffd\nm=0\nN\u22121\n\ufffd\nn=0\nf(m, n)h(x \u2212 m, y \u2212 n)\n(8.3)\n235\n8.2. PROBLEMS\nUsing only (8.3), write the equivalent 2D correlation operation.\nPadding and stride\nRecommended reading : \u201cA guide to convolution arithmetic for deep learning\u201d by Vincent\nDumoulin and Francesco Visin (2016) [22].",
    "solution": "A convolution operation is just like correlation, except that we \ufb02ip over the \ufb01lter both\nhorizontally and vertically before correlating.\nf(x, y) \u2297 h(x, y) =\nM\u22121\n\ufffd\nm=0\nN\u22121\n\ufffd\nn=0\nf \u2217(m, n)h(x + m, y + n)\n(8.44)\n\u25a0\nPadding and stride\nRecommended reading : \u201cA guide to convolution arithmetic for deep learning by Vincent\nDumoulin and Francesco Visin (2016)\u201d [22]."
  },
  {
    "id": "PRB-189",
    "chapter": "",
    "question": "When designing a convolutional neural network layer, one must also de\ufb01ne how the \ufb01lter\nor kernel slides through the input signal. This is controlled by what is known as the stride\nand padding parameters or modes. The two most commonly used padding approached in\nconvolutions are the VALID and the SAME modes. Given an input stride of 1:\n1. De\ufb01ne SAME\n2. De\ufb01ne VALID",
    "solution": "1. The Valid padding only uses values from the original input; however, when the data\nresolution is not a multiple of the stride, some boundary values are ignored entirely in\nthe feature calculation.\n2. The Same padding ensures that every input value is included, but also adds zeros near\nthe boundary which are not in the original input.\n\u25a0"
  },
  {
    "id": "PRB-190",
    "chapter": "",
    "question": "True or False: A valid convolution is a type of convolution operation that does not use\nany padding on the input.",
    "solution": "True. Contrast this with the two other types of convolution operations.\n\u25a0"
  },
  {
    "id": "PRB-191",
    "chapter": "",
    "question": "You are provided with a K \u00d7 K input signal and a \u03b8 \u00d7 \u03b8 \ufb01lter. The signal is subjected to\nthe valid padding mode convolution. What are the resulting dimensions?\narr = [\n0\n...\n0\n0\n...\n0\n0\n...\n0\n]\n(8.4)",
    "solution": "\ufffdK \u2212 \u03b8\n\u03b8\n\ufffd\n+ 1 \u00d7\n\ufffdn \u2212 \u03b8\n\u03b8\n\ufffd\n+ 1\n(8.45)\n\u25a0"
  },
  {
    "id": "PRB-192",
    "chapter": "",
    "question": "As depicted in (8.4), a \ufb01lter is applied to a \u00d73 input signal. Identify the correct choice\ngiven a stride of 1 and Same padding mode.\n236\nChapter 8\nDEEP LEARNING\nFIGURE 8.4: A padding approach",
    "solution": "292\nChapter 8\nDEEP LEARNING\nA is the correct choice.\n\u25a0"
  },
  {
    "id": "PRB-193",
    "chapter": "",
    "question": "As depicted in in (8.5), a \ufb01lter is applied to a 3 \u00d7 3 input signal, mark the correct choices\ngiven a stride of 1.\n(i) A represents a VALID convolution and B represents a SAME convolution\n(ii) A represents a SAME convolution and B represents a VALID convolution\n(iii) Both A and B represent a VALID convolution\n(iv) Both A and B represent a SAME convolution\n237\n8.2. PROBLEMS\nFIGURE 8.5: A padding approach",
    "solution": "A represents the VALID mode while B represents the SAME mode.\n\u25a0"
  },
  {
    "id": "PRB-194",
    "chapter": "",
    "question": "In this question we discuss the two most commonly used padding approaches in convo-\nlutions; VALID and SAME . Fig.8.6 presents python code for generating an input signal\narr001 and a convolution kernel filter001. The input signal, arr001 is \ufb01rst initialized to\nall zeros as follows:\narr001 = [\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n]\n(8.5)\n1. Without actually executing the code, determine what would be the resulting shape of\nthe convolve2d() operation.\n2. Manually compute the result of convolving the input signal with the provided \ufb01lter.\n3. Elaborate why the size of the resulting convolutions is smaller than the size of the\ninput signal.\n238\nChapter 8\nDEEP LEARNING\n1 import numpy\n2 import scipy.signal\n3\n4 arr01 = numpy.zeros((6, 6),dtype=float)\n5 print (arr01)\n6 arr01[:,:3] = 3.0\n7 arr01[:,3:] = 1.0\n8\n9 filter001 = numpy.zeros((3, 3), dtype=float)\n10 filter001[:,0] = 2.0\n11 filter001[:,2] = -2.0\n12\n13 output = scipy.signal.convolve2d(arr01, filter, mode='valid')\nFIGURE 8.6: Convolution and correlation in python\nKernels and filters",
    "solution": "1. The resulting output has a shape of 4 \u00d7 4.\n2. Convolution operation\n[[3. 3. 3. 1. 1. 1.]\n[3. 3. 3. 1. 1. 1.]\n[3. 3. 3. 1. 1. 1.]\n[3. 3. 3. 1. 1. 1.]\n[3. 3. 3. 1. 1. 1.]\n[3. 3. 3. 1. 1. 1.]]\n[[ 2.\n0. -2.]\n[ 2.\n0. -2.]\n[ 2.\n0. -2.]]\n3. By de\ufb01nition, convolutions in the valid mode, reduce the size of the resulting input\ntensor.\n[[\n0. -12. -12.\n0.]\n[\n0. -12. -12.\n0.]\n[\n0. -12. -12.\n0.]\n[\n0. -12. -12.\n0.]]\n\u25a0\nKernels and filters"
  },
  {
    "id": "PRB-195",
    "chapter": "",
    "question": "Equation 8.6 is the discrete equivalent of equation 8.2 which is frequently used in image\nprocessing:\n(y \u2217 k)[i, j] =\n\ufffd\nn\n\ufffd\nm\ny[i \u2212 n, j \u2212 m]k[n, m]\n(8.6)\n1. Given the following discrete kernel in the X direction, what would be the equivalent Y\ndirection?\nk = 1\n2\n\uf8ee\n\uf8f0 \u22121\n1\n\u22121\n1\n\uf8f9\n\uf8fb\n(8.7)\n2. Identify the discrete convolution kernel presented in (8.7).\n239\n8.2. PROBLEMS\nFIGURE 8.7: A 3 by 3 convolution kernel",
    "solution": "293\n8.3. SOLUTIONS\n1. Flipping by 180 degrees we get:\nk = 1\n2\n\uf8ee\n\uf8f0 \u22121\n\u22121\n1\n1\n\uf8f9\n\uf8fb\n(8.46)\n2. The Sobel \ufb01lter which is being frequently used for edge detection in classical computer\nvision.\n\u25a0"
  },
  {
    "id": "PRB-196",
    "chapter": "",
    "question": "Given an image of size w\u00d7h, and a kernel with width K, how many multiplications and\nadditions are required to convolve the image?\nConvolution and correlation in python",
    "solution": "The resulting complexity is given by:\nK2wh\n(8.47)\n\u25a0\nConvolution and correlation in python"
  },
  {
    "id": "PRB-197",
    "chapter": "",
    "question": "Fig.8.8 presents two built-in Python functions for the convolution and correlation oper-\nators.\n1 import nympy as np\n2 np.convolve(A,B,\"full\") # for convolution\n3 np.correlate(A,B,\"full\") # for cross correlation\nFIGURE 8.8: Convolution and correlation in python\n1. Implement the convolution operation from scratch in Python. Compare it with the\n240\nChapter 8\nDEEP LEARNING\nbuilt-in numpy equivalent.\n2. Implement the correlation operation using the implementation of the convolution op-\neration. Compare it with the built-in numpy equivalent.\nSeparable convolutions",
    "solution": "1. Convolution operation:\n294\nChapter 8\nDEEP LEARNING\n1 import numpy as np\n2 def convolution(A,B):\n3\nl_A = np.size(A)\n4\nl_B = np.size(B)\n5\nC = np.zeros(l_A + l_B -1)\n6\n7\nfor m in np.arange(l_A):\n8\nfor n in np.arange(l_B):\n9\nC[m+n] = C[m+n] + A[m]*B[n]\n10\n11\nreturn C\nFIGURE 8.52: Convolution and correlation in python\n2. Correlation operation:\n1 def crosscorrelation(A,B):\n2\nreturn convolution(np.conj(A),B[::-1])\nFIGURE 8.53: Convolution and correlation in python\n\u25a0\nSeparable convolutions"
  },
  {
    "id": "PRB-198",
    "chapter": "",
    "question": "The Gaussian distribution in the 1D and 2D is shown in Equations 8.8 and 8.9.\nG(x) =\n1\n\u221a\n2\u03c0\u03c3e\u2212 x2\n2\u03c32\n(8.8)\nG(x, y) =\n1\n2\u03c0\u03c32e\u2212 x2+y2\n2\u03c32\n(8.9)\nThe Gaussian \ufb01lter, is an operator that is used to blur images and remove detail and\nnoise while acting like a low-pass \ufb01lter. This is similar to the way a mean \ufb01lter works, but\nthe Gaussian \ufb01lter uses a different kernel. This kernel is represented with a Gaussian bell\nshaped bump.\nAnswer the following questions:\n1. Can 8.8 be used directly on a 2D image?\n2. Can 8.9 be used directly on a 2D image?\n3. Is the Gaussian \ufb01lter separable? if so, what are the advantages of separable \ufb01lters.\n8.2.3\nSimilarity measures\nImage, text similarity",
    "solution": "1. No.Since images are usually stored as discrete pixel values one would have to use a\ndiscrete approximation of the Gaussian function on the \ufb01ltering mask before performing\nthe convolution.\n2. No.\n295\n8.3. SOLUTIONS\n3. Yes it is separable, a factor that has great implications. For instance, separability means\nthat a 2D convolution can be reduced to two consequent 1D convolutions reducing the\ncomputational runtime from O (n2 m2) to O (n2 m).\n\u25a0\n8.3.3\nSimilarity measures\nImage, text similarity"
  },
  {
    "id": "PRB-199",
    "chapter": "",
    "question": "A data scientist extracts a feature vector from an image using a pre-trained ResNet34\nCNN (9.5).\n241\n8.2. PROBLEMS\n1 import torchvision.models as models\n2 ...\n3 res_model = models.resnet34(pretrained=True)\nFIGURE 8.9: PyTorch declaration for a pre-trained ResNet34 CNN (simpli\ufb01ed).\nHe then applies the following algorithm, entitled xxx on the image (9.2).\n1 void xxx(std::vector<float>& arr) {\n2 float mod = 0.0;\n3\nfor (float i : arr) {\n4\nmod += i * i;\n5\n}\n6 float mag = std::sqrt(mod);\n7 for (float & i : arr) {\n8\ni /= mag;\n9\n}\n10 }\nAn unknown algorithm in C++11\nFIGURE 8.10: listing\nWhich results in this vector (8.11):\n0.7766 0.4455 0.8342 0.6324 \u00b7 \u00b7 \u00b7\nk = 512\nValues after applying xxx to a k-element FV.\nFIGURE 8.11: A one-dimensional 512-element embedding for a single image from the Res-\nNet34 architecture.\nName the algorithm that he used and explain in detail why he used it.\n242\nChapter 8\nDEEP LEARNING",
    "solution": "The algorithm presented in (8.12) normalizes the input vector. This is usually done prior\nto applying any other method to the vector or before persisting a vector to a database of FVs.\n\u25a0"
  },
  {
    "id": "PRB-200",
    "chapter": "",
    "question": "Further to the above, the scientist then applies the following algorithm:\nAlgorithm 3: Algo 1\nData: Two vectors v1 and v2 are provided\nApply algorithm xxx on the two vectors\nRun algorithm 2\nAlgorithm 4: Algo 2\n1 float algo2(const std::vector<float>& v1, const\nstd::vector<float>& v2){\n\ufffd\u2192\n2\ndouble mul = 0;\n3\nfor (size_t i = 0; i < v1.size(); ++i){\n4\nmul += v1[i] * v2[i];\n5\n}\n6\nif (mul < 0) {\n7\nreturn 0;\n8\n}\n9 return mul;\n10 }\nFIGURE 8.12: An unknown algorithm\n1. Name the algorithm algo2 that he used and explain in detail what he used it for.\n2. Write the mathematical formulae behind it.\n3. What are the minimum and maximum values it can return?\n4. An alternative similarity measures between two vectors is:\nsimeuc(v1, v2) = \u2212||v1 \u2212 v2||.\n(8.10)\nName the measure.\n243\n8.2. PROBLEMS\nJacard similarity",
    "solution": "1. The algorithm presented in (8.1) is one of the most commonly used image similarity\nmeasures and is entitled cosine similarity. It can be applied to any pair of images.\n2. The mathematical formulae behind it is:\nThe cosine similarity between two vectors:\nu = {u1, u2, . . . , uN} and v = {v1, v2, . . . , vN} is de\ufb01ned as:\nsim(u, v) = u \u00b7 v\n|u||v| =\n\ufffdN\ni=1 uivi\n\ufffd\ufffd\ufffdN\ni=1 u2\ni\n\ufffd \ufffd\ufffdN\ni=1 v2\ni\n\ufffd\nThus, the cosine similarity between two vectors measures the cosine of the angle\nbetween the vectors irrespective of their magnitude. It is calculated as the dot product\nof two numeric vectors, and is normalized by the product of the length of the vectors.\n3. The minimum and maximum values it can return are 0 and 1 respectively. Thus, a\ncosine similarity value which is close to 1 indicated a very high similarity while that\nclose to 0 indicates a very low similarity.\n4. It represents the negative distance in Euclidean space between the vectors.\n296\nChapter 8\nDEEP LEARNING\n\u25a0\nJacard similarity"
  },
  {
    "id": "PRB-201",
    "chapter": "",
    "question": "1. What is the formulae for the Jaccard similarity [12] of two sets?:\n2. Explain the formulae in plain words.\n3. Find the Jacard similarity given the sets depicted in (8.13)\nFIGURE 8.13: Jaccard similarity.\n4. Compute the Jaccard similarity of each pair of the following sets:\ni 12, 14, 16, 18.\nii 11, 12, 13, 14, 15.\niii 11, 16, 17.\nThe Kullback-Leibler Distance",
    "solution": "1. The general formulae for the Jaccard similarity of two sets is given as follows:\nJ(A, B) = |A \u2229 B|\n|A \u222a B|\n2. That is, the ratio of the size of the intersection of A and B to the size of their union.\n3. The Jaccard similarity equals:\n2\n7\n4. Given (8.13)\nFor the three combinations of pairs above, we have\nJ({11, 16, 17}, {12, 14, 16, 18})\n=\n1\n6\nJ({11, 12, 13, 14, 15}, {11, 16, 17})\n=\n1\n7\nJ({11, 12, 13, 14, 15}, {12, 14, 16, 18})\n=\n2\n7\n\u25a0\nThe Kullback-Leibler Distance"
  },
  {
    "id": "PRB-202",
    "chapter": "",
    "question": "In this problem, you have to actually read 4 different papers, so you will probably not\nencounter such a question during an interview, however reading academic papers is an ex-\ncellent skill to master for becoming a DL researcher.\nRead the following papers which discuss aspects of the Kullback-Leibler divergence:\ni Bennet [2]\n244\nChapter 8\nDEEP LEARNING\nii Ziv [29]\niii Bigi [3]\niv Jensen [1]\nThe Kullback-Leibler divergence, which was discussed thoroughly in chap 4 is a meas-\nure of how different two probability distribution are. As noted, the KL divergence of the\nprobability distributions P, Q on a set X is de\ufb01ned as shown in Equation 8.11.\nDKL(P||Q) =\n\ufffd\nx\u2208X\nP(x)logP(x)\nQ(x)\n(8.11)\nNote however that since KL divergence is a non-symmetric information theoretical meas-\nure of distance of P from Q, then it is not strictly a distance metric. During the past years,\nvarious KL based distance measures (rather than divergence based) have been introduced in\nthe literature generalizing this measure.\nName each of the following KL based distances:\nDKLD1(P||Q) = DKL(P||Q) + DKL(Q||P)\n(8.12)\nDKLD2(P||Q) =\n\ufffd\nx\u2208X\n(P(x) \u2212 Q(x))logP(x)\nQ(x)\n(8.13)\nDKLD3(P||Q) = 1\n2\n\ufffd\nDKL\n\ufffd\nP||P + Q\n2\n\ufffd\n+ DKL\n\ufffd\nQ||P + Q\n2\n\ufffd\ufffd\n(8.14)\nDKLD4(P||Q) = max (DKL(P||Q) + DKL(Q||P))\n(8.15)\nMinHash\nRead the paper entitled Detecting near-duplicates for web crawling [12] and answer the\nfollowing questions.",
    "solution": "Each KLD corresponds to the de\ufb01nition of:\ni Jensen [1]\n297\n8.3. SOLUTIONS\nii Bennet [2]\niii Bigi [3]\niv Ziv [29]\n\u25a0\nMinHash\nRead the paper entitled Detecting near-duplicates for web crawling [12] and answer the\nfollowing questions."
  },
  {
    "id": "PRB-203",
    "chapter": "",
    "question": "What is the goal of hashing? Draw a simple HashMap of keys and values. Explain what\nis a collision and the notion of buckets. Explain what is the goal of MinHash.\n245\n8.2. PROBLEMS",
    "solution": "A Hashing function (8.54) maps a value into a constant length string that can be com-\npared with other hashed values.\nFIGURE 8.54: The idea of hashing\nThe idea behind hashing is that items are hashed into buckets, such that similar items\nwill have a higher probability of hashing into the same buckets.\nThe goal of MinHash is to compute the Jaccard similarity without actually computing the\nintersection and union of the sets, which would be slower. The main idea behind MinHash\nis to devise a signature scheme such that the probability that there is a match between the\nsignatures of two sets, S1 and S2, is equal to the Jaccard measure [12].\n\u25a0\n298\nChapter 8\nDEEP LEARNING"
  },
  {
    "id": "PRB-204",
    "chapter": "",
    "question": "What is Locality Sensitive Hashing or LSH?",
    "solution": "Locality-Sensitive Hashing (LSH) is a method which is used for determining which items\nin a given set are similar. Rather than using the naive approach of comparing all pairs of items\nwithin a set, items are hashed into buckets, such that similar items will be more likely to hash\ninto the same buckets.\n\u25a0"
  },
  {
    "id": "PRB-205",
    "chapter": "",
    "question": "Complete the sentence: LSH main goal is to [...] the probability of a colliding, for\nsimilar items in a corpus.\n8.2.4\nPerceptrons\nThe Single Layer Perceptron",
    "solution": "Maximise.\n\u25a0\n8.3.4\nPerceptrons\nThe Single Layer Perceptron"
  },
  {
    "id": "PRB-206",
    "chapter": "",
    "question": "1. complete the sentence: In a single-layer feed-forward NN, there are [...] input(s)\nand [...]. output layer(s) and no [...] connections at all.",
    "solution": "Answer: one, one, feedback.\n\u25a0"
  },
  {
    "id": "PRB-207",
    "chapter": "",
    "question": "In its simplest form, a perceptron (8.16) accepts only a binary input and emits a binary\noutput. The output, can be evaluated as follows:\noutput =\n\uf8f1\n\uf8f2\n\uf8f3\n0,\nif \ufffd\nj wjxj + b \u2264 0,\n1,\nif\n\ufffd\nj wjxj + b > 0\n.\n(8.16)\nWhere weights are denoted by wj and biases are denoted by b. Answer the following ques-\ntions:\n1. True or False: If such a perceptron is trained using a labelled corpus, for each parti-\ncipating neuron the values wj and b are learned automatically.\n2. True or False: If we instead use a new perceptron (sigmoidial) de\ufb01ned as follows:\n\u03c3(wx + b)\n(8.17)\n246\nChapter 8\nDEEP LEARNING\nwhere \u03c3 is the sigmoid function:\n\u03c3(z) =\n1\n1 + e\u2212z .\n(8.18)\nThen the new perceptron can process inputs ranging between 0 and 1 and emit output\nranging between 0 and 1.\n3. Write the cost function associated with the sigmoidial neuron.\n4. If we want to train the perceptron in order to obtain the best possible weights and\nbiases, which mathematical equation do we have to solve?\n5. Complete the sentence: To solve this mathematical equation, we have to apply [...]\n6. What does the following equation stands for?\n\u2207C = 1\nn\n\ufffd\nx\n\u2207Cx\n(8.19)\nWhere:\nCx = 1\n2\u2225y(x) \u2212 a(x, w, b)\u22252\n(8.20)\n7. Complete the sentence: Due to the time-consuming nature of computing gradients for\neach entry in the training corpus, modern DL libraries utilize a technique that gauges\nthe gradient by \ufb01rst randomly sampling a subset from the training corpus, and then\naveraging only this subset in every epoch. This approach is known as [...]. The actual\nnumber of randomly chosen samples in each epoch is termed [...]. The gradient itself\nis obtained by an algorithm known as [...].\nThe Multi Layer Perceptron",
    "solution": "1. True.\n2. True.\n3.\nC(w, b) = 1\n2n\n\ufffd\nx\n\u2225y(x) \u2212 a(x, w, b)\u22252\n(8.48)\nwhere w denotes the collection of all weights in the network, b all the biases, n is the\ntotal number of training inputs and a(x, w, b) is the vector of outputs from the network\nwhich has weights w, biases b and the input x.\n4.\narg min\nw,b C(w, b).\n(8.49)\n5. Gradient descent.\n299\n8.3. SOLUTIONS\n6. The gradient.\n7. Stochastic gradient descent. Batch size. Back-propagation.\n\u25a0\nThe Multi Layer Perceptron"
  },
  {
    "id": "PRB-208",
    "chapter": "",
    "question": "The following questions refer to the MLP depicted in (9.1).The inputs to the MLP in\n(9.1) are x1 = 0.9 and x2 = 0.7 respectively, and the weights w1 = \u22120.3 and w2 = 0.15\nrespectively. There is a single hidden node, H1. The bias term, B1 equals 0.001.\n247\n8.2. PROBLEMS\nx1\nH1\nx2\n\ufffd\nB1\nw1 =\n\u22120.3\nw2 =\n0.15\nout1\n0.001\nInputs\nHidden\nSum\nFIGURE 8.14: Several nodes in a MLP.\n1. We examine the mechanism of a single hidden node, H1. The inputs and weights go\nthrough a linear transformation. What is the value of the output (out1) observed at\nthe sum node?\n2. What is the value resulting from the application the sum operator?\n3. Verify the correctness of your results using PyTorch.\nActivation functions in perceptrons",
    "solution": "1. This operation is a dot product with the given weights. Therefore:\nout = x1 \u2217 w1 + x2 \u2217 w2 + b1 =\n0.9 \u2217 (\u22120.3) + 0.7 \u2217 0.15 = \u22120.164\n(8.50)\n2. This operation (sum) is a dot product with the given weights and with the given bias\nadded. Therefore:\nout1 = x1 \u2217 w1 + x2 \u2217 w2 + b1 =\n0.9 \u2217 (\u22120.3) + 0.7 \u2217 0.15 + 0.001 = \u22120.165\n(8.51)\n3. Code snippet 8.55 provides a pure PyTorch-based implementation of the MLP operation.\n1 import torch\n2 # .type(torch.FloatTensor)\n3 x= torch.tensor([0.9,0.7])\n4 w= torch.tensor([-0.3,0.15])\n5 B= torch.tensor([0.001])\n6 print (torch.sum(x*w))\n7 print (torch.sum(x*w) + B)\nFIGURE 8.55: MLP operations.\n\u25a0\n300\nChapter 8\nDEEP LEARNING\nActivation functions in perceptrons"
  },
  {
    "id": "PRB-209",
    "chapter": "",
    "question": "The following questions refer to the MLP depicted in (8.15).\n1. Further to the above, the ReLU non-linear activation function g(z) = max{0, z} is\napplied (8.15) to the output of the linear transformation. What is the value of the\noutput (out2) now?\nx1\nH1\nx2\ng(x1, x2)\n\ufffd\nB1\nw1 =\n\u22120.3\nw2 =\n0.15\nout1\nout2\n0.001\nInputs\nHidden\nActivation\nSum\nFIGURE 8.15: Several nodes in a MLP.\n248\nChapter 8\nDEEP LEARNING\n2. Con\ufb01rm your manual calculation using PyTorch tensors.\nBack-propagation in perceptrons",
    "solution": "1. Since by de\ufb01nition:\nfReLU(x) =\n\uf8f1\n\uf8f2\n\uf8f3\n1\nif x > 0\n0\nif x \u2264 0\n(8.52)\nAnd the output of the linear sum operation was \u22120.164 then, the output out2 = 0.\n2. Code snippet 8.56 provides a pure PyTorch-based implementation of the MLP operation.\n1 import torch\n2 x= torch.tensor([0.9,0.7])\n3 w= torch.tensor([-0.3,0.15])\n4 B= torch.tensor([0.001])\n5 print (torch.sum(x*w))\n6 print (torch.sum(x*w) + B)\n7 print (torch.relu(torch.sum(x*w + B)))\nFIGURE 8.56: MLP operations.\n\u25a0\nBack-propagation in perceptrons"
  },
  {
    "id": "PRB-210",
    "chapter": "",
    "question": "Your co-worker, an postgraduate student at M.I.T, suggests using the following activa-\ntion functions in a MLP. Which ones can never be back-propagated and why?\ni\nf(x) = |x|\n(8.21)\nii\nf(x) = x\n(8.22)\niii\nf(x) =\n\uf8f1\n\uf8f2\n\uf8f3\nx sin(1/x)\nif x \u0338= 0\n0\nif x = 0\n(8.23)\niv\nf(x) =\n\uf8f1\n\uf8f4\n\uf8f4\n\uf8f2\n\uf8f4\n\uf8f4\n\uf8f3\nx2\nx > 0\n\u2212x\nx < 0\n0\nx = 0\n(8.24)",
    "solution": "The answers are as follows:\n1. Non-differentiable at 0.\n2. Non-differentiable at 0.\n301\n8.3. SOLUTIONS\n3. Even though for x \u0338= 0:\nf \u2032(x) = sin 1\nx \u2212 1\nx cos 1\nx,\n(8.53)\nthe function is still non-differentiable at 0.\n4. Non-differentiable at 0.\n\u25a0"
  },
  {
    "id": "PRB-211",
    "chapter": "",
    "question": "You are provided with the following MLP as depicted in 8.16.\n249\n8.2. PROBLEMS\n\u03b80\n\u03b81\n\u03b82\nH1\nH2\nH3\n\u03b31\n\u03b32\nFIGURE 8.16: A basic MLP\nThe ReLU non-linear activation function g(z) = max{0, z} is applied to the hidden\nlayers H1...H3 and the bias term equals 0.001.\nAt a certain point in time it has the following values 8.17 all of which are belong to the\ntype torch.FloatTensor:\n1 import torch\n2 x= torch.tensor([0.9,0.7]) # Input\n3 w= torch.tensor([\n4 [-0.3,0.15],\n5 [0.32,-0.91],\n6 [0.37,0.47],\n7 ]) # Weights\n8 B= torch.tensor([0.002]) # Bias\nFIGURE 8.17: MLP operations.\n1. Using Python, calculate the output of the MLP at the hidden layers H1...H3.\n2. Further to the above, you discover that at a certain point in time that the weights\nbetween the hidden layers and the output layers \u03b31 have the following values:\n1 w1= torch.tensor([\n2 [0.15,-0.46,0.59],\n3 [0.10,0.32,-0.79],\n4 )\n250\nChapter 8\nDEEP LEARNING\nWhat is the value observed at the output nodes \u03b31..\u03b32?\n3. Assume now that a Softmax activation is applied to the output. What are the resulting\nvalues?\n4. Assume now that a cross-entropy loss is applied to the output of the Softmax.\nL = \u2212\n\ufffd\ni\n\u02c6yi log (yi)\n(8.25)\nWhat are the resulting values?\nThe theory of perceptrons",
    "solution": "1. Fig 8.57 uses a loop (inef\ufb01cient but easy to understand) to print the values:\n1 for i in range(0,w.size(0)):\n2 print (torch.relu(torch.sum(x*w[i]) + B))\n3 > tensor([0.])\n4 > tensor([0.])\n5 > tensor([0.6630])\nFIGURE 8.57: MLP operations- values.\n2. The values at each hidden layer are depicted in 8.58\n302\nChapter 8\nDEEP LEARNING\n0.0\n0.0\n0.6630\nOutput\nFIGURE 8.58: Hidden layer values, simple MLP.\n3. Fig 8.59 uses a loop (inef\ufb01cient but easy to understand) to print the values:\n1 x1= torch.tensor([0.0,0.0,0.6630])# Input\n2 w1= torch.tensor([\n3 [0.15,-0.46,0.59],\n4 [0.10,0.32,-0.79],\n5 ]).type(torch.FloatTensor) # Weights\n6 for i in range(0,w1.size(0)):\n7\nprint (torch.sum(x1*w1[i]))\n8 > tensor(0.3912)\n9 > tensor(-0.5238)\nFIGURE 8.59: MLP operations- values at the output.\n4. We can apply the Softmax function like so 8.60:\n303\n8.3. SOLUTIONS\n1 x1= torch.tensor([0.0,0.0,0.6630]) # Input\n2 w1= torch.tensor([\n3 [0.15,-0.46,0.59],\n4 [0.10,0.32,-0.79],\n5 ]).type(torch.FloatTensor) # Weights\n6 out1 = torch.tensor([[torch.sum(x1*w1[0]).item()],\n7 [torch.sum(x1*w1[1]).item()]])\n8 print (out1)\n9 yhat = torch.softmax(out1, dim=0)\n10 print (yhat)\n11 > tensor([[ 0.3912],\n12 [-0.5238]])\n13 > tensor([[0.7140],\n14 [0.2860]])\nFIGURE 8.60: MLP operations- Softmax.\n5. For the cross-entropy loss, we use the Softmax values and calculate the result as follows:\n\u22121.0 \u2217 log(0.7140) \u2212 0.0 \u2217 log(0.2860) = 1.31\n(8.54)\n\u25a0\nThe theory of perceptrons"
  },
  {
    "id": "PRB-212",
    "chapter": "",
    "question": "If someone is quoted saying:\nMLP networks are universal function approximators.\nWhat does he mean?",
    "solution": "He means that theoretically [6], a non-linear layer followed by a linear layer, can ap-\nproximate any non-linear function with arbitrary accuracy, provided that there are enough\nnon-linear neurons\n\u25a0"
  },
  {
    "id": "PRB-213",
    "chapter": "",
    "question": "True or False: the output of a perceptron is 0 or 1.",
    "solution": "\u25a0"
  },
  {
    "id": "PRB-214",
    "chapter": "",
    "question": "True or False: A multi-layer perceptron falls under the category of supervised machine\nlearning.",
    "solution": "\u25a0\n304\nChapter 8\nDEEP LEARNING"
  },
  {
    "id": "PRB-215",
    "chapter": "",
    "question": "True or False: The accuracy of a perceptron is calculated as the number of correctly\nclassi\ufb01ed samples divided by the total number of incorrectly classi\ufb01ed samples.\nLearning logical gates\n251\n8.2. PROBLEMS",
    "solution": "False. Divided by the training samples, not the number of incorrectly classi\ufb01ed samples. \u25a0\nLearning logical gates"
  },
  {
    "id": "PRB-216",
    "chapter": "",
    "question": "The following questions refer to the SLP depicted in (8.18). The weights in the SLP are\nw1 = 1 and w2 = 1 respectively. There is a single hidden node, H1. The bias term, B1 equals\n\u22122.5.\nx1\nH1\nx2\n\ufffd\nB1\nw1 =\n1\nw2 =\n1\nout1\n\u22122.5\nInputs\nHidden\nSum\nFIGURE 8.18: A single layer perceptron.\n1. Assuming the inputs to the SLP in (8.18) are\ni x1 = 0.0 and x2 = 0.0\nii x1 = 0.0 and x2 = 1.0\niii x1 = 1.0 and x2 = 0.0\niv x1 = 1.0 and x2 = 1.0\nWhat is the value resulting from the application the sum operator?\n2. Repeat the above, assuming now that the bias term B1 was amended and equals \u22120.25.\n3. De\ufb01ne what is the perceptron learning rule.\n4. What was the most crucial difference between Rosenblatt\u2019s original algorithm and\nHinton\u2019s fundamental papers of 1986:\n\u201cLearning representations by back-propagating errors\u201d [22]\nand 2012:\n\u201cImageNet Classi\ufb01cation with Deep Convolutional Neural Networks\u201d [18]?\n5. The AND logic gate [7] is de\ufb01ned by the following table (8.19):\n252\nChapter 8\nDEEP LEARNING\nx1\nx2\ny\n1\n1\n1\n1\n0\n0\n0\n1\n0\n0\n0\n0\nFIGURE 8.19: Logical AND gate\nCan a perceptron with only two inputs and a single output function as an AND logic\ngate? If so, \ufb01nd the weights and the threshold and demonstrate the correctness of your\nanswer using a truth table.\n8.2.5\nActivation functions (rectification)\nWe concentrate only on the most commonly used activation functions, those which\nthe reader is more likely to encounter or use during his daily work.\nSigmoid",
    "solution": "1. The values are presented in the following table (8.61):\nBias = \u22122.5\nInput\nWeighted sum\nOutput\n(0,0)\n-2.5\n0\n(0,1)\n-1.5\n0\n(1,0)\n-1.5\n0\n(1,1)\n-0.5\n0\nFIGURE 8.61: Logical AND: B=-2.5\n2. The values are presented in the following table (8.62):\nBias = \u22120.25\nInput\nWeighted sum\nOutput\n(0,0)\n-0.25\n0\n(0,1)\n-0.75\n0\n(1,0)\n-0.75\n0\n(1,1)\n1.75\n1\nFIGURE 8.62: Logical AND: B=-0.25\n3. The perceptron learning rule is an algorithm that can automatically compute optimal\nweights for the perceptron.\n305\n8.3. SOLUTIONS\n4. The main addition by [22] and [18] was the introduction of a differentiable activation\nfunction.\n5. if we select w1 = 1;w2 = 1 and threshold=1. We get:\nx1 = 1, x2 = 1 :\nn = 1 \u00d7 1 + 1 \u00d7 1 = 2,thus,y = 1\nx1 = 1, x2 = \u22121 :\nn = 1 \u00d7 1 + 1 \u00d7 (\u22121) = 0,thus,y = \u22121\nx1 = \u22121, x2 = 1 :\nn = 1 \u00d7 (\u22121) + 1 \u00d7 1 = 0,thus,y = \u22121\nx1 = \u22121, x2 = \u22121 :\nn = 1 \u00d7 (\u22121) + 1 \u00d7 (\u22121) = \u22122,thus,y = \u22121\n(8.55)\nOr summarized in a table (8.63):\nAND gate\nin1\nin2\nout\n0\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n1\nFIGURE 8.63: Logical AND gate\n\u25a0\n8.3.5\nActivation functions (rectification)\nWe concentrate only on the most commonly used activation functions, those which\nthe reader is more likely to encounter or use during his daily work.\nSigmoid\n306\nChapter 8\nDEEP LEARNING"
  },
  {
    "id": "PRB-217",
    "chapter": "",
    "question": "The Sigmoid sc(x) =\n1\n1+e\u2212cx, also commonly known as the logistic function (Fig. 8.20),\nis widely used in binary classi\ufb01cation and as a neuron activation function in arti\ufb01cial neural\nnetworks. Typically, during the training of an ANN, a Sigmoid layer applies the Sigmoid\nfunction to elements in the forward pass, while in the backward pass the chain rule is be-\ning utilized as part of the backpropagation algorithm. In 8.20 the constant c was selected\narbitrarily as 2 and 5 respectively.\n253\n8.2. PROBLEMS\n\u22124,0\n\u22123,0\n\u22122,0\n\u22121,0\n1,0\n2,0\n3,0\n4,0\n0,2\n0,4\n0,6\n0,8\n1,0\nx\ny\n\u03c3(x) =\n1\n1+e\u22122x\n\u03c3(x) =\n1\n1+e\u22125x\n\u03c3(x) =\n1\n1+2\u22121.5x\nFIGURE 8.20: Examples of two sigmoid functions and an approximation.\nDigital hardware implementations of the sigmoid function do exist but they are expens-\nive to compute and therefore several approximation methods were introduced by the research\ncommunity. The method by [10] uses the following formulas to approximate the exponential\nfunction:\nex \u2248 Ex(x) \u2248 21.44x\n(8.26)\nBased on this formulation, one can calculate the sigmoid function as:\nSigmoid (x) \u2248\n1\n1 + 2\u22121.44x \u2248\n1\n1 + 2\u22121.5x\n(8.27)\n1. Code snippet 8.21 provides a pure C++ based (e.g. not using Autograd) implementa-\ntion of the forward pass for the Sigmoid function. Implement the backward pass that\ndirectly computes the analytical gradients in C++ using Libtorch [19] style tensors.\n254\nChapter 8\nDEEP LEARNING\n1 #include <torch/script.h>\n2 #include <vector>\n3\n4 torch::Tensor sigmoid001(const torch::Tensor & x ){\n5\ntorch::Tensor sig = 1.0 / (1.0 + torch::exp(( -x)));\n6\nreturn sig;\n7 }\nFIGURE 8.21: Forward pass for the Sigmoid function using Libtorch\n2. Code snippet 8.22 provides a skeleton for printing the values of the sigmoid and its\nderivative for a range of values contained in the vector v. Complete the code (lines 7-8)\nso that the values are printed.\n1 #include <torch/script.h>\n2 #include <vector>\n3 int main() {\n4\nstd::vector<float> v{0.0, 0.1, 0.2, 0.3,\n0.4,0.5,0.6,0.7,0.8,0.9,0.99};\n\ufffd\u2192\n5\nfor (auto it = v.begin(); it != v.end(); ++it) {\n6\ntorch::Tensor t0 = torch::tensor((*it));\n7\n...\n8\n...\n9\n}\n10 }\n.\nFIGURE 8.22: Evaluation of the sigmoid and its derivative using Libtorch\n3. Manually derive the derivative of eq. 8.27, e.g:\nd\ndx\n\ufffd\n1\n1 + 2\u22121.5x\n\ufffd\n(8.28)\n255\n8.2. PROBLEMS\n4. Implement both the forward pass for the Sigmoid function approximation eq. 8.27 that\ndirectly computes the analytical gradients in C++ using Libtorch [19].\n5. Print the values of the Sigmoid function and the Sigmoid function approximation eq.\n8.27 for the following vector:\nv = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.99]\n(8.29)\nTanh",
    "solution": "1. Remember that the analytical derivative is of the sigmoid:\nd\ndxs(x) = d\ndx((1 + e\u2212x)\u22121)\n(8.56)\nd\ndxs(x) = \u22121((1 + e\u2212x)(\u22121\u22121)) d\ndx(1 + e\u2212x)\n(8.57)\nd\ndxs(x) = \u22121((1 + e\u2212x)(\u22122))( d\ndx(1) + d\ndx(e\u2212x))\n(8.58)\nd\ndxs(x) = \u22121((1 + e\u2212x)(\u22122))(0 + e\u2212x( d\ndx(\u2212x)))\n(8.59)\nd\ndxs(x) = \u22121((1 + e\u2212x)(\u22122))(e\u2212x)(\u22121)\n(8.60)\nd\ndxs(x) = ((1 + e\u2212x)(\u22122))(e\u2212x)\n(8.61)\nd\ndxs(x) =\n1\n(1 + e\u2212x)2(e\u2212x)\n(8.62)\nd\ndxs(x) =\n(e\u2212x)\n(1 + e\u2212x)2\n(8.63)\nCode snippet 8.64 provides a pure C++ based implementation of the backward pass that\ndirectly computes the analytical gradients in C++.\n1 #include <torch/script.h>\n2 #include <vector>\n3\n4 torch::Tensor sigmoid001_d(torch::Tensor & x) {\n5\ntorch::Tensor s = sigmoid001(x);\n6\nreturn (1 - s) * s;\n7 }\nFIGURE 8.64: Backward pass for the Sigmoid function using Libtorch.\n307\n8.3. SOLUTIONS\n2. Code snippet 8.65 depicts one way of printing the values.\n1 #include <torch/script.h>\n2 #include <vector>\n3 int main() {\n4\nstd::vector<float> v{0.0, 0.1, 0.2, 0.3,\n0.4,0.5,0.6,0.7,0.8,0.9,0.99};\n\ufffd\u2192\n5\nfor (auto it = v.begin(); it != v.end(); ++it) {\n6\ntorch::Tensor t0 = torch::tensor((*it));\n7\nstd::cout << (*it) << \",\" <<\nsigmoid001(t0).data().detach().item()\n\ufffd\u2192\n8\n.toFloat()<< \",\"\n9\n<< sigmoid001_d (t0).data().detach().item().toFloat()\n10\n<< '\\n';\n11\n}\n12 }\nFIGURE 8.65: Evaluation of the sigmoid and its derivative in C++ using Libtorch.\n3. The manual derivative of eq. 8.27 is:\n3 ln(2)\u00d7\n\ufffd\n2\u22121.5x\n(2\u22121.5x + 1)2\n\ufffd\n(8.64)\n4. The forward pass for the Sigmoid function approximation eq. 8.27 is presented in code\nsnippet 8.66:\n308\nChapter 8\nDEEP LEARNING\n1 #include <torch/script.h>\n2 #include <vector>\n3 torch::Tensor sig_approx(const torch::Tensor & x ){\n4\ntorch::Tensor sig = 1.0 / (1.0 +\ntorch::pow(2,( -1.5*x)));\n5\nreturn sig;\n6 }\nFIGURE 8.66: Forward pass for the Sigmoid function approximation in C++ using Libtorch.\n5. The values are 8.67: :\n1 #include <torch/script.h>\n2 #include <vector>\n3 int main() {\n4\nstd::vector<float> v{0.0, 0.1, 0.2, 0.3,\n0.4,0.5,0.6,0.7,0.8,0.9,0.99};\n\ufffd\u2192\n5\nfor (auto it = v.begin(); it != v.end(); ++it) {\n6\ntorch::Tensor t0 = torch::tensor((*it));\n7\nstd::cout << (*it) << \",\" <<\nsigmoid001(t0).data().detach().item()\n\ufffd\u2192\n8\n.toFloat()<< \",\"<< sig_approx (t0).data().detach().item().\n9\ntoFloat()<<'\\n';\n10\n}\nFIGURE 8.67: Printing the values for Sigmoid and Sigmoid function approximation in C++\nusing Libtorch.\nAn the values are presented in Table 8.2:\n309\n8.3. SOLUTIONS\nValue\nSig\nApprox\n0\n0.5\n0.5\n0.1\n0.524979\n0.52597\n0.2\n0.549834\n0.5518\n0.3\n0.574443\n0.577353\n0.4\n0.598688\n0.602499\n0.5\n0.622459\n0.627115\n0.6\n0.645656\n0.65109\n0.7\n0.668188\n0.674323\n0.8\n0.689974\n0.69673\n0.9\n0.710949\n0.71824\n0.99\n0.729088\n0.736785\nTABLE 8.2: Computed values for the Sigmoid and the Sigmoid approximation.\n\u25a0\nTanh"
  },
  {
    "id": "PRB-218",
    "chapter": "",
    "question": "The Hyperbolic tangent nonlinearity, or the tanh function (Fig. 8.23), is a widely used\nneuron activation function in arti\ufb01cial neural networks:\nftanh (x) = sinh(x)\ncosh(x) = ex \u2212 e\u2212x\nex + e\u2212x\n(8.30)\n\u22124,0\n\u22123,0\n\u22122,0\n\u22121,0\n1,0\n2,0\n3,0\n4,0\n\u22124,0\n\u22122,0\n2,0\n4,0\nx\ny\n\u03c3(x) = 4 \u2217 tanh x\n4\n\u03c3(x) = tanh x\n4\nFIGURE 8.23: Examples of two tanh functions.\n1. Manually derive the derivative of the tanh function.\n256\nChapter 8\nDEEP LEARNING\n2. Use this numpy array as an input [[0.37, 0.192, 0.571]] and evaluate the result using\npure Python.\n3. Use the PyTorch based torch.autograd.Function class to write a custom Function\nthat implements the forward and backward passes for the tanh function in Python.\n4. Name the class TanhFunction, and using the gradcheck method from torch.autograd,\nverify that your numerical values equate the analytical values calculated by gradcheck.\nRemember you must implement a method entitled .apply(x) so that the function can\nbe invoked by Autograd.",
    "solution": "The answers are as follows:\n1. The derivative is:\nftanh(x) = 1 \u2212 ftanh(x)2\n(8.65)\n2. Code snippet 8.68 implements the forward pass using pure Python.\n310\nChapter 8\nDEEP LEARNING\n1 import numpy as np\n2 xT =\ntorch.abs(torch.tensor([[0.37,0.192,0.571]],requires_grad=True))\n\ufffd\u2192\n3 .type(torch.DoubleTensor)\n4 xT_np=xT.detach().cpu().numpy()\n5 print (\"Input: \\n\",xT_np)\n6 tanh_values = np.tanh(xT_np)\n7 print (\"Numpy:\", tanh_values)\n8 > Numpy: [[0.35399172 0.18967498 0.51609329]]\nFIGURE 8.68: Forward pass for tanh using pure Python.\n3. In order to implement a PyTorch based torch.autograd.Function function such as\ntanh, we must provide both the forward and backward passes implementation. The\nmechanism behind this idiom in PyTorch is via the use of a context, abbreviated ctx\nwhich is like a state manager for automatic differentiation. The implementation is de-\npicted in 8.69:\n311\n8.3. SOLUTIONS\n1 import torch\n2\n3 class TanhFunction(torch.autograd.Function):\n4 @staticmethod\n5\ndef forward(ctx, x):\n6\nctx.save_for_backward( x )\n7\ny = x.tanh()\n8\nreturn y\n9\n10 @staticmethod\n11\ndef backward(ctx, grad_output):\n12\ninput, = ctx.saved_tensors\n13\ndy_dx = 1 / (input.cosh() ** 2)\n14\nout = grad_output * dy_dx\n15\nprint (\"backward:{}\".format(out))\n16\nreturn out\nFIGURE 8.69: Tanh in PyTorch.\n4. Code snippet 8.70 veri\ufb01es the correctness of the implementation using gradcheck.\n312\nChapter 8\nDEEP LEARNING\n1 import numpy as np\n2 import numpy as np\n3 xT = torch.abs(torch.tensor([[0.37,0.192,0.571]],\n4 requires_grad=True))\n5 .type(torch.DoubleTensor)\n6 xT_np=xT.detach().cpu().numpy()\n7 tanh_values = np.tanh(xT_np)\n8 tanh_values_torch = tanhPyTorch(xT)\n9 print (\"Torch:\", tanh_values_torch)\n10 from torch.autograd import gradcheck, Variable\n11 f = TanhFunction.apply\n12 test=gradcheck(lambda t: f(t), xT)\n13 print(test)\n14 > PyTorch version: 1.7.0\n15 > Torch: tensor([[0.3540, 0.1897, 0.5161]], dtype=torch.float64)\n16 > backward:tensor([[0.8747, 0.9640, 0.7336]],dtype=torch.float64)\nFIGURE 8.70: Invoking gradcheck on tanh.\n\u25a0"
  },
  {
    "id": "PRB-219",
    "chapter": "",
    "question": "The code snippet in 8.24 makes use of the tanh function.\n1 import torch\n2\n3 nn001 = nn.Sequential(\n4\nnn.Linear(200, 512),\n5\nnn.Tanh(),\n6\nnn.Linear(512, 512),\n7\nnn.Tanh(),\n8\nnn.Linear(512, 10),\n9\nnn.LogSoftmax(dim=1)\n10 )\nFIGURE 8.24: A simple NN based on tanh in PyTorch.\n1. What type of a neural network does nn001 in 8.24 represent?\n2. How many hidden layers does the layer entitles nn001 have?",
    "solution": "1. The type of NN is a MultiLayer Perceptron or MLP.\n2. There are two hidden layers.\n\u25a0"
  },
  {
    "id": "PRB-220",
    "chapter": "",
    "question": "257\n8.2. PROBLEMS\nYour friend, a veteran of the DL community claims that MLPs based on tanh activation\nfunction, have a symmetry around 0 and consequently cannot be saturated. Saturation, so\nhe claims is a phenomenon typical of the top hidden layers in sigmoid based MLPs. Is he\nright or wrong?",
    "solution": "He is partially correct , see for example Understanding the dif\ufb01culty of training deep\nfeedforward neural networks [9].\n\u25a0\n313\n8.3. SOLUTIONS"
  },
  {
    "id": "PRB-221",
    "chapter": "",
    "question": "If we initialize the weights of a tanh based NN, which of the following approaches will\nlead to the vanishing gradients problem?.\ni Using the normal distribution, with parameter initialization method as suggested by\nKaiming [14].\nii Using the uniform distribution, with parameter initialization method as suggested by\nXavier Glorot [9].\niii Initialize all parameters to a constant zero value.",
    "solution": "Initialize all parameters to a constant zero value. When we apply the tanh function to an\ninput which is very large, the output which is almost zero, will be propagated to the remaining\npartial derivatives leading to the well known phenomenon.\n\u25a0"
  },
  {
    "id": "PRB-222",
    "chapter": "",
    "question": "You friend, who is experimenting with the tanh activation function designed a small\nCNN with only one hidden layer and a linear output (8.25):\nFIGURE 8.25: A small CNN composed of tanh blocks.\nHe initialized all the weights and biases (biases not shown for brevity) to zero. What is\nthe most signi\ufb01cant design \ufb02aw in his architecture?\nHint: think about back-propagation.\nReLU",
    "solution": "During the back-propagation process, derivatives are calculated with respect to (W (1))\nand also (W (2)). The design \ufb02aw:\ni Your friend initialized all weights and biases to zero.\nii Therefore any gradient with respect to (W (2)) would also be zero.\niii Subsequently, (W (2)) will never be updated.\niv This would inadvertently cause the derivative with respect to (W (1)) to be always zero.\nv Finally, would also never be updated (W (1)).\n\u25a0\nReLU"
  },
  {
    "id": "PRB-223",
    "chapter": "",
    "question": "258\nChapter 8\nDEEP LEARNING\nThe recti\ufb01ed linear unit, or ReLU g(z) = max{0, z} is the default for many CNN archi-\ntectures. It is de\ufb01ned by the following function:\nfReLU(x) = max(0, x)\n(8.31)\nOr:\nfReLU(x) =\n\uf8f1\n\uf8f2\n\uf8f3\n1\nif x > 0\n0\nif x \u2264 0\n(8.32)\n1. In what sense is the ReLU better than traditional sigmoidal activation functions?",
    "solution": "The ReLU function has the bene\ufb01t of not saturating for positive inputs since its derivative\nis one for any positive value.\n\u25a0"
  },
  {
    "id": "PRB-224",
    "chapter": "",
    "question": "You are experimenting with the ReLU activation function, and you design a small CNN\n(8.26) which accepts an RGB image as an input. Each CNN kernel is denoted by w.\nFIGURE 8.26: A small CNN composed of ReLU blocks.\nWhat is the shape of the resulting tensor W?",
    "solution": "The shape is:\n3 \u00d7 3 \u00d7 3 \u00d7 16\n\u25a0"
  },
  {
    "id": "PRB-225",
    "chapter": "",
    "question": "Name the following activation function where a \u2208 (0, 1):\nf(x) =\n\uf8f1\n\uf8f2\n\uf8f3\nx\nif x > 0\nax\notherwise\n(8.33)\nSwish\n259\n8.2. PROBLEMS",
    "solution": "The activation function is a leaky ReLU which in some occasions may outperform the\n314\nChapter 8\nDEEP LEARNING\nReLU activation function.\n\u25a0\nSwish"
  },
  {
    "id": "PRB-226",
    "chapter": "",
    "question": "In many interviews, you will be given a paper that you have never encountered before,\nand be required to read and subsequently discuss it. Please read Searching for Activation\nFunctions [21] before attempting the questions in this question.\n1. In [21], researchers employed an automatic pipeline for searching what exactly?\n2. What types of functions did the researchers include in their search space?\n3. What were the main \ufb01ndings of their research and why were the results surprising?\n4. Write the formulae for the Swish activation function.\n5. Plot the Swish activation function.\n8.2.6\nPerformance Metrics\nComparing different machine learning models, tuning hyper parameters and learn-\ning rates, \ufb01nding optimal augmentations, are all important steps in ML research. Typ-\nically our goal is to \ufb01nd the best model with the lowest errors on both the training\nand validation sets. To do so we need to be able to measure the performance of each\napproach/model/parameter setting etc. and compare those measures. For valuable\nreference, read: \u201cEvaluating Learning Algorithms: A Classi\ufb01cation Perspective\u201d [22]\nConfusion matrix, precision, recall",
    "solution": "1. They intended to \ufb01nd new better-performing activation functions.\n2. They had a list of basic mathematical functions to choose from, for instance the expo-\nnential families exp(), sin(), min and max.\n3. Previous research found several activation function properties which were considered\nvery useful. For instance, gradient preservation and non-monotonicity. However the\nsurprising discovery was that the swish function violates both of these previously deemed\nuseful properties.\n4. The equation is:\nf(x) = x \u00b7 \u03c3(x)\n(8.66)\n5. The plot is 8.71\n\u22121,0 \u22120,8 \u22120,6 \u22120,4 \u22120,2\n0,2\n0,4\n0,6\n0,8\n1,0\n\u22121,0\n\u22120,5\n0,5\n1,0\nx\ny\nx \u2217 \u03c3(x) = x \u2217\n1\n1+e\u22124x\nFIGURE 8.71: A plot of the Swish activation function.\n\u25a0\n315\n8.3. SOLUTIONS\n8.3.6\nPerformance Metrics\nConfusion matrix, precision, recall"
  },
  {
    "id": "PRB-227",
    "chapter": "",
    "question": "You design a binary classi\ufb01er for detecting the presence of malfunctioning temperature\nsensors. Non-malfunctioning (N) devices are the majority class in the training corpus. While\nrunning inference on an unseen test-set, you discover that the Confusion Metrics (CM) has\nthe following values 8.27:\n260\nChapter 8\nDEEP LEARNING\nPredicted\nP\nN\nActual\nP\n12\n7\nN\n24\n1009\nFIGURE 8.27: A confusion metrics for functioning (N) temperature sensors. P stands for\nmalfunctioning devices.\n1. Find: TP, TN, FP, FN and correctly label the numbers in table 8.27.\n2. What is the accuracy of the model?\n3. What is the precision of the model?\n4. What is the recall of the model?\nROC-AUC\nThe area under the receiver operating characteristic (ROC) curve, 8.73 known as the\nAUC, is currently considered to be the standard method to assess the accuracy of\npredictive distribution models.\nFIGURE 8.28: Receiver Operating Characteristic curve.\n261\n8.2. PROBLEMS",
    "solution": "1. The values are labelled inside 8.27:\nPredicted\nP\nN\nTruth\nP\nTP=12\nFN=7\nN\nFP=24\nTN=1009\nFIGURE 8.72: TP, TN, FP, FN.\n2.\nacc =\n12 + 1009\n12 + 7 + 24 + 1009 = 0.97\n(8.67)\n3.\nprec =\n12\n12 + 24 = 0.333\n(8.68)\n4.\nrecall =\n12\n12 + 7 = 0.631\n(8.69)\n\u25a0\nROC-AUC\nThe area under the receiver operating characteristic (ROC) curve, 8.73 known as the\nAUC, is currently considered to be the standard method to assess the accuracy of\npredictive distribution models.\n316\nChapter 8\nDEEP LEARNING\nFIGURE 8.73: Receiver Operating Characteristic curve."
  },
  {
    "id": "PRB-228",
    "chapter": "",
    "question": "Complete the following sentences:\n1. Receiver Operating Characteristics of a classi\ufb01er shows its performance as a trade off\nbetween [...] and [...].\n2. It is a plot of [...] vs. the [...]. In place of [...], one could also use [...] which are essen-\ntially {1 - \u2018true negatives\u2019}.\n3. A typical ROC curve has a concave shape with [...] as the beginning and [...] as the\nend point\n4. The ROC curve of a \u2018random guess classi\ufb01er\u2019, when the classi\ufb01er is completely con-\nfused and cannot at all distinguish between the two classes, has an AUC of [...] which\nis the [...] line in an ROC curve plot.",
    "solution": "ROC allows to attest the relationship between sensitivity and speci\ufb01city of a binary clas-\nsi\ufb01er. Sensitivity or true positive rate measures the proportion of positives correctly classi\ufb01ed;\nspeci\ufb01city or true negative rate measures the proportion of negatives correctly classi\ufb01ed. Con-\nventionally, the true positive rate tpr is plotted against the false positive rate fpr, which is one\nminus true negative rate.\n1. Receiver Operating Characteristics of a classi\ufb01er shows its performance as a trade off\nbetween selectivity and sensitivity.\n2. It is a plot of \u2018true positives\u2019 vs. the \u2018true negatives\u2019. In place of \u2018true negatives\u2019,\none could also use \u2018false positives\u2019 which are essentially 1 - \u2018true negatives\u2019.\n3. A typical ROC curve has a concave shape with (0,0) as the beginning and (1,1) as the\nend point\n4. The ROC curve of a \u2018random guess classi\ufb01er\u2019, when the classi\ufb01er is completely confused\nand cannot at all distinguish between the two classes, has an AUC of 0.5, the \u2018x = y\u2019\nline in an ROC curve plot.\n317\n8.3. SOLUTIONS\n\u25a0"
  },
  {
    "id": "PRB-229",
    "chapter": "",
    "question": "The code 8.30 and Figure 8.29 are the output from running XGBOOST for a binary\nclassi\ufb01cation task.\nFIGURE 8.29: RUC AUC\n262\nChapter 8\nDEEP LEARNING\n1 XGBClassifier(base_score=0.5, colsample_bylevel=1,\ncolsample_bytree=0.5,\n\ufffd\u2192\n2 gamma=0.017, learning_rate=0.15, max_delta_step=0, max_depth=9,\n3 min_child_weight=3, missing=None, n_estimators=1000, nthread=-1,\n4 objective='binary:logistic', reg_alpha=0, reg_lambda=1,\n5 scale_pos_weight=1, seed=0, silent=1,\nsubsample=0.9)shape:(316200, 6)\n\ufffd\u2192\n6\n7 >ROC AUC:0.984439608912\n8 >LOG LOSS:0.0421598347226\nFIGURE 8.30: XGBOOST for binary classi\ufb01cation.\nHow would you describe the results of the classi\ufb01cation?.\n8.2.7\nNN Layers, topologies, blocks\nCNN arithmetics",
    "solution": "The ROC curve of an ideal classi\ufb01er (100% accuracy) has an AUC of 1, with 0.0 \u2018false\npositives\u2019 and 1.0 \u2018true positives\u2019. The ROC curve in our case, is almost ideal, which may\nindicate over-\ufb01tting of the XGBOOST classi\ufb01er to the training corpus.\n\u25a0\n8.3.7\nNN Layers, topologies, blocks\nCNN arithmetics"
  },
  {
    "id": "PRB-230",
    "chapter": "",
    "question": "Given an input of size of n \u00d7 n, \ufb01lters of size f \u00d7 f and a stride of s with padding of p,\nwhat is the output dimension?",
    "solution": "Output dimension: L \u00d7 L \u00d7 M where L = n\u2212f+2p\ns\n+ 1\n\u25a0"
  },
  {
    "id": "PRB-231",
    "chapter": "",
    "question": "Referring the code snippet in Fig. (8.31), answer the following questions regarding the\nVGG11 architecture [25]:\n263\n8.2. PROBLEMS\n1 import torchvision\n2 import torch\n3 def main():\n4\nvgg11 = torchvision.models.vgg11(pretrained=True)\n5\nvgg_layers = vgg11.features\n6\nfor param in vgg_layers.parameters():\n7\nparam.requires_grad = False\n8\n9\nexample = [torch.rand(1, 3, 224, 224),\n10\ntorch.rand(1, 3, 512, 512),\n11\ntorch.rand(1, 3, 704, 1024)]\n12\nvgg11.eval()\n13\nfor e in example:\n14\nout=vgg_layers(e)\n15\nprint(out.shape)\n16 if __name__ == \"__main__\":\n17\nmain()^^I^^I\nFIGURE 8.31: CNN arithmetics on the VGG11 CNN model.\n1. In each case for the input variable example , determine the dimensions of the tensor\nwhich is the output of applying the VGG11 CNN to the respective input.\n2. Choose the correct option. The last layer of the VGG11 architecture is:\ni Conv2d\nii MaxPool2d\niii ReLU",
    "solution": "The answers are as follows:\n1. Output dimensions:\ni torch.Size([1, 512, 7, 7])\nii torch.Size([1, 512, 16, 16])\niii torch.Size([1, 512, 22, 40])\n2. The layer is MaxPool2d.\n\u25a0"
  },
  {
    "id": "PRB-232",
    "chapter": "",
    "question": "Still referring the code snippet in Fig. (8.31), and speci\ufb01cally to line 7, the code is\namended so that the line is replaced by the line:\nvgg_layers=vgg11.features[:3] .\n264\nChapter 8\nDEEP LEARNING\n1. What type of block is now represented by the new line? Print it using PyTorch.\n2. In each case for the input variable example , determine the dimensions of the tensor\nwhich is the output of applying the block:\nvgg_layers=vgg11.features[:3] to the respective input.",
    "solution": "The answers are as follows:\n1. A convolutional block 8.74.\n318\nChapter 8\nDEEP LEARNING\n1 Sequential(\n2 (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1,\n1))\n\ufffd\u2192\n3 (1): ReLU(inplace=True)\n4 (2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1,\nceil_mode=False\n\ufffd\u2192\n5 )\nFIGURE 8.74: Convolutional block from the VGG11 architecture.\n2. The shapes are as follows:\ni torch.Size([1, 64, 112, 112])\nii torch.Size([1, 64, 256, 256])\niii torch.Size([1, 64, 352, 512])\n\u25a0"
  },
  {
    "id": "PRB-233",
    "chapter": "",
    "question": "Table (8.1) presents an incomplete listing of the of the VGG11 architecture [25]. As\ndepicted, for each layer the number of \ufb01lters (i. e., neurons with unique set of parameters) are\npresented.\nLayer\n#Filters\nconv4_3\n512\nfc6\n4,096\nfc7\n4,096\noutput\n1,000\nTABLE 8.1: Incomplete listing of the VGG11 architecture.\nComplete the missing parts regarding the dimensions and arithmetics of the VGG11\nCNN architecture:\n1. The VGG11 architecture consists of [...] convolutional layers.\n2. Each convolutional layer is followed by a [...] activation function, and \ufb01ve [...] opera-\ntions thus reducing the preceding feature map size by a factor of [...].\n3. All convolutional layers have a [...] kernel.\n4. The \ufb01rst convolutional layer produces [...] channels.\n5. Subsequently as the network deepens, the number of channels [...] after each [...] oper-\nation until it reaches [...].\n265\n8.2. PROBLEMS\nDropout",
    "solution": "The VGG11 architecture contains seven convolutional layers, each followed by a ReLU\nactivation function, and \ufb01ve max-polling operations, each reducing the respective feature\nmap by a factor of 2. All convolutional layers have a 3 \u00d7 3 kernel. The \ufb01rst convolutional\nlayer produces 64 channels and subsequently, as the network deepens, the number of channels\ndoubles after each max-pooling operation until it reaches 512.\n\u25a0\nDropout"
  },
  {
    "id": "PRB-234",
    "chapter": "",
    "question": "A Dropout layer [26] (Fig. 8.32) is commonly used to regularize a neural network model\nby randomly equating several outputs (the crossed-out hidden node H) to 0.\n\u03b80\nH\nH\nDropout\nFIGURE 8.32: A Dropout layer (simpli\ufb01ed form).\nFor instance, in PyTorch [20], a Dropout layer is declared as follows (8.2):\n1 import torch\n2 import torch.nn as nn\n3 nn.Dropout(0.2)\nCODE 8.2: Dropout in PyTorch\nWhere nn.Dropout(0.2) (Line #3 in 8.2) indicates that the probability of zeroing an\nelement is 0.2.\n266\nChapter 8\nDEEP LEARNING\n\u03b81\n\u03b82\nH1\nH2\n\u03b31\nFIGURE 8.33: A Bayesian Neural Network Model\nA new data scientist in your team suggests the following procedure for a Dropout layer\nwhich is based on Bayesian principles. Each of the neurons \u03b8n in the neural network in (Fig.\n8.33) may drop (or not) independently of each other exactly like a Bernoulli trial.\nDuring the training of a neural network, the Dropout layer randomly drops out outputs\nof the previous layer, as indicated in (Fig. 8.32). Here, for illustration purposes, all four\nneurons are dropped as depicted by the crossed-out hidden nodes Hn.\n1. You are interested in the proportion \u03b8 of dropped-out neurons. Assume that the chance\nof drop-out, \u03b8, is the same for each neuron (e.g. a uniform prior for \u03b8). Compute the\nposterior of \u03b8.\n2. Describe the similarities of dropout to bagging.",
    "solution": "1. The observed data, e.g the dropped neurons are distributed according to:\n(x1, . . . , xn)|\u03b8\niid\n\u223c Bern(\u03b8)\n(8.70)\n319\n8.3. SOLUTIONS\nDenoting s and f as success and failure respectively, we know that the likelihood is:\np (x1, . . . , xn|\u03b8) = \u03b8s(1 \u2212 \u03b8)f\n(8.71)\nWith the following parameters \u03b1 = \u03b2 = 1 the beta distribution acts like Uniform prior:\n\u03b8 \u223c Beta(\u03b1, \u03b2), given \u03b1 = \u03b2 = 1\n(8.72)\nHence, the prior density is:\np(\u03b8) =\n1\nB(\u03b1, \u03b2)\u03b8\u03b1\u22121(1 \u2212 \u03b8)\u03b2\u22121\n(8.73)\nTherefore the posterior is:\np (\u03b8|x1, . . . , xn) \u221d p (x1, . . . , xn|\u03b8) p(\u03b8)\n\u221d \u03b8S(1 \u2212 \u03b8)f\u03b8\u03b1\u22121(1 \u2212 \u03b8)\u03b2\u22121\n= \u03b8\u03b1+s\u22121(1 \u2212 \u03b8)\u03b2+f\u22121\n(8.74)\n2. In dropout, in every training epoch, neurons are randomly pruned with probability\nP = p sampled from a Bernoulli distribution. During inference, all the neurons are used\nbut their output is multiplied by the a-priory probability P. This approach resembles to\nsome degree the model averaging approach of bagging.\n\u25a0"
  },
  {
    "id": "PRB-235",
    "chapter": "",
    "question": "A co-worker claims he discovered an equivalence theorem where, two consecutive Dro-\npout layers [26] can be replaced and represented by a single Dropout layer 8.34.\nFIGURE 8.34: Two consecutive Dropout layers\nHi realized two consecutive layers in PyTorch [20], declared as follows (8.3):\n267\n8.2. PROBLEMS\n1 import torch\n2 import torch.nn as nn\n3 nn.Sequential(\n4\nnn.Conv2d(1024, 32),\n5\nnn.ReLU(),\n6\nnn.Dropout(p=P, inplace=True),\n7\nnn.Dropout(p=Q, inplace=True)\n8 )\nCODE 8.3: Consequtive dropout in PyTorch\nWhere nn.Dropout(0.1) (Line #6 in 8.3) indicates that the probability of zeroing an\nelement is 0.1.\n1. What do you think about his idea, is he right or wrong?\n2. Either prove that he is right or provide a single example that refutes his theorem.\nConvolutional Layer\nThe convolution layer is probably one of the most important layers in the theory and\npractice of modern deep learning and computer vision in particular.\nTo study the optimal number of convolutional layers for the classi\ufb01cation of two\ndifferent types of the Ebola virus, a researcher designs a binary classi\ufb01cation pipeline\nusing a small CNN with only a few layers (8.35):\n268\nChapter 8\nDEEP LEARNING\nFIGURE 8.35: A CNN based classi\ufb01cation system.\nAnswer the following questions while referring to (8.35):",
    "solution": "The answers are as follows:\n1. The idea is true and a solid one.\n2. The idiom may be exempli\ufb01ed as follows 8.75:\n320\nChapter 8\nDEEP LEARNING\nFIGURE 8.75: Equivalence of two consecutive dropout layers\nThe probabilities add up by multiplication at each layer, resulting in a single dropout\nlayer with probability:\n1 \u2212 (1 \u2212 p)(1 \u2212 q)\n(8.75)\n\u25a0\nConvolutional Layer"
  },
  {
    "id": "PRB-236",
    "chapter": "",
    "question": "If he uses the following \ufb01lter for the convolutional operation, what would be the resulting\ntensor after the application of the convolutional layer?\nFIGURE 8.36: A small \ufb01lter for a CNN",
    "solution": "The result is (8.76):\nFIGURE 8.76: The result of applying the \ufb01lter.\n\u25a0\n321\n8.3. SOLUTIONS"
  },
  {
    "id": "PRB-237",
    "chapter": "",
    "question": "What would be the resulting tensor after the application of the ReLU layer (8.37)?\n269\n8.2. PROBLEMS\nFIGURE 8.37: The result of applying the \ufb01lter.",
    "solution": "The result is (8.77):\nFIGURE 8.77: The result of applying a ReLU activation.\n\u25a0"
  },
  {
    "id": "PRB-238",
    "chapter": "",
    "question": "What would be the resulting tensor after the application of the MaxPool layer (8.78)?\nPooling Layers\nA pooling layer transforms the output of a convolutional layer, and neurons in a pool-\ning layer accept the outputs of a number of adjacent feature maps and merge their\noutputs into a single number.\nMaxPooling",
    "solution": "The result is (8.78):\nFIGURE 8.78: The result of applying a MaxPool layer.\n\u25a0\nPooling Layers\nMaxPooling\n322\nChapter 8\nDEEP LEARNING"
  },
  {
    "id": "PRB-239",
    "chapter": "",
    "question": "The following input 8.38 is subjected to a MaxPool2D(2,2) operation having 2 \u00d7 2 max-\npooling \ufb01lter with a stride of 2 and no padding at all.\n270\nChapter 8\nDEEP LEARNING\nFIGURE 8.38: Input to MaxPool2d operation.\nAnswer the following questions:\n1. What is the most common use of max-pooling layers?\n2. What is the result of applying the MaxPool2d operation on the input?",
    "solution": "The answers are as follows:\n1. A max-pooling layer is most commonly used after a convolutional layer in order to\nreduce the spatial size of CNN feature maps.\n2. The result is 8.79:\nFIGURE 8.79: Output of the MaxPool2d operation.\n\u25a0"
  },
  {
    "id": "PRB-240",
    "chapter": "",
    "question": "While reading a paper about the MaxPool operation, you encounter the following code\nsnippet 9.1 of a PyTorch module that the authors implemented. You download their pre-\ntrained model, and evaluate its behaviour during inference:\n271\n8.2. PROBLEMS\n1 import torch\n2 from torch import nn\n3 class MaxPool001(nn.Module):\n4\ndef __init__(self):\n5\nsuper(MaxPool001, self).__init__()\n6\nself.math = torch.nn.Sequential(\n7\ntorch.nn.Conv2d(3, 32, kernel_size=7, padding=2),\n8\ntorch.nn.BatchNorm2d(32),\n9\ntorch.nn.MaxPool2d(2, 2),\n10\ntorch.nn.MaxPool2d(2, 2),\n11\n)\n12\ndef forward(self, x):\n13\nprint (x.data.shape)\n14\nx = self.math(x)\n15\nprint (x.data.shape)\n16\nx = x.view(x.size(0), -1)\n17\nprint (\"Final shape:{}\",x.data.shape)\n18\nreturn x\n19 model = MaxPool001()\n20 model.eval()\n21 x = torch.rand(1, 3, 224, 224)\n22 out=model.forward(x)\nCODE 8.4: A CNN in PyTorch\nThe architecture is presented in 9.2:\n272\nChapter 8\nDEEP LEARNING\nFIGURE 8.39: Two consecutive MaxPool layers.\nPlease run the code and answer the following questions:\n1. In MaxPool2D(2,2), what are the parameters used for?\n2. After running line 8, what is the resulting tensor shape?\n3. Why does line 20 exist at all?\n4. In line 9, there is a MaxPool2D(2,2) operation, followed by yet a second MaxPool2D(2,2).\nWhat is the resulting tensor shape after running line 9? and line 10?\n5. A friend who saw the PyTorch implementation, suggests that lines 9 and 10 may\nbe replaced by a single MaxPool2D(4,4,) operation while producing the exact same\nresults. Do you agree with him? Amend the code and test your assertion.\nBatch normalization, Gaussian PDF\nRecommended readings for this topic are \u201cBatch Normalization: Accelerating Deep Net-\nwork Training by Reducing Internal Covariate Shift\u201d [16] and \u201cDelving deep into recti\ufb01ers:\nSurpassing human-level performance on imagenet classi\ufb01cation\u201d [14].\nA discussion of batch normalization (BN) would not be complete without a discus-\nsion of the Gaussian normal distribution. Though it would be instructive to develop\nthe forward and backwards functions for a BN operation from scratch, it would also\nbe quite complex. As an alternative we discuss several aspects of the BN operation\nwhile expanding on the Gaussian distribution.\n273\n8.2. PROBLEMS\nThe Gaussian distribution",
    "solution": "1. In MaxPool2D(2,2), the \ufb01rst parameter is the size of the pooling operation and the\nsecond is the stride of the pooling operation.\n2. The BatchNorm2D operation does not change the shape of the tensor from the previous\nlayer and therefore it is:\ntorch.Size([1, 32, 222, 222]).\n3. During the training of a CNN we use model.train() so that Dropout layers are \ufb01red.\nHowever, in order to run inference, we would like to turn this \ufb01ring mechanism off,\nand this is accomplished by model.eval() instructing the PyTorch computation graph\nnot to activate dropout layers.\n4. The resulting tensor shape is:\ntorch.Size([1, 32, 55, 55])\nIf we reshape the tensor like in line 17 using:\nx = x.view(x.size(0), \u22121)\n323\n8.3. SOLUTIONS\nThen the tensor shape becomes:\ntorch.Size([1, 96800])\n5. Yes, you should agree with him, as depicted by the following plot 8.80:\nFIGURE 8.80: A single MaxPool layer.\n\u25a0\nBatch normalization, Gaussian PDF\nThe Gaussian distribution"
  },
  {
    "id": "PRB-241",
    "chapter": "",
    "question": "1. What is batch normalization?\n2. The normal distribution is de\ufb01ned as follows:\nP(x) =\n1\n\u03c3\n\u221a\n2\u03c0e\u2212(x\u2212\u00b5)2/2\u03c32\n(8.34)\nGenerally i.i.d. X \u223c N(\u00b5, \u03c32) however BN uses the standard normal distribution.\nWhat mean and variance does the standard normal distribution have?\n3. What is the mathematical process of normalization?\n4. Describe, how normalization works in BN.",
    "solution": "The answers are as follows:\n1. BN is a method that normalizes the mean and variance of each of the elements during\ntraining.\n2. X \u223c N(0, 1) a mean of zero and a variance of one. The standard normal distribution\noccurs when (\u03c3)2 = 1 and \u00b5 = 0.\n3. In order to normalize we:\ni Step one is to subtract the mean to shift the distribution.\nii Divide all the shifted values by their standard deviation (the square root of the\nvariance).\n4. In BN, the normalization is applied on an element by element basis. During training at\neach epoch, every element in the batch has to be shifted and scaled so that it has a zero\nmean and unit variance within the batch.\n\u25a0\n324\nChapter 8\nDEEP LEARNING"
  },
  {
    "id": "PRB-242",
    "chapter": "",
    "question": "In python, the probability density function for a normal distribution is given by 8.40:\n1 import scipy\n2 scipy.stats.norm.pdf(x, mu, sigma)\nFIGURE 8.40: Normal distribution in Python.\n1. Without using Scipy, implement the normal distribution from scratch in Python.\n2. Assume, you want to back propagate on the normal distribution, and therefore you\nneed the derivative. Using Scipy write a function for the derivative.\nBN",
    "solution": "1. One possible realization is as follows 8.81:\n1 from math import sqrt\n2 import math\n3 def normDist(x, mu, sigSqrt):\n4\nreturn (1 / sqrt(2 * math.pi * sigSqrt)) * math.e ** ((-0.5) *\n(x - mu) ** 2 / sigSqrt)\n\ufffd\u2192\nFIGURE 8.81: Normal distribution in Python: from scratch.\n2. The derivative is given by 8.82:\n1 scipy.stats.norm.pdf(x, mu, sigma)*(mu - x)/sigma**2\nFIGURE 8.82: The derivative of a Normal distribution in Python.\n\u25a0\nBN"
  },
  {
    "id": "PRB-243",
    "chapter": "",
    "question": "274\nChapter 8\nDEEP LEARNING\nYour friend, a novice data scientist, uses an RGB image (8.41) which he then subjects to\nBN as part of training a CNN.\nFIGURE 8.41: A convolution and BN applied to an RGB image.\n1. Help him understand, during BN, is the normalization applied pixel-wise or per colour\nchannel?\n2. In the PyTorch implementation, he made a silly mistake 8.42, help him identify it:\n275\n8.2. PROBLEMS\n1 import torch\n2 from torch import nn\n3 class BNl001(nn.Module):\n4\ndef __init__(self):\n5\nsuper(BNl001, self).__init__()\n6\nself.cnn = torch.nn.Sequential(\n7\ntorch.nn.Conv2d(3, 64, kernel_size=3, padding=2),\n8\n)\n9\nself.math= torch.nn.Sequential(\n10\ntorch.nn.BatchNorm2d(32),\n11\ntorch.nn.PReLU(),\n12\ntorch.nn.Dropout2d(0.05)\n13\n)\n14\ndef forward(self, x):\n15\n...\nFIGURE 8.42: A mistake in a CNN\nTheory of CNN design",
    "solution": "1. During training of a CNN, when a convolution is being followed by a BN layer, for\neach of the three RGB channels a single separate mean and variance is being computed.\n2. The mistake he made is using a BN with a batch size of 32, while the output from the\nconvolutional layer is 64.\n\u25a0\n325\n8.3. SOLUTIONS\nTheory of CNN design"
  },
  {
    "id": "PRB-244",
    "chapter": "",
    "question": "True or false: An activation function applied after a Dropout, is equivalent to an activ-\nation function applied before a dropout.",
    "solution": "True.\n\u25a0"
  },
  {
    "id": "PRB-245",
    "chapter": "",
    "question": "Which of the following core building blocks may be used to construct CNNs? Choose all\nthe options that apply:\ni Pooling layers\nii Convolutional layers\niii Normalization layers\niv Non-linear activation function\n276\nChapter 8\nDEEP LEARNING\nv Linear activation function",
    "solution": "All the options may be used to build a CNN.\n\u25a0"
  },
  {
    "id": "PRB-246",
    "chapter": "",
    "question": "You are designing a CNN which has a single BN layer. Which of the following core CNN\ndesigns are valid? Choose all the options that apply:\ni CONV \u2192 act \u2192 BN \u2192 Dropout \u2192 . . .\nii CONV \u2192 act \u2192 Dropout \u2192 BN \u2192 . . .\niii CONV \u2192 BN \u2192 act \u2192 Dropout \u2192 . . .\niv BN \u2192 CONV \u2192 act \u2192 Dropout \u2192 . . .\nv CONV \u2192 Dropout \u2192 BN \u2192 act \u2192 . . .\nvi Dropout \u2192 CONV \u2192 BN \u2192 act \u2192 . . .",
    "solution": "While the original paper ([16]) suggests that BN layers be\nused before an activation function, it is also possible to use BN after the activation function.\nIn some cases, it actually leads to better results ([4]).\n\u25a0"
  },
  {
    "id": "PRB-247",
    "chapter": "",
    "question": "The following operator is known as the Hadamard product:\nOUT = A \u2299 B\n(8.35)\nWhere:\n(A \u2299 B)i,j := (A)i,j(B)i,j\n(8.36)\nA scientist, constructs a Dropout layer using the following algorithm:\ni Assign a probability of p for zeroing the output of any neuron.\nii Accept an input tensor T, having a shape S\niii Generate a new tensor T\u2018 \u2208 {0, 1}S\niv Assign each element in T\u2018 a randomly and independently sampled value from a Bernoulli\ndistribution:\nT\u2018i \u223c B(1, p)\n(8.37)\n277\n8.2. PROBLEMS\nv Calculate the OUT tensor as follows:\nOUT = T\u2018 \u2299 T\n(8.38)\nYou are surprised to \ufb01nd out that his last step is to multiply the output of a dropout layer\nwith:\n1\n1 \u2212 p\n(8.39)\nExplain what is the purpose of multiplying by the term\n1\n1\u2212p.",
    "solution": "When dropout is enabled during the training process, in order to keep the expected output\nat the same value, the output of a dropout layer must be multiplied with this term. Of course,\nduring inference no dropout is taking place at all.\n\u25a0"
  },
  {
    "id": "PRB-248",
    "chapter": "",
    "question": "Visualized in (8.43) from a high-level view, is an MLP which implements a well-known\nidiom in DL.\nFIGURE 8.43: A CNN block\n1. Name the idiom.\n2. What can this type of layer learn?\n3. A fellow data scientist suggests amending the architecture as follows (8.44)\n278\nChapter 8\nDEEP LEARNING\nFIGURE 8.44: A CNN block\nName one disadvantage of this new architecture.\n4. Name one CNN architecture where the input equals the output.\nCNN residual blocks",
    "solution": "1. The idiom is a bottleneck layer ([27]), which may act much like an autoencoder.\n2. Reducing and then increasing the activations, may force the MLP to learn a more com-\npressed representation.\n3. The new architecture has far more connections and therefore it would be prone to over-\n\ufb01tting.\n4. Once such architecture is an autoencoder ([28]).\n\u25a0\nCNN residual blocks"
  },
  {
    "id": "PRB-249",
    "chapter": "",
    "question": "Answer the following questions regarding residual networks ([13]).\n1. Mathematically, the residual block may be represented by:\ny = x + F(x)\n(8.40)\nWhat is the function F?\n2. In one sentence, what was the main idea behind deep residual networks (ResNets) as\nintroduced in the original paper ([13])?",
    "solution": "326\nChapter 8\nDEEP LEARNING\n1. The function F is the residual function.\n2. The main idea was to add an identity connection which skips two layers all together.\n\u25a0"
  },
  {
    "id": "PRB-250",
    "chapter": "",
    "question": "Your friend was thinking about ResNet blocks, and tried to visualize them in (8.45).\n279\n8.2. PROBLEMS\nFIGURE 8.45: A resnet CNN block\n1. Assuming a residual of the form y = x + F(x), complete the missing parts in Fig.\n(8.45).\n2. What does the symbol \u2295 denotes?\n3. A fellow data scientist, who had coffee with you said that residual blocks may compute\nthe identity function. Explain what he meant by that.\n8.2.8\nTraining, hyperparameters\nHyperparameter optimization",
    "solution": "1. The missing parts are visualized in (8.83).\nFIGURE 8.83: A resnet CNN block\n2. The symbol represents the addition operator.\n3. Whenever F returns a zero, then the input X will reach the output without being\nmodi\ufb01ed. Therefore, the term identity function.\n\u25a0\n8.3.8\nTraining, hyperparameters\nHyperparameter optimization"
  },
  {
    "id": "PRB-251",
    "chapter": "",
    "question": "A certain training pipeline for the classi\ufb01cation of large images (1024 x 1024) uses the\nfollowing Hyperparameters (8.46):\n280\nChapter 8\nDEEP LEARNING\nHyperparameter\nValue\nInitial learning rate\n0.1\nWeight decay\n0.0001\nMomentum\n0.9\nBatch size\n1024\n1 optimizer = optim.SGD(model.parameters(), lr=0.1,\n2 momentum=0.9,\n3 weight_decay=0.0001)\n4 ...\n5 trainLoader = torch.utils.data.DataLoader(\n6 datasets.LARGE('../data', train=True, download=True,\n7 transform=transforms.Compose([\n8 transforms.ToTensor(),\n9 ])),\n10 batch\\_size=1024, shuffle=True)\nFIGURE 8.46: Hyperparameters.\nIn your opinion, what could possibly go wrong with this training pipeline?",
    "solution": "The question states that image size is quite large, and the batch size is 1024, therefore it\nmay fail to allocate memory on the GPU with an Out Of Memory (OOM) error message. This\n327\n8.3. SOLUTIONS\nis one of the most commonly faced errors when junior data-scientist start training models.\n\u25a0"
  },
  {
    "id": "PRB-252",
    "chapter": "",
    "question": "A junior data scientist in your team who is interested in Hyperparameter tuning, wrote\nthe following code (8.5) for spiting his corpus into two distinct sets and \ufb01tting an LR model:\n281\n8.2. PROBLEMS\n1 from sklearn.model_selection import train_test_split\n2 dataset = datasets.load_iris()\n3 X_train, X_test, y_train, y_test =\n4 train_test_split(dataset.data, dataset.target, test_size=0.2)\n5 clf = LogisticRegression(data_norm=12)\n6 clf.fit(X_train, y_train)\nCODE 8.5: Train and Validation split.\nHe then evaluated the performance of the trained model on the Xtest set.\n1. Explain why his methodology is far from perfect.\n2. Help him resolve the problem by utilizing a difference splitting methodology.\n3. Your friend now amends the code an uses:\n1 clf = GridSearchCV(method, params, scoring='roc_auc', cv=5)\n2 clf.fit(train_X, train_y)\nExplain why his new approach may work better.",
    "solution": "1. Since hs is tuning his Hyperparameters on the validation set, he would most probably\nover\ufb01t to the validation set which he also used for evaluating the performance of the\nmodel.\n2. One way would be to amend the splitting, is by \ufb01rst keeping a fraction of the training set\naside, for instance 0.1, and then split the remaining .90 into a training and a validation\nset, for instance 0.8 and 0.1.\n3. His new approach uses GridSearchCV with 5-fold cross-validation to tune his Hyper-\nparameters. Since he is using cross validation with \ufb01ve folds, his local CV metrics would\nbetter re\ufb02ect the performance on an unseen data set.\n\u25a0"
  },
  {
    "id": "PRB-253",
    "chapter": "",
    "question": "In the context of Hyperparameter optimization, explain the difference between grid search\nand random search.\nLabelling and bias\nRecommended reading:\n\u201cAdded value of double reading in diagnostic radiology,a systematic review\u201d [8].",
    "solution": "In grid search, a set of pre-determined values is selected by a user for each dimension in\nhis search space, and then thoroughly attempting each and every combination. Naturally, with\nsuch a large search space the number of the required combinations that need to be evaluated\nscale exponentially in the number of dimensions in the grid search.\nIn random search the main difference is that the algorithm samples completely random\npoints for each of the dimensions in the search space. Random search is usually faster and may\neven produce better results.\n\u25a0\nLabelling and bias\nRecommended reading:\n\u201cAdded value of double reading in diagnostic radiology,a systematic review\u201d [8]."
  },
  {
    "id": "PRB-254",
    "chapter": "",
    "question": "282\nChapter 8\nDEEP LEARNING\nNon-invasive methods that forecast the existence of lung nodules (8.47), is a precursor\nto lung cancer. Yet, in spite of acquisition standardization attempts, the manual detection of\nlung nodules still remains predisposed to inter mechanical and observer variability. What is\nmore, it is a highly laborious task.\nFIGURE 8.47: Pulmonary nodules.\nIn the majority of cases, the training data is manually labelled by radiologists who make\nmistakes. Imagine you are working on a classi\ufb01cation problem and hire two radiologists for\nlung cancer screening based on low-dose CT (LDCT). You ask them to label the data, the\n\ufb01rst radiologist labels only the training set and the second the validation set. Then you hire\na third radiologist to label the test set.\n1. Do you think there is a design \ufb02ow in the curation of the data sets?\n2. A friend suggests that all there radiologists read all the scans and label them independ-\nently thus creating a majority vote. What do you think about this idea?\nValidation curve ACC",
    "solution": "There is a potential for bias in certain settings such as this. If the whole training set\nis labelled only by a single radiologist, it may be possible that his professional history would\n328\nChapter 8\nDEEP LEARNING\ninadvertently generate bias into the corpus. Even if we use the form of radiology report reading\nknown as double reading it would not be necessarily true that the annotated scans would be\ndevoid of bias or that the quality would be better [8].\n\u25a0\nValidation curve ACC"
  },
  {
    "id": "PRB-255",
    "chapter": "",
    "question": "Answer the following questions regarding the validation curve visualized in (8.48):\n283\n8.2. PROBLEMS\n20\n40\n60\n80\n100\n0,2\n0,4\n0,6\n0,8\nEPOCH\nERR\nVALID\nTRAIN\nFIGURE 8.48: A validation curve.\n1. Describe in one sentence, what is a validation curve.\n2. Which hyperparameter is being used in the curve?\n3. Which well-known metric is being used in the curve? Which other metric is commonly\nused?\n4. Which positive phenomena happens when we train a NN longer?\n5. Which negative phenomena happens when we train a NN longer than we should?\n6. How this negative phenomena is re\ufb02ected in 8.48?\nValidation curve Loss",
    "solution": "The answers are as follows:\n1. A validation curve displays on a single graph a chosen hyperparameter on the hori-\nzontal axis and a chosen metric on the vertical axis.\n2. The hyperparameter is the number of epochs\n3. The quality metric is the error (1 -accuracy). Accuracy, error = (1`accuracy) or loss are\ntypical quality metrics.\n4. The longer the network is trained, the better it gets on the training set.\n5. At some point the network is \ufb01t too well to the training data and loses its capability to\ngeneralize. While the classi\ufb01er is still improving on the training set, it gets worse on\nthe validation and the test set.\n6. At this point the quality curve of the training set and the validation set diverge.\n\u25a0\nValidation curve Loss"
  },
  {
    "id": "PRB-256",
    "chapter": "",
    "question": "Refer to the validation log-loss curve visualized in (8.49) and answer the following ques-\ntions:\n284\nChapter 8\nDEEP LEARNING\nFIGURE 8.49: Log-loss function curve.\n1. Name the phenomena that starts happening right after the marking by the letter E and\ndescribe why it is happening.\n2. Name three different weight initialization methods.\n3. What is the main idea behind these methods?\n4. Describe several ways how this phenomena can be alleviated.\n5. Your friend, a fellow data-scientist, inspects the code and sees the following Hyper-\nparameters are being used:\nHyperparameter\nValue\nInitial LR\n0.00001\nMomentum\n0.9\nBatch size\n1024\nHe then tells you that the learning rate (LR) is constant and suggests amending the\ntraining pipeline by adding the following code (8.50):\n285\n8.2. PROBLEMS\n1 scheduler = optim.lr_scheduler.ReduceLROnPlateau(opt)\nFIGURE 8.50: A problem with the log-loss curve.\nWhat do you think about his idea?\n6. Provide one reason against the use of the log-loss curve.\nInference",
    "solution": "The answers are as follows:\n1. What we are witnessing is phenomena entitled a plateau. This may happen when the\noptimization protocol can not improve the loss for several epochs.\n2. There possible methods are:\ni Constant\nii Xavier/Glorot uniform\n329\n8.3. SOLUTIONS\niii Xavier/Glorot normal\n3. Good initialization would optimally generate activations that produce initial gradients\nthat are larger than zero. One idea is that the training process would converge faster if\nunit variance is achieved ([16]). Moreover, weights should be selected carefully so that:\ni They are large enough thus preventing gradients from decaying to zero.\nii They are not too large causing activation functions to over saturate.\n4. There are several ways to reduce the problem of plateaus:\ni Add some type of regularization.\nii In cases wherein the plateau happens right at the beginning, amend the way weights\nare initialized.\niii Amending the optimization algorithm altogether, for instance using SGD instead\nof Adam and vice versa.\n5. Since the initial LR is already very low, his suggestion may worsen the situation since\nthe optimiser would not be able to jump off and escape the plateau.\n6. In contrast to accuracy, Log loss has no upper bounds and therefore at times may be\nmore dif\ufb01cult to understand and to explain.\n\u25a0\nInference"
  },
  {
    "id": "PRB-257",
    "chapter": "",
    "question": "You \ufb01nished training a face recognition algorithm, which uses a feature vector of 128\nelements. During inference, you notice that the performance is not that good. A friend tells\nyou that in computer vision faces are gathered in various poses and perspectives. He there-\nfore suggests that during inference you would augment the incoming face \ufb01ve times, run\ninference on each augmented image and then fuse the output probability distributions by\naveraging.\n1. Name the method he is suggesting.\n2. Provide several examples of augmentation that you might use during inference.",
    "solution": "1. Usually data augmentation, is a technique that is heavily used during training, espe-\ncially for increasing the number of instances of minority classes. In this case, augment-\nations are using during inference and this method is entitled Test Time Augmentation\n(TTA).\n2. Here are several image augmentation methods for TTA, with two augmentations shown\nalso in PyTorch.\n330\nChapter 8\nDEEP LEARNING\nHorizontal \ufb02ip\nVertical \ufb02ip\nRotation\nScaling\nCrops\n1 transforms.HorizolntalFlip(p=1)(image)\n2 transforms.VerticalFlip(p=1)(image)\nFIGURE 8.84: Several image augmentation methods for TTA.\n\u25a0"
  },
  {
    "id": "PRB-258",
    "chapter": "",
    "question": "Complete the sentence: If the training loss is insigni\ufb01cant while the test loss is signi\ufb01c-\nantly higher, the network has almost certainly learned features which are not present in an\n[...] set. This phenomena is referred to as [...]\n8.2.9\nOptimization, Loss\nStochastic gradient descent, SGD",
    "solution": "i Unseen\nii Over\ufb01tting\n\u25a0\n8.3.9\nOptimization, Loss\nStochastic gradient descent, SGD"
  },
  {
    "id": "PRB-259",
    "chapter": "",
    "question": "What does the term stochastic in SGD actually mean? Does it use any random number\n286\nChapter 8\nDEEP LEARNING\ngenerator?",
    "solution": "There is no relation to random number generation, the true meaning is the use of batches\nduring the training process.\n\u25a0"
  },
  {
    "id": "PRB-260",
    "chapter": "",
    "question": "Explain why in SGD, the number of epochs required to surpass a certain loss threshold\nincreases as the batch size decreases?\nMomentum",
    "solution": "A larger batch size decreases the variance of the gradient estimation of SGD. Therefore, if\nyour training loop uses larger batches, the model will converge faster. On the other hand, smal-\n331\n8.3. SOLUTIONS\nler batch sizes increase the variance, leading to the opposite phenomena; longer convergence\ntimes.\n\u25a0\nMomentum"
  },
  {
    "id": "PRB-261",
    "chapter": "",
    "question": "How does momentum work? Explain the role of exponential decay in the gradient descent\nupdate rule.",
    "solution": "Momentum introduces an extra term which comprises a moving average which is used\nin gradient descent update rule to exponentially decay the historical gradients Using such\nterm has been demonstrated to accelerate the training process ([11]) requiring less epochs to\nconverge.\n\u25a0"
  },
  {
    "id": "PRB-262",
    "chapter": "",
    "question": "In your training loop, you are using SGD and a logistic activation function which is\nknown to suffer from the phenomenon of saturated units.\n1. Explain the phenomenon.\n2. You switch to using the tanh activation instead of the logistic activation, in your\nopinion does the phenomenon still exists?\n3. In your opinion, is using the tanh function makes the SGD operation to converge\nbetter?",
    "solution": "The answers are as follows:\n1. The derivative of the logistic activation function is extremely small for either negtive or\npositive large inputs.\n2. The use of the tanh function does not alleviate the problem since we can scale and\ntranslate the sigmoid function to represent the tanh function:\ntanh(z) = 2\u03c3(2z) \u2212 1\n(8.76)\nWhile the sigmoid function is centred around 0.5, the tanh activation is centred around\nzero. Similar to the application of BN, centring the activations may aid the optimizer con-\nverge faster. Note: there is no relation to SGD; the issue exists when using other optimization\nfunctions as well.\n\u25a0"
  },
  {
    "id": "PRB-263",
    "chapter": "",
    "question": "Which of the following statements holds true?\ni In stochastic gradient descent we \ufb01rst calculate the gradient and only then adjust weights\nfor each data point in the training set.\nii In stochastic gradient descent, the gradient for a single sample is not so different from\nthe actual gradient, so this gives a more stable value, and converges faster.\niii SGD usually avoids the trap of poor local minima.\n287\n8.2. PROBLEMS\niv SGD usually requires more memory.\nNorms, L1, L2",
    "solution": "The answers are as follows:\ni True.\nii False. In stochastic gradient descent, the gradient for a single sample is quite different\n332\nChapter 8\nDEEP LEARNING\nfrom the actual gradient, so this gives a more noisy value, and converges slower\niii True.\niv False. SGD requires less memory.\n\u25a0\nNorms, L1, L2"
  },
  {
    "id": "PRB-264",
    "chapter": "",
    "question": "Answer the following questions regarding norms.\n1. Which norm does the following equation represent?\n|x1 \u2212 x2| + |y1 \u2212 y2|\n(8.41)\n2. Which formulae does the following equation represent?\n\ufffd\n\ufffd\n\ufffd\n\ufffd\nn\n\ufffd\ni=1\n(xi \u2212 yi)2\n(8.42)\n3. When your read that someone penalized the L2 norm, was the euclidean or the Man-\nhattan distance involved?\n4. Compute both the Euclidean and Manhattan distance of the vectors:\nx1 = [6, 1, 4, 5] and x2 = [2, 8, 3, \u22121].",
    "solution": "1. The L2 norm.\n2. The Euclidean distance which is calculated as the square root of the sum of differences\nbetween each point in a set of two points.\n3. The Manhattan distance is an L1 norm (introduced by Hermann Minkowski) while the\nEuclidean distance is an L2 norm.\n4. The Manhattan distance is:\n|6 \u2212 2| + |1 \u2212 8| + |4 \u2212 3| + |5 \u2212 (\u22121)|\n= 4 + 7 + 1 + 6 = 18\n(8.77)\n5. The Euclidean distance is:\n\ufffd\n(6 \u2212 2)2 + (1 \u2212 8)2 + (4 \u2212 3)2 + (5 \u2212 (\u22121))2\n=\n\u221a\n102\n(8.78)\n\u25a0"
  },
  {
    "id": "PRB-265",
    "chapter": "",
    "question": "You are provided with a pure Python code implementation of the Manhattan distance\nfunction (8.51):\n1 from scipy import spatial\n2 x1=[6,1,4,5]\n3 x2=[2,8,3,-1]\n4 cityblock = spatial.distance.cityblock(x1, x2)\n5 print(\"Manhattan:\", cityblock)\nFIGURE 8.51: Manhattan distance function.\n288\nChapter 8\nDEEP LEARNING\nIn many cases, and for large vectors in particular, it is better to use a GPU for imple-\nmenting numerical computations. PyTorch has full support for GPU\u2019s (and its my favourite\nDL library ... ), use it to implement the Manhattan distance function on a GPU.",
    "solution": "The PyTorch implementation is in (8.85). Note that we are allocating tensors on a GPU\nbut \ufb01rst they are created on a CPU using numpy. This is also always the interplay between\nthe CPU and the GPU when training NN models. Note that this only work if you have GPU\navailable; in case there is no GPU detected, the code has a fallback to the CPU.\n333\nREFERENCES\n1 %reset -f\n2 import torch\n3 import numpy\n4\n5 use_cuda = torch.cuda.is_available()\n6 device = torch.device(\"cuda\" if use_cuda else \"cpu\")\n7 print (device)\n8 x1np=numpy.array([6,1,4,5])\n9 x2np=numpy.array([2,8,3,-1])\n10 x1t=torch.FloatTensor(x1np).to(device) # Move to GPU if available\n11 x2t=torch.FloatTensor(x2np).to(device)\n12 dist = torch.sqrt (torch.pow(x1t - x2t, 2).sum())\n13 dist\n14 >cuda\n15 >tensor(10.0995, device='cuda:0')\nFIGURE 8.85: Manhattan distance function in PyTorch.\n\u25a0"
  },
  {
    "id": "PRB-266",
    "chapter": "",
    "question": "Your friend is training a logistic regression model for a binary classi\ufb01cation problem\nusing the L2 loss for optimization. Explain to him why this is a bad choice and which loss he\nshould be using instead.\n8.3\nSolutions\n8.3.1\nCross Validation\nOn the signi\ufb01cance of cross validation and strati\ufb01cation in particular, refer to \u201cA study\nof cross-validation and bootstrap for accuracy estimation and model selection\u201d [17].\nCV approaches",
    "solution": "The L2 loss is suitable for a target, or a response variable that is continuous. On the other\nhand, in a binary classi\ufb01cation problem using LR we would like the output to match either\nzero or one and a natural candidate for a loss function is the binary cross-entropy loss.\n\u25a0\nReferences\n[1]\nF. T. B. Fuglede. \u2018Jensen-Shannon Divergence and Hilbert space embedding\u2019. In:\nIEEE Int Sym. Information Theory (2004) (cit. on pp. 245, 297).\n[2]\nC. Bennett. \u2018Information Distance\u2019. In: IEEE Trans. Pattern Anal. Inform. Theory.\n44:4 (1998), pp. 1407\u20131423 (cit. on pp. 244, 298).\n[3]\nB. Bigi. \u2018Using Kullback-Leibler Distance for Text Categorization\u2019. In: In Pro-\nceedings of the ECIR-2003, Lecture Notes in Computer Science, Springer-Verlag 2633\n(2003), pp. 305\u2013319 (cit. on pp. 245, 298).\n334\nChapter 8\nDEEP LEARNING\n[4]\nG. Chen. Rethinking the Usage of Batch Normalization and Dropout in the Training of\nDeep Neural Networks. 2019. arXiv: 1905.05928 [cs.LG] (cit. on p. 326).\n[5]\nY. S. Chen et al. \u2018Deep photo enhancer: Unpaired learning for image enhance-\nment from photographs with gans\u2019. In: IEEE Conference on Computer Vision and\nPattern Recognition. 2018, p. 6306 (cit. on p. 231).\n[6]\nI. Ciuca and J. A. Ware. \u2018Layered neural networks as universal approximators\u2019.\nIn: Computational Intelligence Theory and Applications. Ed. by B. Reusch. Berlin,\nHeidelberg: Springer Berlin Heidelberg, 1997, pp. 411\u2013415 (cit. on p. 304).\n[7]\nT. Floyd. Digital Fundamentals. Prentice Hall, 2003 (cit. on p. 252).\n[8]\nH. Geijer and M. Geijer. \u2018Added value of double reading in diagnostic radi-\nology,a systematic review\u2019. In: Insights into Imaging 9 (Mar. 2018). DOI: 10.1007/\ns13244-018-0599-0 (cit. on pp. 282, 328, 329).\n[9]\nX. Glorot and Y. Bengio. \u2018Understanding the dif\ufb01culty of training deep feedfor-\nward neural networks\u2019. In: Journal of Machine Learning Research - Proceedings Track\n9 (Jan. 2010), pp. 249\u2013256 (cit. on pp. 258, 313).\n[10]\nS. Gomar, M. Mirhassani and M. Ahmadi. \u2018Precise digital implementations of\nhyperbolic tanh and sigmoid function\u2019. In: 2016 50th Asilomar Conference on Sig-\nnals, Systems and Computers (2016) (cit. on p. 254).\n[11]\nI. Goodfellow, Y. Bengio and A. Courville. Adaptive computation and machine\nlearning. MIT Press, 2016 (cit. on p. 332).\n[12]\nJ. Gurmeet Singh Manku. \u2018Detecting near-duplicates for web crawling\u2019. In: Pro-\nceedings of the 16th International Conference on World Wide Web (2007), p. 141 (cit.\non pp. 244, 245, 298).\n[13]\nK. He. Deep Residual Learning for Image Recognition. 2015. arXiv: 1512.03385\n(cit. on p. 279).\n[14]\nK. He et al. Delving Deep into Recti\ufb01ers: Surpassing Human-Level Performance on\nImageNet Classi\ufb01cation. 2015. arXiv: 1502.01852 [cs.CV] (cit. on pp. 258, 273).\n[15]\nA. Ignatov et al. \u2018Dslr-quality photos on mobile devices with deep convolu-\ntional networks\u2019. In: IEEE International Conference on Computer Vision (ICCV).\n2017, pp. 3297\u20133305 (cit. on p. 231).\n[16]\nS. Ioffe and C. Szegedy. \u2018Batch Normalization\u2019. In: CoRR abs/1502.03167 (2015).\narXiv: 1502.03167 (cit. on pp. 273, 326, 330).\n335\nREFERENCES\n[17]\nR. Kohavi. \u2018A Study of Cross-Validation and Bootstrap for Accuracy Estima-\ntion and Model Selection\u2019. In: Morgan Kaufmann, 1995, pp. 1137\u20131143 (cit. on\npp. 231, 289).\n[18]\nA. Krizhevsky, I. Sutskever and G. E. Hinton. \u2018ImageNet Classi\ufb01cation with\nDeep Convolutional Neural Networks\u2019. In: Advances in Neural Information Pro-\ncessing Systems. Ed. by F. Pereira et al. Vol. 25. Curran Associates, Inc., 2012,\npp. 1097\u20131105 (cit. on pp. 252, 306).\n[19]\nLibtorch: The PyTorch C++ frontend is a C++14 library for CPU and GPU tensor com-\nputation. 2020 (cit. on pp. 254, 256).\n[20]\nA. Paszke et al. \u2018Automatic differentiation in PyTorch\u2019. In: 31st Conference on\nNeural Information Processing Systems. 2017 (cit. on pp. 266, 267).\n[21]\nP. Ramachandran. Searching for Activation Functions. 2017. arXiv: 1710.05941\n[cs.NE] (cit. on p. 260).\n[22]\nD. E. Rumelhart and G. E. Hinton. \u2018Learning Representations by Back Propagat-\ning Errors\u2019. In: Neurocomputing: Foundations of Research. Cambridge, MA, USA:\nMIT Press, 1988, pp. 696\u2013699 (cit. on pp. 236, 252, 260, 292, 306).\n[23]\nS. Sengupta et al. \u2018Sfsnet: Learning shape, re\ufb02ectance and illuminance of faces\nin the wild\u2019. In: Computer Vision and Pattern Regognition (CVPR). 2018 (cit. on\np. 231).\n[24]\nZ. Shu, E. Yumer and S. Hadap. \u2018Neural face editing with intrinsic image dis-\nentangling\u2019. In: Computer Vision and Pattern Recognition (CVPR) IEEE Conference.\n2017, pp. 5444\u20135453 (cit. on p. 231).\n[25]\nK. Simonyan and A. Zisserman. Very Deep Convolutional Networks for Large-Scale\nImage Recognition. 2014. arXiv: 1409.1556 [cs.CV] (cit. on pp. 263, 265).\n[26]\nP. Sledzinski et al. \u2018The current state and future perspectives of cannabinoids in\ncancer biology\u2019. In: Cancer Medicine 7.3 (2018), pp. 765\u2013775 (cit. on pp. 266, 267).\n[27]\nC. Szegedy et al. \u2018Inception v4, Inception-ResNet and the Impact of Residual\nConnections on Learning\u2019. In: ICLR 2016 Workshop. 2016 (cit. on p. 326).\n[28]\nP. Vincent et al. \u2018Extracting and composing robust features with denoising au-\ntoencoders\u2019. In: Proceedings of the 25th international conference on Machine learning.\n2008, pp. 1096\u20131103 (cit. on p. 326).\n336\nChapter 8\nDEEP LEARNING\n[29]\nJ. Ziv and N. Merhav. \u2018A measure of relative entropy between individual se-\nquences with application to universal classi\ufb01cation\u2019. In: IEEE Transactions on In-\nformation Theory 39(4) (1993), pp. 1270\u20131279 (cit. on pp. 245, 298).\n337\nREFERENCES\n338\nPRACTICE EXAM\nPART V\nCHAPTER\n9\nJOB INTERVIEW MOCK EXAM\nA man who dares to waste one hour of time has not discovered the value of life.\n\u2014 Charles Darwin\nContents\nRules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342\nProblems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343\nPerceptrons\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343\nCNN layers\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343\nClassi\ufb01cation, Logistic regression . . . . . . . . . . . . . . . . . . . . . . 345\nInformation theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347\nFeature extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349\nBayesian deep learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352\nStressful events, such as a job interview, prompt concern and anxiety (as they do for\nvirtually every person), but it\u2019s the lack of preparation that fuels unnecessary nervous-\nness. Many perceive the interview as a potentially threatening event. Testing your\nknowledge in AI using a mock exam, is an effective way to not only identifying your\nweaknesses and to pinpointing the concepts and topics that need brushing up, but\nalso to becoming more relaxed in similar situations. Remember that at the heart of job\ninterview con\ufb01dence is feeling relaxed.\nDoing this test early enough, gives you a head-start before the actual interview, so\nthat you can target areas that require perfection. The exam includes questions from\na wide variety of topics in AI, so that these areas are recognised and it would then\nbe a case of solving all the problems in this book over a period of few months to be\nproperly prepared. Do not worry even if you can not solve any of the problems in the\nexam as some of them are quite dif\ufb01cult.\nDEEP LEARNING JOB INTERVIEW MOCK EXAM\nEXAM INSTRUCTIONS:\nYOU SHOULD NOT SEARCH FOR SOLUTIONS ON THE WEB. MORE GENERALLY, YOU\nARE URGED TO TRY AND SOLVE THE PROBLEMS WITHOUT CONSULTING ANY REFER-\nENCE MATERIAL, AS WOULD BE THE CASE IN A REAL JOB INTERVIEW.\n9.0.1\nRules\nREMARK: In order to receive credits, you must:\ni Show all work neatly.\nii A sheet of formulas and calculators are permitted but not notes or texts.\niii Read the problems CAREFULLY\niv Do not get STUCK at any problem (or in local minima ...) for too much time!\nv After completing all problems, a double check is STRONGLY advised.\nvi You have three hours to complete all questions.\n342\nChapter 9\nJOB INTERVIEW MOCK EXAM\n9.1\nProblems\n9.1.1\nPerceptrons"
  },
  {
    "id": "PRB-267",
    "chapter": "",
    "question": "The following questions refer to the MLP depicted in (9.1).The inputs to the MLP in\n(9.1) are x1 = 0.9 and x2 = 0.7 respectively, and the weights w1 = \u22120.3 and w2 = 0.15\nrespectively. There is a single hidden node, H1. The bias term, B1 equals 0.001.\nx1\nH1\nx2\n\ufffd\nB1\nw1 =\n\u22120.3\nw2 =\n0.15\nout1\n0.001\nInputs\nHidden\nSum\nFIGURE 9.1: Several nodes in a MLP.\n1. We examine the mechanism of a single hidden node, H1. The inputs and weights go\nthrough a linear transformation. What is the value of the output (out1) observed at\nthe sum node?\n2. What is the resulting value from the application of the sum operator?\n3. Using PyTorch tensors, verify the correctness of your answers.\n9.1.2\nCNN layers",
    "solution": ""
  },
  {
    "id": "PRB-268",
    "chapter": "",
    "question": "While reading a paper about the MaxPool operation, you encounter the following code\nsnippet 9.1 of a PyTorch module that the authors implemented. You download their pre-\ntrained model, and examine its behaviour during inference:\n343\n9.1. PROBLEMS\n1 import torch\n2 from torch import nn\n3 class MaxPool001(nn.Module):\n4\ndef __init__(self):\n5\nsuper(MaxPool001, self).__init__()\n6\nself.math = torch.nn.Sequential(\n7\ntorch.nn.Conv2d(3, 32, kernel_size=7, padding=2),\n8\ntorch.nn.BatchNorm2d(32),\n9\ntorch.nn.MaxPool2d(2, 2),\n10\ntorch.nn.MaxPool2d(2, 2),\n11\n)\n12\ndef forward(self, x):\n13\nprint (x.data.shape)\n14\nx = self.math(x)\n15\nprint (x.data.shape)\n16\nx = x.view(x.size(0), -1)\n17\nprint (\"Final shape:{}\",x.data.shape)\n18\nreturn x\n19 model = MaxPool001()\n20 model.eval()\n21 x = torch.rand(1, 3, 224, 224)\n22 out=model.forward(x)\nCODE 9.1: A CNN in PyTorch\nThe architecture is presented in 9.2:\n344\nChapter 9\nJOB INTERVIEW MOCK EXAM\nFIGURE 9.2: Two consecutive MaxPool layers.\nPlease run the code and answer the following questions:\n1. In MaxPool2D(2,2), what are the parameters used for?\n2. After running line 8, what is the resulting tensor shape?\n3. Why does line 20 exist at all?\n4. In line 9, there is a MaxPool2D(2,2) operation, followed by yet\na second MaxPool2D(2,2). What is the resulting tensor shape after running line 9?\nand line 10?\n5. A friend who saw the PyTorch implementation, suggests that lines 9 and 10 may\nbe replaced by a single MaxPool2D(4,4,) operation while producing the exact same\nresults. Do you agree with him? Amend the code and test your assertion.\n9.1.3\nClassification, Logistic regression",
    "solution": ""
  },
  {
    "id": "PRB-269",
    "chapter": "",
    "question": "To study factors that affect the survivability of humans infected with COVID19 using\nlogistic regression, a researcher considers the link between lung cancer and COVID19 as a\n345\n9.1. PROBLEMS\nplausible risk factor. The predictor variable is a count of removed pulmonary nodules (Fig.\n9.3) in the lungs.\nFIGURE 9.3: Pulmonary nodules.\nThe response variable Y measures whether the patient shows any remission (as in the\nmanifestations of a disease, e. g. yes=1, no=0) when the pulmonary nodules count shifts up\nor down. The output from training a logistic regression classi\ufb01er is as follows:\nStandard\nParameter\nDF\nEstimate\nError\nIntercept\n1\n-4.8792\n1.0732\nPulmonary nodules\n1\n0.0258\n0.0194\n1. Estimate the probability of improvement when the count of removed pulmonary nod-\nules of a patient is 33.\n2. Find out the removed pulmonary nodules count at which the estimated probability of\nimprovement is 0.5.\n3. Find out the estimated odds ratio of improvement for an increase of 1, in the total\nremoved pulmonary nodule count.\n4. Obtain a 99% con\ufb01dence interval for the true odds ratio of improvement increase of\n1 in the total removed pulmonary nodule count. Remember that The most common\ncon\ufb01dence levels are 90%, 95%, 99%, and 99.9%.\n346\nChapter 9\nJOB INTERVIEW MOCK EXAM\nCon\ufb01dence Level\nz\n90%\n1.645\n95%\n1.960\n99%\n2.576\n99.9%\n3.291\nTABLE 9.1: Common con\ufb01dence levels\nTable 9.1 lists the z values for these levels.\n9.1.4\nInformation theory",
    "solution": ""
  },
  {
    "id": "PRB-270",
    "chapter": "",
    "question": "This question discusses the link between binary classi\ufb01cation, information gain and\ndecision trees. Recent research suggests that the co-existence of in\ufb02uenza (Fig. 9.4) and\nCOVID19 virus may decrease the survivability of humans infected with the COVID 19\nvirus. The data (Table 9.2) comprises a training set of feature vectors with corresponding\nclass labels which a researcher intents classifying using a decision tree.\nTo study factors affecting COVID19 eradication, the deep-learning researcher collects\ndata regrading two independent binary variables; \u03b81 (T/F) indicating whether the patient is\na female, and \u03b82 (T/F) indicating whether the human tested positive for the in\ufb02uenza virus.\nThe binary response variable, \u03b3, indicates whether eradication was observed (e.g. eradica-\ntion=+, no eradication=-).\n347\n9.1. PROBLEMS\nFIGURE 9.4: The in\ufb02uenza virus.\nReferring to Table (9.2), each row indicates the observed values, columns (\u03b8i) denote\nfeatures and rows (< \u03b8i, \u03b3i >) denote labelled instances while class label (\u03b3) denotes whether\neradication was observed.\n\u03b3\n\u03b81\n\u03b82\n+\nT\nT\n-\nT\nF\n+\nT\nF\n+\nT\nT\n-\nF\nT\nTABLE 9.2: Decision trees and the COVID19 virus.\n1. Describe what is meant by information gain.\n2. Describe in your own words how does a decision tree work.\n3. Using log2, and the provided dataset, calculate the sample entropy H(\u03b3).\n4. What is the information gain IG(X1) \u2261 H(\u03b3) \u2212 H(|\u03b81) for the provided training\ncorpus?\n348\nChapter 9\nJOB INTERVIEW MOCK EXAM",
    "solution": ""
  },
  {
    "id": "PRB-271",
    "chapter": "",
    "question": "What is the entropy of a biased coin? Suppose a coin is biased such that the probability\nof \u2018heads\u2019 is p(xh) = 0.98.\n1. Complete the sentence: We can predict \u2018heads\u2019 for each \ufb02ip with an accuracy of [__-\n_]%.\n2. Complete the sentence: If the result of the coin toss is \u2018heads\u2019, the amount of Shannon\ninformation gained is [___] bits.\n3. Complete the sentence: If the result of the coin toss is \u2018tails\u2019, the amount of Shannon\ninformation gained is [___] bits.\n4. Complete the sentence: It is always true that the more information is associated with\nan outcome, the [more/less] surprising it is.\n5. Provided that the ratio of tosses resulting in \u2018heads\u2019 is p(xh), and the ratio of tosses\nresulting in \u2018tails\u2019 is p(xt), and also provided that p(xh) + p(xt) = 1, what is the\nformula for the average surprise?\n6. What is the value of the average surprise in bits?",
    "solution": ""
  },
  {
    "id": "PRB-272",
    "chapter": "",
    "question": "Complete the sentence: The relative entropy D(p||q) is the measure of (a) [___] between\ntwo distributions. It can also be expressed as a measure of the (b)[___] of assuming that the\ndistribution is q when the (c)[___] distribution is p.\n9.1.5\nFeature extraction",
    "solution": ""
  },
  {
    "id": "PRB-273",
    "chapter": "",
    "question": "A data scientist extracts a feature vector from an image using a pre-trained ResNet34\nCNN (9.5).\n349\n9.1. PROBLEMS\n1 import torchvision.models as models\n2 ...\n3 res_model = models.resnet34(pretrained=True)\nFIGURE 9.5: PyTorch declaration for a pre-trained ResNet34 CNN (simpli\ufb01ed).\nHe then applies the following algorithm, entitled xxx on the image (9.2).\nCODE 9.2: An unknown algorithm in C++11\n1 void xxx(std::vector<float>& arr){\n2\nfloat mod = 0.0;\n3\nfor (float i : arr) {\n4\nmod += i * i;\n5\n}\n6\nfloat mag = std::sqrt(mod);\n7\nfor (float & i : arr) {\n8\ni /= mag;\n9\n}\n10 }\nWhich results in this vector (9.6):\n0.7766 0.4455 0.8342 0.6324 \u00b7 \u00b7 \u00b7\nk = 512\nValues after applying xxx to a k-element FV.\nFIGURE 9.6: A one-dimensional 512-element embedding for a single image from the Res-\nNet34 architecture.\nName the algorithm that he used and explain in detail why he used it.\n350\nChapter 9\nJOB INTERVIEW MOCK EXAM",
    "solution": ""
  },
  {
    "id": "PRB-274",
    "chapter": "",
    "question": "[FEATURE EXTRACTION]\nThe following question discusses the method of \ufb01xed feature extraction from layers of the\nVGG19 architecture for the classi\ufb01cation of the COVID19 pathogen. It depicts FE principles\nwhich are applicable with minor modi\ufb01cations to other CNNs as well. Therefore, if you hap-\npen to encounter a similar question in a job interview, you are likely be able to cope with it\nby utilizing the same logic.\nIn (Fig. 9.7), 2 different classes of human cells are displayed; infected and not-infected,\nwhich were curated from a dataset of 4K images labelled by a majority vote of two expert\nvirologists. Your task is to use FE to correctly classify the images in the dataset.\nFIGURE 9.7: A dataset of human cells infected by the COVID19 pathogen.\nTable (9.3) presents an incomplete listing of the of the VGG19 architecture. As depicted,\nfor each layer the number of \ufb01lters (i. e. neurons with unique set of parameters), learnable\nparameters (e. g. weights and biases), and FV size are presented.\n351\n9.1. PROBLEMS\nLayer name\n#Filters\n#Parameters\n# Features\nconv4_3\n512\n2.3M\n512\nfc6\n4,096\n103M\n4,096\nfc7\n4,096\n17M\n4,096\noutput\n1,000\n4M\n-\nTotal\n13,416\n138M\n12,416\nTABLE 9.3: Incomplete listing of the of the VGG19 architecture\n1. Describe how the VGG19 CNN may be used as \ufb01xed FE for a classi\ufb01cation task. In\nyour answer be as detailed as possible regarding the stages of FE and the method used\nfor classi\ufb01cation.\n2. Referring to Table (9.3), suggest three different ways in which features can be extrac-\nted from a trained VGG19 CNN model. In each case, state the extracted feature layer\nname and the size of the resulting FE.\n3. After successfully extracting the features for the 4k images from the dataset, how can\nyou now classify the images into their respective categories?\n9.1.6\nBayesian deep learning",
    "solution": ""
  },
  {
    "id": "PRB-275",
    "chapter": "",
    "question": "A recently published paper presents a new layer for Bayesian neural networks (BNNs).\nThe layer behaves as follows. During the feed-forward operation, each of the hidden neurons\nHn , n \u2208 {1, 2, } in the neural network in (Fig. 9.8) may, or may not \ufb01re, independently\nof each other, according to a known prior distribution.\n352\nChapter 9\nJOB INTERVIEW MOCK EXAM\n\u03b81\n\u03b82\nH1\nH2\nFIGURE 9.8: Likelihood in a BNN model.\nThe chance of \ufb01ring, \u03b3, is the same for each hidden neuron. Using the formal de\ufb01nition,\ncalculate the likelihood function of each of the following cases:\n1. The hidden neuron is distributed according to X \u223c B(n, \u03b3) random variable and \ufb01res\nwith a probability of \u03b3. There are 100 neurons and only 20 are \ufb01red.\n2. The hidden neuron is distributed according to X \u223c U(0, \u03b3) random variable and \ufb01res\nwith a probability of \u03b3.",
    "solution": ""
  },
  {
    "id": "PRB-276",
    "chapter": "",
    "question": "During pregnancy, the Placenta Chorion Test is commonly used for the diagnosis of\nhereditary diseases (Fig. 9.9).\nFIGURE 9.9: Foetal surface of the placenta\nAssume, that a new test entitled the Placenta COVID19 Test has the exact same proper-\nties as the Placenta Chorion Test. The test has a probability of 0.95 of being correct whether\nor not a COVID19 pathogen is present. It is known that 1/100 of pregnancies result in\n353\n9.1. PROBLEMS\nCOVID19 virus being passed to foetal cells. Calculate the probability of a test indicating\nthat a COVID19 virus is present.",
    "solution": ""
  },
  {
    "id": "PRB-277",
    "chapter": "",
    "question": "A person who was unknowingly infected with the COVID19 pathogen takes a walk in\na park crowded with people. Let y be the number of successful infections in 5 independent\nsocial interactions or infection attempts (trials), where the probability of \u201csuccess\" (infecting\nsomeone else) is \u03b8 in each trial. Suppose your prior distribution for \u03b8 is as follows: P(\u03b8 =\n1/2) = 0.25, P(\u03b8 = 1/6) = 0.5, and P(\u03b8 = 1/4) = 0.25.\n1. Derive the posterior distribution p(\u03b8|y).\n2. Derive the prior predictive distribution for y.",
    "solution": ""
  },
  {
    "id": "PRB-278",
    "chapter": "",
    "question": "The 2014 west African Ebola (Fig. 9.10) epidemic has become the largest and fastest-\nspreading outbreak of the disease in modern history with a death tool far exceeding all past\noutbreaks combined. Ebola (named after the Ebola River in Zaire) \ufb01rst emerged in 1976 in\nSudan and Zaire and infected over 284 people with a mortality rate of 53%.\nFIGURE 9.10: The Ebola virus.\nThis rare outbreak, underlined the challenge medical teams are facing in containing epi-\ndemics. A junior data scientist at the centre for disease control (CDC) models the possible\nspread and containment of the Ebola virus using a numerical simulation. He knows that out\nof a population of k humans (the number of trials), x are carriers of the virus (success in\n354\nChapter 9\nJOB INTERVIEW MOCK EXAM\nstatistical jargon). He believes the sample likelihood of the virus in the population, follows a\nBinomial distribution:\nL(\u03b3) =\n\uf8eb\n\uf8ed n\ny\n\uf8f6\n\uf8f8 \u03b3y(1 \u2212 \u03b3)n\u2212y,\n\u03b3 \u2208 [0, 1],\ny = 1, 2, . . . , n\n,\n(9.1)\nwhere:\n\uf8eb\n\uf8ed n\ny\n\uf8f6\n\uf8f8 =\nn!\n(n \u2212 y)!y!.\n(9.2)\nAs the senior researcher in the team, you guide him that his parameter of interest is \u03b3, the\nproportion of infected humans in the entire population.\nThe expectation and variance of the binomial are:\nE(y|\u03b3, n) = n\u03b3, , V (y|\u03b3, n) = n\u03b3(1 \u2212 \u03b3).\n(9.3)\nAnswer the following:\n1. For the likelihood function of the form lx(\u03b3) = log Lx(\u03b3) what is the log-likelihood\nfunction?\n2. Find the log-likelihood function ln (L(\u03b3))\n3. Find the gradient vector g(\u03b3)\n4. Find the Hessian matrix H(\u03b3)\n5. Find the Fisher information I(\u03b3)\n6. In a population spanning 10,000 individuals, 300 were infected by Ebola. Find the\nMLE for \u03b3 and the standard error associated with it.\n355\n9.1. PROBLEMS\n356\nVOLUME TWO\nPART VI\nCHAPTER\n10\nVOLUME TWO - PLAN\nNothing exists until it is measured.\n\u2014 Niels Bohr, 1985\nContents\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nAI system design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nAdvanced CNN topologies . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n1D CNN\u2019s\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n3D CNN\u2019s\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nData augmentations\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nObject detection\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nObject segmentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nSemantic segmentation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nInstance segmentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nImage classi\ufb01cation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nImage captioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nNLP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360\nRNN\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nLSTM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nGANs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nAdversarial attacks and defences . . . . . . . . . . . . . . . . . . . . . . . . . 361\nVariational auto encoders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nFCN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nSeq2Seq\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nMonte carlo, ELBO, Re-parametrization\n. . . . . . . . . . . . . . . . . . . . 361\n10.1. INTRODUCTION\nText to speech . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nSpeech to text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nCRF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nQuantum computing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\nRL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n10.1\nIntroduction\nI\nT is important at the outset to understand we could not possibly include\neverything we wanted to include in the \ufb01rst VOLUME of this series. While\nthe \ufb01rst volume is meant to introduce many of the core subjects in AI, the\nsecond volume takes another step down that road and includes numerous,\nmore advanced subjects. This is a short glimpse into the plan for VOLUME-2 of this\nseries. This second volume focuses on more advanced topics in AI\n10.2\nAI system design\n10.3\nAdvanced CNN topologies\n10.4\n1D CNN\u2019s\n10.5\n3D CNN\u2019s\n10.6\nData augmentations\n10.7\nObject detection\n10.8\nObject segmentation\n10.9\nSemantic segmentation\n10.10\nInstance segmentation\n10.11\nImage classification\n10.12\nImage captioning\n10.13\nNLP\n360\nChapter 10\nVOLUME TWO - PLAN\n10.14\nRNN\n10.15\nLSTM\n10.16\nGANs\n10.17\nAdversarial attacks and defences\n10.18\nVariational auto encoders\n10.19\nFCN\n10.20\nSeq2Seq\n10.21\nMonte carlo, ELBO, Re-parametrization\n10.22\nText to speech\n10.23\nSpeech to text\n10.24\nCRF\n10.25\nQuantum computing\n10.26\nRL\n361\n10.26. RL\n362\nList of Tables\nTumour eradication statistics. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n17\nCommon con\ufb01dence levels.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\nTumour shrinkage in rats.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n22\nProbability values of hereditary-disease detection. . . . . . . . . . . . . . . . .\n67\nDecision trees and frogs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n95\nDecision trees and Cannabinoids administration . . . . . . . . . . . . . . . . .\n96\nDecision trees and star expansion.\n. . . . . . . . . . . . . . . . . . . . . . . . .\n97\nDecision trees and radiation therapy. . . . . . . . . . . . . . . . . . . . . . . . .\n98\nSplitting on \u03b81. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113\nSplitting on \u03b81. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\nSplitting on \u03b82. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\nForward-mode AD table for y = g(x1, x2) = ln(x1)+x1x2 evaluated at (x1, x2) =\n(e2; \u03c0) and setting \u02d9x1 = 1 to compute \u2202y\n\u2202x1.\n. . . . . . . . . . . . . . . . . . 169\nForward-mode AD table for y = g(x1, x2) = ln(x1)+x1x2 evaluated at (x1, x2) =\n(e2; \u03c0) and setting \u02d9x1 = 1 (seed values are mentioned here: 3) to compute\n\u2202y\n\u2202x1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171\nImageNet-pretrained CNNs. Ensembles of these CNN architectures have been\nextensively studies and evaluated in various ensembling approaches. . . 193\nIncomplete listing of the VGG19 architecture . . . . . . . . . . . . . . . . . . . 209\nIncomplete listing of the VGG11 architecture. . . . . . . . . . . . . . . . . . . . 265\nComputed values for the Sigmoid and the Sigmoid approximation. . . . . . . 310\nCommon con\ufb01dence levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347\nDecision trees and the COVID19 virus. . . . . . . . . . . . . . . . . . . . . . . . 348\nIncomplete listing of the of the VGG19 architecture . . . . . . . . . . . . . . . . 352\nLIST OF TABLES\n364\nList of Figures\nExamples of two sigmoid functions.\n. . . . . . . . . . . . . . . . . . . . . . . .\n15\nPulmonary nodules (left) and breast cancer (right). . . . . . . . . . . . . . . . .\n16\nA multi-detector positron scanner used to locate tumours.\n. . . . . . . . . . .\n18\nA dental amalgam.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\nA chain of spherical bacteria.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n20\nCannabis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\nLogistic regression in CPP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n23\nA linear model in PyTorch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\nLogistic regression methods in Python. . . . . . . . . . . . . . . . . . . . . . . .\n25\nLogistic regression methods in Python. . . . . . . . . . . . . . . . . . . . . . . .\n26\nLogistic regression methods in Python. . . . . . . . . . . . . . . . . . . . . . . .\n27\nOdds vs. probability values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n30\nBinary entropy.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n39\nLogistic regression in C++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n39\nHistopathology for pancreatic cancer cells.\n. . . . . . . . . . . . . . . . . . . .\n44\nBosons and fermions: particles with half-integer spin are fermions.\n. . . . . .\n46\nFoetal surface of the placenta\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n47\nThe Dercum disease . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n47\nThe New York Stock Exchange. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n48\nHedge funds and monkeys. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n49\nDialect detection.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n49\nThe Morse telegraph code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n50\nThe Ebola virus. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n52\nLikelihood in a BNN model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n55\nOnOffLayer in a BNN model. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n56\nA Dropout layer (simpli\ufb01ed form). . . . . . . . . . . . . . . . . . . . . . . . . .\n56\nA Bayesian Neural Network Model . . . . . . . . . . . . . . . . . . . . . . . . .\n57\nThe Maxwell-Boltzmann distribution.\n. . . . . . . . . . . . . . . . . . . . . . .\n58\nA QuantumDrop layer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n58\nThe binomial distribution. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n59\nZ-score . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n62\nLIST OF FIGURES\nConditional probability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n63\nVenn diagram of the intersected events A and B in probability space H . . . .\n63\nAnnotated components of the Bayes formula (eq. 3.23) . . . . . . . . . . . . . .\n64\nMutual information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n86\nRe\ufb02ection on the motive power of \ufb01re. . . . . . . . . . . . . . . . . . . . . . . .\n87\nNatural (ln), binary (log2) and common (log10) logarithms. . . . . . . . . . . . .\n88\nA Frog in its natural habitat. Photo taken by my son. . . . . . . . . . . . . . . .\n95\nCannabis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n96\nShannon's \ufb01ve element communications system. . . . . . . . . . . . . . . . . .\n99\nAn octahedral dice. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\nLogarithms in information theory.\n. . . . . . . . . . . . . . . . . . . . . . . . . 102\nH vs. Probability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\nShannon information gain for a biased coin toss. . . . . . . . . . . . . . . . . . 107\nAverage surprise\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\nFirst split. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\nEntropy before splitting. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\nEntropy before splitting. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\nMutual Information between H(S) & H(D). . . . . . . . . . . . . . . . . . . . . 117\nIntermediate value theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\nA Computation graph with intermediate values as nodes and operations as\narcs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\nAn expression graph for g(x). Constants are shown in gray, crossed-out since\nderivatives should not be propagated to constant operands.\n. . . . . . . 127\nAn expression graph for g(x). Constants are shown in gray, crossed-out since\nderivatives should not be propagated to constant operands.\n. . . . . . . 127\nx2 Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133\nForward pass for the sigmoid function. . . . . . . . . . . . . . . . . . . . . . . . 135\nPyTorch syntax for autograd.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\nA typical binary classi\ufb01cation problem.\n. . . . . . . . . . . . . . . . . . . . . . 137\nAn expression graph for g(x). Constants are shown in gray, crossed-out since\nderivatives should not be propagated to constant operands.\n. . . . . . . 139\nAn expression graph for g(x). Constants are shown in gray, crossed-out since\nderivatives should not be propagated to constant operands.\n. . . . . . . 140\nA computation graph for g(x) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141\nA Tangent line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147\n366\nChapter 10\nLIST OF FIGURES\nForward and backward passes for the sigmoid activation function in pure\nPython. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\nForward and backward for the sigmoid function in Autograd. . . . . . . . . . 159\nForward and backward for the ReLU function in Autograd. . . . . . . . . . . . 160\nForward pass for equation (5.23) using pure Python. . . . . . . . . . . . . . . . 161\nForward pass for equation (5.23). . . . . . . . . . . . . . . . . . . . . . . . . . . 161\nBackward pass for equation (5.23). . . . . . . . . . . . . . . . . . . . . . . . . . 162\nInvoking arctanh using gradcheck\n. . . . . . . . . . . . . . . . . . . . . . . . . 162\nAutograd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165\nAutograd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166\nA Computation graph for g(x1, x2) in 5.1 . . . . . . . . . . . . . . . . . . . . . . 168\nA derivative graph for g(x1, x2) in 5.1 . . . . . . . . . . . . . . . . . . . . . . . . 169\nPython code- AD of the function g(x1, x2) . . . . . . . . . . . . . . . . . . . . . 170\nPython code- AD of the function g(x1, x2) . . . . . . . . . . . . . . . . . . . . . 172\nSigmoid in SymPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nSigmoid gradient in SymPy\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nSigmoid gradient in SymPy\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nSymPy gradient of the Sigmoid() function . . . . . . . . . . . . . . . . . . . . . 174\nSymPy imports\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175\nLikelihood function using SymPy . . . . . . . . . . . . . . . . . . . . . . . . . . 176\nBeta distribution using SymPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177\nA plot of the Beta distribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\nA plot of the Beta distribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179\nA plot of the Posterior with the provided data samples. . . . . . . . . . . . . . 181\nA speci\ufb01c ensembling approach . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\nA speci\ufb01c ensembling approach . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\nSampling approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\nSampling approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\nPyTorch code snippet for an ensemble . . . . . . . . . . . . . . . . . . . . . . . 191\nA typical binary classi\ufb01cation problem.\n. . . . . . . . . . . . . . . . . . . . . . 194\nPyTorch code snippet for an ensemble . . . . . . . . . . . . . . . . . . . . . . . 195\nPyTorch code snippet for an ensemble . . . . . . . . . . . . . . . . . . . . . . . 196\nPyTorch code snippet for an ensemble . . . . . . . . . . . . . . . . . . . . . . . 197\nA learning rate schedule. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n367\nLIST OF FIGURES\nA one-dimensional 512-element embedding for a single image from the Res-\nNet34 architecture. While any neural network can be used for FE, depic-\nted is the ResNet CNN architecture with 34 layers. . . . . . . . . . . . . . 206\nPyTorch decleration for a pre-trained ResNet34 CNN (simpli\ufb01ed). . . . . . . . 206\nA dataset of 4K histopathology WSI from three severity classes: A, B and C. . 209\nPyTorch code snippet for extracting the fc7 layer from a pre-trained VGG19\nCNN model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210\nPyTorch code skeleton for extracting a 512-dimensional FV from a pre-trained\nResNet34 CNN model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\nPyTorch code skeleton for extracting a 512-dimensional FV from a pre-trained\nResNet34 CNN model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212\nSkin lesion categories. An exemplary visualization of melanoma. . . . . . . . 214\nArtistic style transfer using the style of Francis Picabia\u2019s Udnie painting. . . . 215\nPyTorch declaration for a pre-trained ResNet34 CNN. . . . . . . . . . . . . . . 216\nPyTorch code snippet for extracting the fc7 layer from a pre-trained VGG19\nCNN model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220\nPyTorch code snippet for extracting the fc7 layer from a pre-trained VGG19\nCNN model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221\nTwo CV approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231\nStrati\ufb01ed K-fold . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232\nA speci\ufb01c CV approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234\nA padding approach\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\nA padding approach\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238\nConvolution and correlation in python . . . . . . . . . . . . . . . . . . . . . . . 239\nA 3 by 3 convolution kernel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\nConvolution and correlation in python . . . . . . . . . . . . . . . . . . . . . . . 240\nPyTorch declaration for a pre-trained ResNet34 CNN (simpli\ufb01ed). . . . . . . . 242\nlisting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242\nA one-dimensional 512-element embedding for a single image from the Res-\nNet34 architecture.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242\nAn unknown algorithm\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243\nJaccard similarity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244\nSeveral nodes in a MLP.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248\nSeveral nodes in a MLP.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248\nA basic MLP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250\nMLP operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250\n368\nChapter 10\nLIST OF FIGURES\nA single layer perceptron.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252\nLogical AND gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253\nExamples of two sigmoid functions and an approximation. . . . . . . . . . . . 254\nForward pass for the Sigmoid function using Libtorch . . . . . . . . . . . . . . 255\nEvaluation of the sigmoid and its derivative using Libtorch . . . . . . . . . . . 255\nExamples of two tanh functions.\n. . . . . . . . . . . . . . . . . . . . . . . . . . 256\nA simple NN based on tanh in PyTorch. . . . . . . . . . . . . . . . . . . . . . . 257\nA small CNN composed of tanh blocks. . . . . . . . . . . . . . . . . . . . . . . 258\nA small CNN composed of ReLU blocks.\n. . . . . . . . . . . . . . . . . . . . . 259\nA confusion metrics for functioning (N) temperature sensors. P stands for\nmalfunctioning devices.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 261\nReceiver Operating Characteristic curve. . . . . . . . . . . . . . . . . . . . . . . 261\nRUC AUC\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262\nXGBOOST for binary classi\ufb01cation. . . . . . . . . . . . . . . . . . . . . . . . . . 263\nCNN arithmetics on the VGG11 CNN model. . . . . . . . . . . . . . . . . . . . 264\nA Dropout layer (simpli\ufb01ed form). . . . . . . . . . . . . . . . . . . . . . . . . . 266\nA Bayesian Neural Network Model . . . . . . . . . . . . . . . . . . . . . . . . . 267\nTwo consecutive Dropout layers\n. . . . . . . . . . . . . . . . . . . . . . . . . . 267\nA CNN based classi\ufb01cation system. . . . . . . . . . . . . . . . . . . . . . . . . . 269\nA small \ufb01lter for a CNN\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269\nThe result of applying the \ufb01lter. . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\nInput to MaxPool2d operation.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 271\nTwo consecutive MaxPool layers. . . . . . . . . . . . . . . . . . . . . . . . . . . 273\nNormal distribution in Python. . . . . . . . . . . . . . . . . . . . . . . . . . . . 274\nA convolution and BN applied to an RGB image. . . . . . . . . . . . . . . . . . 275\nA mistake in a CNN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276\nA CNN block\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278\nA CNN block\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279\nA resnet CNN block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\nHyperparameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281\nPulmonary nodules. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\nA validation curve. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284\nLog-loss function curve.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285\nA problem with the log-loss curve. . . . . . . . . . . . . . . . . . . . . . . . . . 286\nManhattan distance function. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288\nConvolution and correlation in python . . . . . . . . . . . . . . . . . . . . . . . 295\nConvolution and correlation in python . . . . . . . . . . . . . . . . . . . . . . . 295\n369\nLIST OF FIGURES\nThe idea of hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298\nMLP operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300\nMLP operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301\nMLP operations- values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302\nHidden layer values, simple MLP. . . . . . . . . . . . . . . . . . . . . . . . . . . 303\nMLP operations- values at the output. . . . . . . . . . . . . . . . . . . . . . . . 303\nMLP operations- Softmax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\nLogical AND: B=-2.5\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305\nLogical AND: B=-0.25 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305\nLogical AND gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306\nBackward pass for the Sigmoid function using Libtorch. . . . . . . . . . . . . . 307\nEvaluation of the sigmoid and its derivative in C++ using Libtorch. . . . . . . 308\nForward pass for the Sigmoid function approximation in C++ using Libtorch. 309\nPrinting the values for Sigmoid and Sigmoid function approximation in C++\nusing Libtorch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309\nForward pass for tanh using pure Python. . . . . . . . . . . . . . . . . . . . . . 311\nTanh in PyTorch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312\nInvoking gradcheck on tanh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\nA plot of the Swish activation function.\n. . . . . . . . . . . . . . . . . . . . . . 315\nTP, TN, FP, FN. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316\nReceiver Operating Characteristic curve. . . . . . . . . . . . . . . . . . . . . . . 317\nConvolutional block from the VGG11 architecture. . . . . . . . . . . . . . . . . 319\nEquivalence of two consecutive dropout layers . . . . . . . . . . . . . . . . . . 321\nThe result of applying the \ufb01lter. . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\nThe result of applying a ReLU activation.\n. . . . . . . . . . . . . . . . . . . . . 322\nThe result of applying a MaxPool layer.\n. . . . . . . . . . . . . . . . . . . . . . 322\nOutput of the MaxPool2d operation. . . . . . . . . . . . . . . . . . . . . . . . . 323\nA single MaxPool layer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\nNormal distribution in Python: from scratch. . . . . . . . . . . . . . . . . . . . 325\nThe derivative of a Normal distribution in Python. . . . . . . . . . . . . . . . . 325\nA resnet CNN block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\nSeveral image augmentation methods for TTA. . . . . . . . . . . . . . . . . . . 331\nManhattan distance function in PyTorch. . . . . . . . . . . . . . . . . . . . . . . 334\nSeveral nodes in a MLP.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343\nTwo consecutive MaxPool layers. . . . . . . . . . . . . . . . . . . . . . . . . . . 345\nPulmonary nodules. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346\n370\nChapter 10\nLIST OF FIGURES\nThe in\ufb02uenza virus. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348\nPyTorch declaration for a pre-trained ResNet34 CNN (simpli\ufb01ed). . . . . . . . 350\nA one-dimensional 512-element embedding for a single image from the Res-\nNet34 architecture.\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350\nA dataset of human cells infected by the COVID19 pathogen. . . . . . . . . . . 351\nLikelihood in a BNN model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353\nFoetal surface of the placenta\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 353\nThe Ebola virus. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354\n371\nLIST OF FIGURES\n372\nAlphabetical Index\nA\nA 2D convolution. . . . . . . . . . . . . . . . . .235\nA 512 dimension embedding. . . . . . .206\nA mathematical theory of\ncommunication . . . . . . . . . . . . . 90\nA random forest . . . . . . . . . . . . . . . . . . . 187\nACC. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .329\nAccuracy . . . . . . . . . . . . . . . . . 251, 283, 329\nActivation functions . 125, 135 ff., 139 ff.,\n157 f., 160, 163, 165, 168, 248,\n256, 301, 306\nActivation layer . . . . . . . . . . . . . . . 253, 306\nAD . . . . . . . . . . . . . . . . . 123 f., 137, 140, 166\nAdam . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330\nAdditivity property. . . . . . . . . . . . . . . .103\nAlexNet. . . . . . . . . . . . . . . . . . . . . . .205, 207\nAlgorithmic differentiation. . . .125, 135,\n137, 139 ff., 146, 157 f., 160, 163,\n165, 168\nAlzheimer\u2019s disease. . . . . . . . . . . . . . . . .20\nAmalgam \ufb01llings . . . . . . . . . . . . . . . . . . . 18\nAnalytical gradients . . . . . . . . . . . . . . . 134\nAnalyze a paper . . . . . . . . . . . . . . . . . . . 260\nAND logic gate . . . . . . . . . . . . . . . . . . . . 252\nANN. . . . . . . . . . . . . . . . . . . . . . . . . . .15, 135\nAnnotated probabilities . . . . . . . . . . . . . 62\nAnnotations . . . . . . . . . . . . . . . . . . . . . . . 282\nANNs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\nANOVA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\nApproaches for combining predictors\n190, 199\nArithmetic operations . . . . . . . . . 138, 163\nArithmetical methods . . . . . . . . . . . . . . . 41\nArti\ufb01cial neural networks . . . . . . . 12, 15\nAUC . . . . . . . . . . . . . . . . . . . . . . . . . . 261, 316\nAugmentation . . . . . . . . . . . . . . . . . . . . . 222\nAugmentations . . . . . . . . . . . . . . . . . . . . . . 8\nAuto correlation. . . . . . . . . . . . . . .235, 291\nAutoAugment . . . . . . . . . . . . . . . . . . . . . 223\nAutoencoder . . . . . . . . . . . . . . . . . . 279, 326\nAutoGrad . . . . . . . . . . . . . . . . . . . . . 158, 173\nAutograd124 f., 135\u2013141, 157 f., 160, 163,\n165, 168, 310\nAutomatic differentiation . . . . 123 f., 173\nAveraging and majority voting. . . . .202\nB\nBack-propagation in perceptrons . . 249,\n301\nBack-propogation. . . . . . . . . . . . . . . . . .247\nBackprop learning . . . . . . . . . . . . . . . . . 134\nBackprop learning rule . . . . . . . . . . . . 134\nBackpropagation . . . . . . . . . 123, 134, 158\nBackpropagation algorithm . . . 135, 156\nBackward pass125, 127, 135, 137, 139 ff.,\n157 f., 160, 163, 165, 168\nBagging. . . . . . . . . . . . . .186, 189, 193, 198\nBasic laws of logarithms . . . . . . . . . . . . 88\nBatch normalization. . . . . . . . . . .273, 324\nBatchNorm2D . . . . . . . . . . . . . . . . 271, 343\nBayes formulae. . . . . . . . . . . . . . . . . .45, 64\nBayes rule . . . . . . . . . . . . . 45, 47, 66, 353 f.\nALPHABETICAL INDEX\nBayes theorem . . . . 42, 46\u201350, 65 f., 68 ff.\nBayesian. . . . . . . . . . . . . . . . . . . . . . . . . . . .77\nBayesian analysis. . . . . . . . . . . . . . . .65, 77\nBayesian approximation . . . . . . . . . . . 192\nBayesian deep learning . . . . . 55, 77, 352\nBayesian dropout . . . . . . . . . . . . . . . . . . 352\nBayesian inference. . . . . . . . . . . . . . .42, 45\nBayesian machine learning. . . . . . . . . .54\nBayesian neural networks. . . . . .55 f., 79\nBayesian paradigm . . . . . . . . . . . . . . . . . 42\nBayesian statistical conclusions . . . . . 65\nBayesian statistics . . . . . . . . . . . . . . . 42, 65\nBernoulli . . . . . . . . . . . . . . . . . . . . . . . 75, 277\nBernoulli distribution . . . . . . . . . . . . . . . 53\nBernoulli random variable . . . . . . . . . . 18\nBernoulli trial . . . . . . . . . . . . . . 42 f., 59, 62\nBeta binomial. . . . . . . . . . . . . . . . . . . . . .146\nBeta binomial distribution. . . . . . . . .54 f.\nBeta distribution . . . . . . . 42, 55, 146, 176\nBeta prior. . . . . . . . . . . . . . . . . . . . . . . . . . .55\nBias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\nBiased coin. . . . . . . . . . . . . . . . . . . . .92, 349\nBiased coin toss . . . . . . . . . . . . . . . . . 64, 92\nBiases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247\nBinary class. . . . . . . . . . . . . . . . . . . . . . . . .38\nBinary classi\ufb01cation 12, 15, 96, 137, 190,\n193 f., 246\nBinary code. . . . . . . . . . . . . . . . . . . . . . . . .90\nBinary logistic regression . . . . . . . . 14, 31\nBinary options . . . . . . . . . . . . . . . . . . . . 48 f.\nBinary response. . . . . . . . . . . . . . . . . . . . .14\nBinary response variable . . . . . 19, 94, 97\nBinomial. . . . . . . . . . . . . . . . . . . .43, 53, 354\nBinomial distribution31, 43, 52 f., 55, 59,\n78\nBinomial likelihood . . . . . . . . . . . . 54, 178\nBinomial random variable . . . . . 43, 59 f.\nBlocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318\nBN . . . . . . . . . . . . . . . . . . . 273 f., 277, 324 ff.\nBNN . . . . . . . . . . . . . . . . . . . . . . . . . . 55 f., 79\nBNNs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352\nBohm and Hiley . . . . . . . . . . . . . . . . . . . . 87\nBoltzmann. . . . . . . . . . . .58, 86, 100 f., 118\nBoltzmann entropy . . . . . . . . . . . . . . . . 118\nBoltzmann\u2019s constant . . . . . . . . . . . . . . 100\nBoltzmanns entropy . . . . . . . . . . . . . . . 101\nBoosting. . . . . . . . .186, 189, 193, 198, 200\nBootstrap aggregation. . . . . . . . .189, 192\nBosons. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .45\nBosons and fermions. . . . . . . . . . . . . . . .46\nBottleneck . . . . . . . . . . . . . . . . . . . . 279, 326\nBrazilian rain forest . . . . . . . . . . . . . . . . . 94\nBreast cancer . . . . . . . . . . . . . . . . . . . . . . . 17\nC\nCalculus . . . . . . . . . . . . . . . . . 80, 122 f., 143\nCalculus in deep learning . . . . . . . . . . 123\nCancer. . . . . . . . . . . . . . . . . . . . . .16, 43, 208\nCannabinoids. . . . . . . . . . . . . . . . . . . . . . .96\nCannabis . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\nCDC. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .354\nCE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .251\nChain of spherical bacteria . . . . . . . . . . 20\nChain rule . . . . . . . . . . . . . . . . . . . . . . . . . 163\nChaotic distribution . . . . . . . . . . . . . . . . 38\nCI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nClass probabilities. . . . . . . . . . . . .190, 199\nClassic bagging . . . . . . . . . . . . . . . . . . . . 199\nClassic logistic regression . . . . . . . . . . . 35\nClassic normalization . . . . . . . . . . . . . . . 29\nClassical committee machines. . . . . .189\nClassical machine learning. . . . . . . . .201\nClassical probability . . . . . . . . . . . . . . . . 42\n374\nChapter 10\nALPHABETICAL INDEX\nClassi\ufb01cation . . . . . 32, 206, 208, 289, 345\nClassi\ufb01cation and information gain . 94,\n110\nClaud Shannon . . . . . . . . . . . . . . . . . . . . . 90\nCM . . . . . . . . . . . . . . . . . . . . . . . . . . . 261, 316\nCNN . . . 8, 190, 192, 205 f., 216, 272, 274,\n318, 326, 344, 349\nCNN arithmetics . . . . . . . . . . . . . . . . . . 318\nCNN as Fixed Feature Extractor . . . 206,\n216\nCNN classi\ufb01ers . . . . . . . . . . . . . . . . . . . . 192\nCNN feature extraction . . . . . . . . . . . . 206\nCNN layers. . . . . . . . . . . . . . . . . . . . . . . .343\nCNN model predictions . . . . . . . . . . . 190\nCNN parameters . . . . . . . . . . . . . . . . . . 207\nCNN residual blocks. . . . . . . . . . . . . . .326\nCoef\ufb01cients . . . . . . . . . . . . . . . . . . 12, 16, 27\nCoffee consumption . . . . . . . . . . . . . . . . 36\nCoin toss . . . . . . . . . . . . . . . . . . . . . . . . . . 349\nCoin toss probabillity . . . . . . . . . . . . . . . 93\nCommon con\ufb01dence levels. . . . . . . . . .21\nComplementary probability. . . . . . . . .63\nComputational graph . . . . . . . . . . . . . . 140\nComputational graphs. .127, 140 f., 165,\n168\nConcave . . . . . . . . . . . . . . . . . . . . . . 154, 202\nConcave and Convex functions . . . . 101\nConcavity. . . . . . . . . . . . . . . . . . . . .106, 154\nConcavity of the logarithm . . . . . . . . 106\nConditional entropy . . . . . . . . . . . . . . . 118\nConditional independence . . . . . . . . . . 66\nConditional probability42, 44\u201350, 62, 69\nCon\ufb01dence intervals . . . . . . . . . . . . . . . . 37\nConfusion matrics. . . . . . . . . . . . .261, 316\nConfusion matrix . . . . . . . . . . . . . . . . . . 316\nConjugate prior . . . . . . . . . . . . . . . . . . . . 54\nConjugate priors. . . . . . . . . . . . . . .54 f., 77\nContent loss . . . . . . . . . . . . 214, 216, 224 f.\nConv2D. . . . . . . . . . . . . . . . . . . . . . .271, 343\nConv2d layer . . . . . . . . . . . . . . . . . . . . . . 223\nConv4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219\nConvex . . . . . . . . . . . . . . . . . . . . . . . 132, 202\nConvex down function . . . . . . . . . . . . 119\nConvex functions . . . . . . . . . . . . . . . . . . 132\nConvNet\u2019s as \ufb01xed feature extractors\n206\nConvolution . . . . . . . . . . . . . . 234, 277, 291\nConvolution and correlation in python\n294\nConvolution complexity . . . . . . . . . . . 240\nConvolution layer. . . . . . . . . . . . .268, 321\nConvolutional layer . . . . . . . . . 268, 321 f.\nConvolutional neural network . . . . . . . 8\nConvolutional neural networks192, 198\nCorrelation . . . . . . . . . . . . . . . . . . 234 f., 291\nCost . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247\nCost function . . . . . . . . . . . . . . . . . . . . . . 247\nCovariance . . . . . . . . . . . . . . . . . . . . . . . . 189\nCovariates . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nCOVID19 . . . . . . . . . . . . . . . . . . . . . 345, 351\nCPP 23 f., 38 f., 142 f., 168 f., 242 f., 254 f.,\n307 ff.\nCPP hypothesis . . . . . . . . . . . . . . . . . . . . . 23\nCPU . . . . . . . . . . . . . . . . . . . . . . . . . . 222, 289\nCPU tensor . . . . . . . . . . . . . . . . . . . . . . . . 222\nCross correlation . . . . . . . . . . . . . . 235, 291\nCross entropy . . . . . . . . . . . . . . . . 25 f., 251\nCross entropy loss. . . . . . . . . . . . .214, 251\nCross validation . . . . . . . . . . 231, 289, 328\nCross validation approaches. . .231, 289\nCUDA. . . . . . . . . . . . . . . . . . . . . . . . . . . . .289\nCV. . . . . . . . . . . . . . . . . . . . . . . . . . . . 231, 289\nCV approaches . . . . . . . . . . . . . . . . . . . . 289\n375\nALPHABETICAL INDEX\nD\nDAG. . . . . . . . . . . . . . . . .123, 126, 141, 168\nData Science . . . . . . . . . . . . . . . . . . . . . . . . . 4\nDecision boundary. . . . . . . . . . . . . . . . . .14\nDecision tree . . . 94 f., 97 f., 111, 187, 198\nDecision trees . . . . . . . . . . . . . 94, 96 f., 348\nDecision trees and cannabinoids\nadministration . . . . . . . . . . . . . . 96\nDeep Learning . . . . . . . . . . . . . . . . . . . . . . . 4\nDeep learning . . . . . 22, 77, 123, 196, 352\nDeep Learning Job Interviews . . . . . . . . 6\nDeep learning pipelines. . . . . . . . . . . .221\nDental amalgam . . . . . . . . . . . . . . . . . . . . 19\nDercum disease. . . . . . . . . . . . . . . . . . . . .47\nDifferentiation . . . . . . . . . . 122, 143 f., 150\nDifferentiation in deep learning . . . . 123\nDirect derivation. . . . . . . . . . . . . . . . . . . .32\nDirected Acyclic Graph . . . . . . . . . . . . 168\nDirected acyclic graph . . . . . . . . . . . . . 141\nDirected acyclic graphs. . . . . . . .126, 147\nDirectional derivative. . . . . . . . . . . . . .131\nDirectional derivatives. . . . . . . . . . . . .125\nDistribution . . . . . . . . . . . . . . . . . . . . . . . . 45\nDL . . . . . . . . . . . . . . 123, 196, 206, 221, 352\nDL classi\ufb01cation pipeline . . . . . . . . . . . 91\nDL job interviews. . . . . . . . . . . . . . . . . .206\nDN. . . . . . . . . . . . . . . . . . . . . . . . . .138 f., 163\nDouble reading. . . . . . . . . . . . . .282 f., 329\nDPN CNN. . . . . . . . . . . . . . . . . . . . . . . . .223\nDropout8, 57, 267 f., 277, 319 f., 326, 352\nDropout as a bayesian approximation\n192\nDropout in PyTorch. . . . . . . . . . . . . . . . .56\nDropout layer . . . . . . . . . . 57, 267 f., 319 f.\nDropped out neurons . . . . . . . . . . . . . . . 57\nDual numbers. . . . . . . . . .138 ff., 163, 165\nDual numbers in AD . . . . . . . . . . 138, 163\nE\nEbola. . . . . . . . . . . . . . . . . . . . . . . . . 53, 354 f.\nEmbedding . . . . . . . . . . . . . . . . . . . . . . . . 206\nEncoded messages . . . . . . . . . . . . . . . . . . 51\nEncrypted communications . . . . . . . . . 50\nEnigma machine . . . . . . . . . . . . . . . . . . . . 50\nEnsemble averaging . . . . . . . . . . . . . . . 193\nEnsemble learning . . . . . . . . 186, 194, 201\nEnsemble methods . . . . . . . . . . . . 190, 195\nEnsembling . . . . . . 186 ff., 190, 194 f., 197\nEntropy22, 38, 86 f., 89, 93, 95, 97 f., 106,\n108, 214, 349\nEntry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\nEpidemic . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\nEquiprobable events.90 f., 103, 105, 118\nEquiprobable sample . . . . . . . . . . . . . . 189\nEquivocation . . . . . . . . . . . . . . . . . . . . . . . 99\nEradication . . . . . . . . . . . . . . . . . . . . . . . . 347\nEradication probabillity . . . . . . . . . . . . . 18\nEuclidean . . . . . . . . . . . . . . . . . . . . . 288, 333\nExpansion of stars . . . . . . . . . . . . . . . . . . 97\nExpectation . . . . . . . . . . . . . . . . . . . . . . . . . 62\nExpectation and variance . . . . . . . . 42, 59\nExplanatory variable. . . . . . . . . . . . . . . .17\nExponential family. . . . . . . . . . . . . . . . . .78\nF\nFc7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219\nFeature extraction 214 f., 224 f., 349, 351\nFeature vector. . . . . . . . . . . . . . . . .205, 350\nFeature vectors . . . . . . . . . . . . . . . . . . . . . 96\nFeed forward neural networks 135, 158\nFermions . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\nFFNN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n376\nChapter 10\nALPHABETICAL INDEX\nFiltering . . . . . . . . . . . . . . . . . . . . . . . . . . . 234\nFiltering kernel . . . . . . . . . . . . . . . . . . . . 234\nFilters. . . . . . . . . . . . . . . . . . . . . . . . .239, 293\nFinancial mathematics . . . . . . . . . . . . . . 42\nFine tuning CNNs . . . . . . . . . . . . 213, 222\nFinite difference rule . . . . . . . . . . 125, 147\nFisher . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\nFisher information . . . . . . . . . 51, 53, 73 f.\nFisher score . . . . . . . . . . . . . . . . . . . . . . . . . 73\nFliping . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294\nForward mode . . . . . . . . . . 131, 140 f., 168\nForward mode AD . 140 f., 163, 166, 168\nForward mode AD table construction\n142, 168\nForward pass . 125, 127, 135, 137, 139 ff.,\n157 f., 160, 163, 165, 168\nG\nGausiian distribution. . . . . . . . . .241, 295\nGaussian . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\nGaussian bell . . . . . . . . . . . . . . . . . . . . . . 241\nGaussian distribution . . . . . . . . . 274, 324\nGaussian PDF . . . . . . . . . . . . . . . . . . . . . 324\nGeneral concepts . . . . . . . . . . . . . . . . 12, 27\nGeneralization . . . . . . . . . . . . . . . . 186, 206\nGeneralized delta rule . . . . . . . . . . . . . 135\ngeneralized linear models. . . . . . . . . . .14\nGLM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nGLMs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\nGPU . . . . . . . . . . . . . . . . . 222, 281, 289, 327\nGPU tensor . . . . . . . . . . . . . . . . . . . . . . . . 222\ngradcheck . . . . . . . . . . . . . . . . . . . . . . . . . 310\nGradient . . . . . . . . . . . . . . . . . . . . . . 130, 247\nGradient descent 123, 130, 146, 158, 247\nGradient descent algorithm . . . . . . . . 132\nGradient descent and backpropagation\n124\nGradients. . . . . . . . . . . . . . . . . . . . . . . . . .222\nGram matrix. . . . . . . . . . . . . . . . . . . . . . .225\nGrid search . . . . . . . . . . . . . . . . . . . 282, 328\nGum bacteria . . . . . . . . . . . . . . . . . . . . . . . 20\nGUR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .135\nH\nHereditary disease . . . . . . . . . . . . . . . . . . 66\nHereditary diseases . . . . . . . . . . . . . . . . . 47\nHessian. . . . . . . . . . . . . . . . . . . . . . . . . . . . .74\nHessian matrix . . . . . . . . . . . . . . . . . . . . . 52\nHeterogeneous ensembling. . . .191, 200\nHidden layer . . . . . . . . . . . . . . . . . . . 78, 248\nHidden layers . . . . . . . . . . . . . . . . . . . . . 250\nHidden node . . . . . . . . . . . . . 248, 252, 343\nHinton . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252\nHistopathology . . . . . . . . . . . . 43, 217, 351\nHuang1704snapshot . . . . . . . . . . . . . . . 202\nHuman voice activity . . . . . . . . . . . . . . . 31\nHyperbolic tangent . . . . . . . . . . . . . . . . 134\nHyperbolig tangent . . . . . . . . . . . . . . . . 138\nHyperparameter optimization . . . . . 282,\n327 f.\nHyperparameters. . . . . . . . . . . . . . . . . .328\nHypotheis . . . . . . . . . . . . . . . . . . . . . . . . . . 16\nI\nIdeal classi\ufb01er. . . . . . . . . . . . . . . . .262, 317\nIdentity connection . . . . . . . . . . . . . . . . 326\nImage analysis. . . . . . . . . . . . . . . . . . . . .110\nImage and text similarity . . . . . . . . . . 296\nImage processing . . . . . . . . . . . . . . . . . . 234\nImageNet. . . . . . . . . . . . . . . . . .206 f., 222 f.\nImageNet pre trained CNNs . . . . . . . 213\n377\nALPHABETICAL INDEX\nImageNet pretrained CNN classi\ufb01ers\n192\nImproper prior . . . . . . . . . . . . . . . . . . . . . 54\nIndependent binary co variates . . . . . 94\nIndependent events. . . . . . . . . . . . . . . . .45\nIndependent variables. . . . . . . . . . .19, 97\nIndividual predictions . . . . . . . . . . . . . 192\nInductive inference . . . . . . . . . . . . . . . . . 86\nInference. . . . . . . . . . . . . . . . . . . . . .286, 330\nInformation gain . . . . . . . . . . 94\u201398, 106 f.\nInformation gain values. . . . . . . . . . . . .95\nInformation matrix . . . . . . . . . . . . . . . . . 53\nInformation theory . . . . . . . 58, 86, 88\u201393,\n98\u2013101, 106, 347\nInteractions . . . . . . . . . . . . . . . . . . . . . . . . . 13\nIntermediate value theorem. . . . . . . .124\nIntersected events. . . . . . . . . . . . . . . . . . .63\nIntroduction. . . .12, 42, 86, 122, 186, 205\nJ\nJacard similarity . . . . . . . . . . . . . . . . . . . 297\nJAX . . . . . . . . . . . . . . . . . . . . . . . . . . . 136, 158\nJensen . . . . . . . . . . . . . . . . . . . . . . . . 101, 119\nJensen\u2019s inequality . . . . . . . . . . . . 101, 118\nJob Interview . . . . . . . . . . . . . . . . . . . . . . . . 4\nJohn von Neumann . . . . . . . . . . . . . . . . . 41\nJoint distribution . . . . . . . . . . . . . . . . . . 110\nJupyter notebook . . . . . . . . . . . . . . . . . . 143\nK\nK Fold cross validation . . . . . . . . . . . . 289\nK way FC layer . . . . . . . . . . . . . . . . . . . . 217\nK-Fold cross validation . . . . . . . . . . . . 232\nKaggle . . . . . . . . . . . . . . . . . . . . . . . . 186, 201\nKaggle competitions . . . . . . . . . . . . . . . 201\nKaiming . . . . . . . . . . . . . . . . . . . . . . . . . . . 258\nKernel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234\nKernels . . . . . . . . . . . . . . . . . . . . . . . 239, 293\nKL divergence . . . . . . . . 53, 93, 100 f., 109\nKLD . . . . . . . . . . . . . . . . . . . . . . . 93, 119, 297\nKullback Leibler . . . . . . . . . . . . . . . . . . . 297\nKullback Leibler divergence 87, 93, 108\nL\nL1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288, 333\nL2 . . . . . . . . . . . . . . . . . . . . . . . . . . . 288, 333 f.\nLabelling and bias . . . . . . . . . . . . . . . . . 328\nLaTeX. . . . . . . . . . . . . . . . . . . . . . . . .174, 176\nLaw of total probability42, 46\u201350, 66\u201370\nLaws of data compression . . . . . . . . . . 86\nLDCT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\nLeaky ReLU . . . . . . . . . . . . . . . . . . . . . . . 259\nLearning logical gates. . . . . . . . . . . . . .305\nLearning rate schedules in ensembling\n197, 202\nLeave one out CV. . . . . . . . . . . . . . . . . .290\nLeave-one-out CV . . . . . . . . . . . . . . . . . 234\nLibtorch . . . . . . . . . . . . . . 254 f., 257, 307 ff.\nLikelihood. . . . . . . . . . . . . . . . . . . .44 f., 353\nLikelihood function . . . 51, 53, 56, 73, 79\nLikelihood parameter . . . . . . . . . . . . . . . 45\nLimits and continuity . . . . . . . . . 130, 151\nLinear classi\ufb01ers . . . . . . . . . . . . . . . . . . . 219\nLinear combination of regression . . 201\nLinear decision boundary . . . . . . . . . . . 14\nLinear logistic regression model. . . . .33\nLinear model in PyTorch . . . . . . . . . . . . 24\nLinear regression . . . . . . . . . . . . . . . . . . 133\nLinear transformation . . . . . . . . . . . . . 343\nLinearity . . . . . . . . . . . . . . . . . . . . . . . . . . 235\nLink function . . . . . . . . . . . . . . . . . . . . . . . 31\nLocal minima . . . . . . . . . . . . . . . . . 198, 202\n378\nChapter 10\nALPHABETICAL INDEX\nLog likelihood . . . . . . . . . . . . . . . . . . . . . . 13\nLog likelihood function. .51, 53, 73, 355\nLog loss . . . . . . . . . . . . . . . . . . . . . . . . . . . 284\nLog odds . . . . . . . . . . . . 13 f., 17 f., 20 f., 29\nLogarithm . . . . . . . . . . . . . . . . . . . 35, 53, 72\nLogarithmic function . . . . . . . . . . . . . . 166\nLogarithms . . . . . . . . . . . . 88 f., 101 ff., 172\nLogarithms in information theory . . . 87\nLogic gate . . . . . . . . . . . . . . . . . . . . . . . . . 252\nLogical gates . . . . . . . . . . . . . . . . . . 251, 305\nLogistic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\nLogistic inverse . . . . . . . . . . . . . . . . . . . . . 14\nLogistic regression12\u201316, 24 ff., 28 f., 31,\n36, 137, 345\n\u2022 Sigmoid. . . . . . . . . . . . . . . . . . . . . .253\nLogistic regression classi\ufb01er. . . . . . . . .19\nLogistic regression coef\ufb01cients . . . . . . 16\nLogistic regression implementation23 f.\nLogistic regression in C++ . . . . . . . . . . 39\nLogistic regression in Python . . . . . . . 26\nLogistic regression model. . . . . . . .27, 35\nLogistic regression predictor variable12\nLogistic regression threashold. . . . . . .39\nLogistic response function . . . . . . . . . . 33\nLogit . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14, 32\nLogit equation . . . . . . . . . . . . . . . . . . . . . . 16\nLogit function. . . . . . . . . . . . . . . .14, 22, 31\nLogit inverse. . . . . . . . . . . . . . . . . . . . . . . .14\nLogit transformation . . . . . . . . . . . . . . . . 14\nLogit value . . . . . . . . . . . . . . . . . . . . . . . . . 33\nLOOCV . . . . . . . . . . . . . . . . . . . . . . . 234, 290\nLoss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334\nLoss function . . . . . . . . . . . . . . . . . . . . . . 133\nLow model generalization . . . . . . . . . 109\nLow standard error . . . . . . . . . . . . . . . . . 75\nLower entropy. . . . . . . . . . . . . . . . . . . . . .38\nLR . . . . . . . . . . . . . 16, 27, 33, 133, 137, 345\nLR coef\ufb01cients . . . . . . . . . . . . . . . . . . . . . . 16\nLung cancer . . . . . . . . . . . . . . . . . . . . 17, 282\nM\nM.Sc in Arti\ufb01cial Intelligence. . . . . . . . .4\nMachine learning . . . . . . 13 f., 25, 28, 316\nMachine learning terminology . . . . . . 13\nMacLaurin expansion. . . . . . . . . . . . . .128\nMacLaurin series. . . . . . . . . . . . . . . . .128 f.\nMagna Carta. . . . . . . . . . . . . . . . . . . . . . . .90\nMajority voting . . . . . . . . . . . 186, 190, 202\nMalignant tumour . . . . . . . . . . . . . . . . . . 17\nMalignant tumours . . . . . . . . . . . . . . . . . 96\nManhattan . . . . . . . . . . . . . . . . . . . . 288, 333\nManual differentiation . . . . . . . . 124, 170\nMaster\u2019s programme in Arti\ufb01cial\nIntelligence. . . . . . . . . . . . . . . . . . .4\nMasters programme . . . . . . . . . . . . . . . . . 4\nMathJax . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\nMaximum likelihood estimatator. . . .73\nMaximum likelihood estimation . 51, 71\nMaxpool2D . . . . . . . . . . . . . . . . . . . 271, 343\nMaxPooling . . . . . . . . . . . . . . . . . . . . . . . 322\nMaxwell Boltzmann distribution . . . . 57\nMaxwell distribution . . . . . . . . . . . . . . . 58\nMean \ufb01lter. . . . . . . . . . . . . . . . . . . . . . . . .241\nMean square error . . . . . . . . . . . . . . . . . 225\nMeasurement vector . . . . . . . . . . . . . . . . 16\nMechanical statistics . . . . . . . 42, 100, 118\nMedical AI . . . . . . . . . . . . . . . . . . . . . . . . 217\nMelanoma . . . . . . . . . . . . . . . . . . . . . . . . . 213\nMigraine probabillity . . . . . . . . . . . . . . . 20\nMinHash . . . . . . . . . . . . . . . . . . . . . . . . . . 298\nML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316\nMLE. . . . . . . . . . . . . . . . . . .51, 53, 72 f., 355\nMLP. . . . . . . . . . . . . . .246 ff., 252, 299, 343\n379\nALPHABETICAL INDEX\nMomentum. . . . . . . . . . . . . . . . . . . . . . . .332\nMonolithic and heterogeneous\nensembling . . . . . . . . . . . . 191, 200\nMonolithic architectures . . . . . . . . . . . 200\nMonolithic ensembling . . . . . . . . . . . . 191\nMonotonically increasing function . . 72\nMonte Carlo dropout . . . . . . . . . . . . . . 192\nMSE. . . . . . . . . . . . . . . . . . . . . .225, 288, 333\nMulti class responses . . . . . . . . . . . . . . . 29\nMulti Layer Perceptrons . . . . . . . . . . . 246\nMulti layer perceptrons . . . . . . . . . . . . 299\nMulti model ensembling . . . . . . 196, 202\nMulticlass classi\ufb01cation . . . . . . . . . . . . . 12\nMulticlass classi\ufb01cation problems . . . 12\nMultivariable . . . . . . . . . . . . . . . . . . . . . . . 12\nMultivariable methods. . . . . . . . . . . . . .12\nMutual information. . .86, 94, 98 ff., 110,\n116\nMutual information formulae . . . . . . 117\nN\nN dimensional feature vector . . . . . . 205\nNatural logistic function . . . . . . . . . . . . 14\nNatural logistic sigmoid . . . . . . . . . . . . 14\nNegative log likelihood . . . . . . . . . . . . . 13\nNeural network . . . . . . . . . . . . . . . 195, 202\nNeural network ensembles . . . . 186, 191\nNeural networks . . 55, 57, 127, 135, 158,\n186\nNeural style transfer . . . . . . . . . . . . . 214 f.\nNeuron activation function . . . . . . . . . 15\nNew York stock exchange . . . . . . . . . . . 48\nNLL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\nNN . . . . . . . . . . 55, 127, 135, 158, 186, 202\nNN Layers . . . . . . . . . . . . . . . . . . . . . . . . 318\nNoise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\nNon convex neural networks . . . . . . 203\nNon informative prior . . . . . . . . . . . . . . 54\nNon informative priors . . . . . . . . . . . . . 77\nNon interacting identical particles . 118\nNon linearity . . . . . . . . . . . . . . . . . . . . . . 301\nNon-differentiable . . . . . . . . . . . . . . . . . 301\nNon-linearity . . . . . . . . . . . . . . . . . . . . . . 248\nNonlinear layer . . . . . . . . . . . . . . . 253, 306\nNormal distribution. . . . . . . . . . .274, 324\nNormalization constant . . . . . . . . . . . . . 64\nNST . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214 f.\nNumerical Differentiation. . . . . . . . . .147\nNumerical differentiation. . .124 ff., 146,\n173\nNumerical instability . . . . . . . . . . . . . . 146\nNumpy. . . . . . . . . . . . . . . . . . . . . . . . . . . .221\nO\nOctahedral dice. . . . . . . . . . . . . . . . . . . .101\nOdds . . . . . . . . . . . . . . . . . . . . . . . . . . 12 f., 29\nOdds of success in a binary response14\nOnOffLayer . . . . . . . . . . . . . . . . . . . . . 56, 78\nOOM . . . . . . . . . . . . . . . . . . . . . . . . . 281, 327\nOptimization. . . . . . . . . . . . . . . . . .131, 153\nOptimization loss. . . . . . . . . . . . . . . . . .331\nOrdinary predictors. . . . . . . . . . . . . . . . .28\nOut of memory . . . . . . . . . . . . . . . 281, 327\nOver\ufb01tting. . . . . . . . . . . . . . . . . .12, 27, 194\nP\nP value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\nPadding . . . . . . . . . . . . . . . . . . . . . . 236, 292\nPancreactic cancer . . . . . . . . . . . . . . . . . . 43\nPancreatic cancer classi\ufb01cation. . . . .208\nPartial derivative . . . . . . . . . . . . . . . . . . . 53\nPartial derivatives. . . . . .130 ff., 142, 152\n380\nChapter 10\nALPHABETICAL INDEX\nParticle physics . . . . . . . . . . . . . . . . . . . . . 45\nPDF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\nPerceptron . . . . . . . . . . . . . . . . . . . . 246, 299\nPerceptron learning rule . . . . . . . . . . . 252\nPerceptrons . . . . . . . . . . 299, 301, 304, 343\nPerformance metrics . . . . . . . . . . . . . . . 316\nPhysical constants . . . . . . . . . . . . . . . . . 100\nPlacenta Chorion Test. . . . . . . . . . . . . .353\nPlacenta chorion test . . . . . . . . . . . . . . 46 f.\nPlanck\u2019s constant . . . . . . . . . . . . . . . . . . 100\nPlateau . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284\nPMF . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43, 59\nPoisson . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\nPoisson distribution . . . . . . . . . . . . . . . . 53\nPooling Layer . . . . . . . . . . . . . . . . . . . . . 270\nPooling layer . . . . . . . . . . . . . . . . . . . . . . 322\nPosterior. . . . . . . . . . . . . . . . . . . . . . . . . . . .45\nPosterior and prior predictive\ndistributions . . . . . . . . . . . . . . . . 54\nPosterior distribution . 54, 146, 180, 354\nPosterior predictive distributions . . . 76\nPre trained CNN . . . . . . . . . . . . . . . . . . 349\nPre trained CNNs. . . . . . . . . . . . . . . . . .205\nPre trained VGG19 CNN model. . . .220\nPrecision . . . . . . . . . . . . . . . . . . . . . . . . . . 316\nPredictor variables . . . . . . . . . . . . . . . . . . 28\nPrior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .45\nPrior distribution . . . . . . . . . . . . . . . . . . . 45\nPrior distributions . . . . . . . . . . . . . . . . . . 77\nPrior predictive distribution . . . . 54, 354\nProbabilistic programming. . . . . . . . . .42\nProbability distribution. . . . . . . . . .13, 94\nProbability mass function. . . . . . . .43, 60\nProbability of failure . . . . . . . . . . . . . . . . 28\nProbability space . . . . . . . . . . . . . . . . . . . 44\nProbability statements . . . . . . . . . . . . . . 65\nProblems . . . . . . . . . . . . . . . . . . 12, 186, 206\nProton theraphy . . . . . . . . . . . . . . . . . . . . 43\nProton therapy . . . . . . . . . . . . . . . . . . 16, 43\nPT. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .16, 43\nPulmonary nodules . . . . . . . . . . . 282, 345\nPyMc3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\nPython . 7, 23\u201327, 38 ff., 42, 56 f., 88, 102,\n107 f., 112, 114, 123, 134, 136,\n138, 140, 143 f., 157, 159 f., 163,\n165 f., 170, 172 f., 175 ff., 179,\n181, 191, 195\u2013198, 202, 206,\n210 f., 218, 221, 223 f., 232,\n239 ff., 250 f., 256 f., 263 f., 266 ff.,\n272, 282, 288, 294 f., 300\u2013304,\n312, 319 f., 330, 343 f., 349\nPython coin toss . . . . . . . . . . . . . . . . . . . 108\nPython interpreter . . . . . . . . . . . . . . . . . . 88\nPyTorch . 7, 23\u201326, 38, 40, 56 f., 123, 134,\n136, 138, 140, 143, 157, 159 f.,\n163, 165 f., 170, 173, 176 f., 181,\n191, 195 ff., 202, 206, 210 f., 218,\n221, 223 f., 254\u2013257, 267 f., 272,\n288, 307 ff., 319 f., 343 f., 349\nPytorch. . . . . . . . . . . . . . . . . . . . . . . . . . . .143\nPyTorch code snippet for an ensemble\n191\nPyTorch sequential . . . . . . . . . . . . . . . . 257\nPyTorch tanh . . . . . . . . . . . . . . . . . . . . . . 257\nQ\nQuadratic equation . . . . . . . . . . . . . . . . . 80\nQuantum drop. . . . . . . . . . . . . . . . . . . . . .57\nQuantum physics. . . . . . . . . . . . . . . . . .100\nQuantum states. . . . . . . . . . . . . . . . . . . . .45\nQuantum term speed . . . . . . . . . . . . . . . 79\n381\nALPHABETICAL INDEX\nR\nRadiation therapy . . . . . . . . . . . . . . . 17, 98\nRadiation therapy planning . . . . . . . . . 17\nRadiology . . . . . . . . . . . . . . . . . . . . . . . . . 282\nRandom guess classi\ufb01er . . . . . . . 262, 317\nRandom number seeds . . . . . . . . . . . . 186\nRandom search . . . . . . . . . . . . . . . 282, 328\nRecall . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316\nReceiver Operating Characteristic. .261\nReceiver operating characteristic . . . 316\nRecti\ufb01cation . . . . . . . . . . . . . . . . . . . . . . . 306\nRelative entropy. . . . .98 f., 109, 117, 349\nRelative maxima and minima . . . . . . 132\nRelative risk . . . . . . . . . . . . . . . . . . . . . . . . 34\nRelative shrinkage frequency . . . . . . 112\nRelative star expansion frequency. .115\nReLU. . . .248 f., 253, 258 f., 301, 306, 314\nRendering sympy in Google colab . 143\nResNet . . . . . . . . . . 205, 207, 211, 217, 223\nResNet152 . . . . . . . . . . . . . . . . . . . . . . . . . 205\nResNet18 . . . . . . . . . . . . . . . . . . . . . . . . . . 201\nResNet34 . . . . . . . . . . . . . . . . . 205, 211, 349\nResNet34 CNN . . . . . . . . . . . . . . . . . . . . 211\nResNetBottom . . . . . . . . . . . . . . . . . . . . . 211\nResNets . . . . . . . . . . . . . . . . . . . . . . . . . . . 326\nResponse variable . . . . . . . . . . 12 f., 17, 29\nReversing probabilities . . . . . . . . . . . . . 47\nROC . . . . . . . . . . . . . . . . . . . . . . . . . . 261, 316\nROC AUC . . . . . . . . . . . . . . . . . . . . . . . . . 316\nROC-AUC. . . . . . . . . . . . . . . . . . . . . . . . .261\nRosenblatt . . . . . . . . . . . . . . . . . . . . . . . . . 252\nRR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .34\nRussakovsky . . . . . . . . . . . . . . . . . . . . . . 206\nRussakovsky 2015 . . . . . . . . . . . . . . . . . 206\nS\nSaddle points . . . . . . . . . . . . . . . . . . . . . . 155\nSame padding . . . . . . . . . . . . 236, 238, 292\nSample odds ratio . . . . . . . . . . . . . . . . . . 37\nSampling approaches . . . . . . . . . . . . . . 189\nSampling with replacement . . . 189, 199\nSampling without replacement 189, 199\nSearch space . . . . . . . . . . . . . . . . . . 282, 328\nSecond derivative test . . . . . . . . . . . . . 132\nSeed values in AD. . . . . . . . . . . . .142, 170\nSequential . . . . . . . . . . . . . . . . . . . . . . . . . 221\nSGD . . . . . . . . . . . . . . . . . . . . . . 286 f., 330 ff.\nShannon . . . . . . . 86 f., 89, 100, 103 f., 117\nShannon bit. . . . . . . . . . . . . . . . . . . . . . . . .90\nShannon\u2019s famous general formulae\n103\nShannon\u2019s general formulae . . . . . . . . 89\nShift-invariance. . . . . . . . . . . . . . . . . . . .235\nSigmoid . . . 15, 23, 32, 134, 137, 144, 160,\n253, 306\nSigmoid activation function . . . . 33, 137,\n157 f., 160\nSigmoid derivative . . . . . . . . . . . . . . . . . 15\nSigmoid function . . . . . . . . . . . . . . . . . . 157\nSigmoid gradient. . . . . . . . . . . . . .144, 173\nSigmoid in SymPy . . . . . . . . . . . . . . . . . 173\nSigmoidal neuron. . . . . . . . . . . . . . . . . .247\nSigmoidal perceptron . . . . . . . . . . . . . . 246\nSimilarity measures. . . . . . . . . . . . . . . .296\nSimple differentiation . . . . . . . . . 144, 172\nSingle Layer Perceptrons. . . . . . . . . . .246\nSingle layer perceptrons . . . . . . . . . . . 299\nSingle model based AI systems . . . . 186\nSingle predictors. . . . . . . . . . . . . . . . . . .201\nSkip connection. . . . . . . . . . . . . . . . . . . .326\nSnapshot ensembling . . . 189 f., 195, 201\n382\nChapter 10\nALPHABETICAL INDEX\nSobel \ufb01lter . . . . . . . . . . . . . . . . . . . . . . . . . 294\nSoftmax . . . . . . . . . . . . . . . . . . . . . . . . . . . 251\nsoftmax. . . . . . . . . . . . . . . . . . . . . . . . . . . .217\nSoftmax activation . . . . . . . . . . . . . . . . . 251\nSoftmax activation function . . . . . . . . . 32\nSoftmax derivation . . . . . . . . . . . . . . . . . 32\nSoftmax function . . . . . . . . . . . . . . . . 32, 40\nSoftmax layers . . . . . . . . . . . . . . . . . . . . . . 29\nSoftmax neurons. . . . . . . . . . . . . . . . . . .214\nSolutions . . . . . . . . . . . . . . . . . . . . . . . . . . 198\nSpeech to text . . . . . . . . . . . . . . . . . . . . . . . 49\nSpeed of light in vacum. . . . . . . . . . . .100\nSperable convolutions. . . . . . . . .241, 295\nSplitting criterion . . . . . . . . . . . . . . . . . . 111\nStacking . . . . . . . . . . . . . . . . . . 186, 189, 198\nStacking and bagging . . . . . . . . . . . . . . 187\nStan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\nStandard deviation . . . . . . . . . . . . . . . . . 61\nStar density. . . . . . . . . . . . . . . . . . . . . . . . .97\nStar expansion. . . . . . . . . . . . . . . . . . . . .115\nStatic committee machines . . . . . . . . . 201\nStatistical distribution. . . . . . . . . . . . . . .44\nStatistical independence . . . . . . . . . . . . 45\nStatistical mechanics. . . . . . . . . . . . .11, 86\nStochastic. . . . . . . . . . . . . . . . . . . . . . . . . .287\nStochastic gradient descent. . . .247, 331\nStochastic gradient descent, SGD . . 286\nStock markets. . . . . . . . . . . . . . . . . . . . . . .48\nStocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\nStrati\ufb01cation . . . . . . . . . . . . . . . . . . 233, 290\nStrati\ufb01ed K fold . . . . . . . . . . . . . . . . . . . 290\nStrati\ufb01ed K-Fold . . . . . . . . . . . . . . . . . . . 233\nStride . . . . . . . . . . . . . . . . . . . . 236, 292, 323\nSTT. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .49\nStyle loss . . . . . . . . . . . . . . . 214, 216, 224 f.\nStyle transfer . . . . . . . . . . . . . . 214 f., 224 f.\nSupervised learning . . . . . . . . . . . . . . . . 28\nSupervised machine learning . . . . . . . 12\nSurprise . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\nSwish . . . . . . . . . . . . . . . . . . . . . . . . . 260, 315\nSymbolic differentiation . . . 123 f., 143 f.,\n172 f.\nSymPy. . . . . . . . .124, 143 f., 146, 173, 177\nT\nTanh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .310\ntanh . . . . . . . . . . . . . . . . . . . . 253, 256 f., 306\nTaylor series . . . . . . . . . . . . . . . . . 122, 128 f.\nTaylor series and dual numbers . . . . 163\nTaylor series expansion . . . . . . 128 f., 150\nTest set . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328\nThe backpropagation algorithm. . . .134\nThe bayesian school of thought . . . . . 42\nThe beta binomial model . . . . . . 144, 174\nThe chain rule. . . . . . . . . . . . . . . . .127, 149\nThe convolution operator . . . . . 234, 291\nThe correlation operator. . . . . . .234, 291\nThe gaussian distribution . . . . . . . . . . 324\nThe gradient descent algorithm . . . . 155\nThe gram matrix . . . . . . . . . . . . . . . . . . . 225\nThe hyperplane . . . . . . . . . . . . . . . . . 14, 31\nThe Kullback Leibler distance. . . . . .297\nThe Likelihood function . . . . . . . . . . . 174\nThe logit function and entropy . . . . . . 38\nThe multi layer perceptron. . . . . . . . .300\nThe Sigmoid . . . . . . . . . . . . . . . . . . . . . . . . 32\nThe sigmoid . . . . . . . . . . . . . . . . . . . . . . . . 15\nThe sigmoid function . . . . . . . . . . . . . . . 29\nThe theory of perceptrons. . . . . . . . . .304\nTheory of CNN design. . . . . . . . . . . . .326\nThermodynamics . . . . . . . . . . 86, 100, 103\nTopologies. . . . . . . . . . . . . . . . . . . . . . . . .318\nToxic mercury fumes . . . . . . . . . . . . . . 18 f.\n383\nALPHABETICAL INDEX\nTrain validation split. . . . . . . . . . . . . . .281\nTraining corpus . . . . . . . . . . . . . . . 189, 200\nTraining curve curve . . . . . . . . . . 283, 329\nTraining hyperparameters . . . . . . . . . 327\nTraining validation epoch . . . . . . . . . . 196\nTransformation . . . . . . . . . . . . . . . . . . . . 222\nTriangle inequality. . . . . . . . . . . . . . . . .109\nTrue probability distribution . . . . . . . . 93\nTruly understanding LR . . . . . . . . . 16, 33\nTTS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\nTumors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\nTumour eradication . . . . . . . . . . . . . 17, 34\nTumour shrinkage . . . . . . . . . . . . . . . . . . 96\nTumour shrinkage in rats . . . . . . . . . . . 22\nTwo dimensional matrix . . . . . . . . . . . . 24\nU\nUncertainty . . . . . . . . . . . . . . . . . . . . . . . 89 f.\nUniversal function approximators . 251\nV\nValid padding . . . . . . . . . . . . 236, 238, 292\nValidation curve . . . . . . . . . . . . . . 283, 329\nValidation curve ACC . . . . . . . . . . . . . 329\nValidation curve Loss . . . . . . . . . . . . . . 329\nValidation set . . . . . . . . . . . . . . . . . . . . . . 328\nVanilla linear regression. . . . . . . . . . . . .14\nVanishing gradients. . . . . . . . . . . . . . . .258\nVariance. . . . . . . . . . . .42 f., 59, 62, 74, 201\nVenn diagram . . . . . . . . . . . . . . . . . 44 f., 99\nVGG . . . . . . . . . . . . . . . . . . . . . . . . . . 205, 207\nVGG conv43 layer . . . . . . . . . . . . . . . . . 209\nVGG fc7 layer . . . . . . . . . . . . . . . . . . . . . 209\nVGG Net. . . . . . . . . . . . . . . . . . . . . .205, 216\nVGG16 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\nVGG19 . . . . . . . . . . . . . . . . . . . 209, 221, 351\nVGG19 architecture . . . . . . . . . . . . . . . . 208\nVGG19 CNN . . . . . . . . . . . . . 208, 218, 351\nVoting power . . . . . . . . . . . . . . . . . . . . . . 201\nVumulative distribution. . . . . . . . . . . . .62\nW\nWald chi squared test . . . . . . . . . . . . . . . 28\nWeight initialization247, 253, 258, 299 f.,\n314\nWest African ebola . . . . . . . . . . . . . . . . . . 52\nWSI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208\nWW2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\nX\nXavier . . . . . . . . . . . . . . . . . . . . . . . . 258, 330\n384",
    "solution": ""
  }
]